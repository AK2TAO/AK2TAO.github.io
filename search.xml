<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>排序</title>
      <link href="/post/a444b428.html"/>
      <url>/post/a444b428.html</url>
      
        <content type="html"><![CDATA[<h1 id="排序简介"><a href="#排序简介" class="headerlink" title="排序简介"></a>排序简介</h1><p>「排序算法 Sorting Algorithm」使得列表中的所有元素按照从小到大的顺序排列。</p><ul><li>待排序的列表的 <strong>元素类型</strong> 可以是整数、浮点数、字符、或字符串；</li><li>排序算法可以根据需要设定 <strong>判断规则</strong>，例如数字大小、字符 ASCII 码顺序、自定义规则；</li></ul><blockquote><p>排序中的不同元素类型和判断规则</p></blockquote><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p1.png" alt="p1"></p><h2 id="评价维度"><a href="#评价维度" class="headerlink" title="评价维度"></a>评价维度</h2><p>排序算法主要可根据 <strong>稳定性 、就地性 、自适应性 、比较类</strong> 来分类。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><ul><li>「稳定排序」在完成排序后，<strong>不改变</strong> 相等元素在数组中的相对顺序。</li><li>「非稳定排序」在完成排序后，相等元素在数组中的相对位置 <strong>可能被改变</strong>。</li></ul><p>假设我们有一个存储学生信息的表格，第 1, 2 列分别是姓名和年龄。那么在以下示例中，「非稳定排序」会导致输入数据的有序性丢失。因此「稳定排序」是很好的特性，<strong>在多级排序中是必须的</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 输入数据是按照姓名排序好的</span><br><span class="line"># (name, age)</span><br><span class="line">  (&#x27;A&#x27;, 19)</span><br><span class="line">  (&#x27;B&#x27;, 18)</span><br><span class="line">  (&#x27;C&#x27;, 21)</span><br><span class="line">  (&#x27;D&#x27;, 19)</span><br><span class="line">  (&#x27;E&#x27;, 23)</span><br><span class="line"></span><br><span class="line"># 假设使用非稳定排序算法按年龄排序列表，</span><br><span class="line"># 结果中 (&#x27;D&#x27;, 19) 和 (&#x27;A&#x27;, 19) 的相对位置改变，</span><br><span class="line"># 输入数据按姓名排序的性质丢失</span><br><span class="line">  (&#x27;B&#x27;, 18)</span><br><span class="line">  (&#x27;D&#x27;, 19)</span><br><span class="line">  (&#x27;A&#x27;, 19)</span><br><span class="line">  (&#x27;C&#x27;, 21)</span><br><span class="line">  (&#x27;E&#x27;, 23)</span><br></pre></td></tr></table></figure><h3 id="就地性"><a href="#就地性" class="headerlink" title="就地性"></a>就地性</h3><ul><li>「原地排序」无需辅助数据，不使用额外空间；</li><li>「非原地排序」需要借助辅助数据，使用额外空间；</li></ul><p>「原地排序」不使用额外空间，可以节约内存；并且一般情况下，由于数据操作减少，原地排序的运行效率也更高。</p><h3 id="自适应性"><a href="#自适应性" class="headerlink" title="自适应性"></a>自适应性</h3><ul><li>「自适应排序」的时间复杂度受输入数据影响，即最佳 &#x2F; 最差 &#x2F; 平均时间复杂度不相等。</li><li>「非自适应排序」的时间复杂度恒定，与输入数据无关。</li></ul><p>我们希望 <strong>最差 &#x3D; 平均</strong>，即不希望排序算法的运行效率在某些输入数据下发生劣化。</p><h3 id="比较类"><a href="#比较类" class="headerlink" title="比较类"></a>比较类</h3><ul><li>「比较类排序」基于元素之间的比较算子（小于、相等、大于）来决定元素的相对顺序。</li><li>「非比较类排序」不基于元素之间的比较算子来决定元素的相对顺序。</li></ul><p>「比较类排序」的时间复杂度最优为 (O(n \log n)) ；而「非比较类排序」可以达到 (O(n)) 的时间复杂度，但通用性较差。</p><h2 id="理想排序算法"><a href="#理想排序算法" class="headerlink" title="理想排序算法"></a>理想排序算法</h2><ul><li><strong>运行快</strong>，即时间复杂度低；</li><li><strong>稳定排序</strong>，即排序后相等元素的相对位置不变化；</li><li><strong>原地排序</strong>，即运行中不使用额外的辅助空间；</li><li><strong>正向自适应性</strong>，即算法的运行效率不会在某些输入数据下发生劣化；</li></ul><p>然而，<strong>没有排序算法同时具备以上所有特性</strong>。排序算法的选型使用取决于具体的列表类型、列表长度、元素分布等因素。</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>「冒泡排序 Bubble Sort」是一种最基础的排序算法，非常适合作为第一个学习的排序算法。顾名思义，「冒泡」是该算法的核心操作。</p><blockquote><p>为什么叫”冒泡”</p></blockquote><p>在水中，越大的泡泡浮力越大，所以最大的泡泡会最先浮到水面。</p><p>「冒泡」操作则是在模拟上述过程，具体做法为：从数组最左端开始向右遍历，依次对比相邻元素大小，若 <strong>左元素 &gt; 右元素</strong> 则将它俩交换，最终可将最大元素移动至数组最右端。</p><p>完成此次冒泡操作后，<strong>数组最大元素已在正确位置，接下来只需排序剩余 (n - 1) 个元素</strong>。</p><blockquote><p>冒泡操作</p></blockquote><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p2.png" alt="p2"></p><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p3.png" alt="p3"></p><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p4.png" alt="p4"></p><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p5.png" alt="p5"></p><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p6.png" alt="p6"></p><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p7.png" alt="p7"></p><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p8.png" alt="p8"></p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ol><li>设数组长度为 (n) ，完成第一轮「冒泡」后，数组最大元素已在正确位置，接下来只需排序剩余 (n - 1) 个元素。</li><li>同理，对剩余 (n - 1) 个元素执行「冒泡」，可将第二大元素交换至正确位置，因而待排序元素只剩 (n - 2) 个。</li><li>以此类推…… <strong>循环 (n - 1) 轮「冒泡」，即可完成整个数组的排序</strong>。</li></ol><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p9.png" alt="p9"></p><blockquote><p>C++实现</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外循环：待排序元素数量为 n-1, n-2, ..., 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 内循环：冒泡操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                <span class="comment">// 这里使用了 std::swap() 函数</span></span><br><span class="line">                <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>python 实现</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 冒泡排序 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 外循环：待排序元素数量为 n-1, n-2, ..., 1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 内循环：冒泡操作</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br></pre></td></tr></table></figure><h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><p><strong>时间复杂度 (O(n^2))</strong> ：各轮「冒泡」遍历的数组长度为 (n - 1) , (n - 2) , (\cdots) , (2) , (1) 次，求和为 (\frac{(n - 1) n}{2}) ，因此使用 (O(n^2)) 时间。</p><p><strong>空间复杂度 (O(1))</strong> ：指针 (i) , (j) 使用常数大小的额外空间。</p><p><strong>原地排序</strong>：指针变量仅使用常数大小额外空间。</p><p><strong>稳定排序</strong>：不交换相等元素。</p><p><strong>自适应排序</strong>：引入 <code>flag</code> 优化后（见下文），最佳时间复杂度为 (O(N)) 。</p><h2 id="效率优化"><a href="#效率优化" class="headerlink" title="效率优化"></a>效率优化</h2><p>我们发现，若在某轮「冒泡」中未执行任何交换操作，则说明数组已经完成排序，可直接返回结果。考虑可以增加一个标志位 <code>flag</code> 来监听该情况，若出现则直接返回。</p><p>优化后，冒泡排序的最差和平均时间复杂度仍为 (O(n^2)) ；而在输入数组 <strong>已排序</strong> 时，达到 <strong>最佳时间复杂度</strong> (O(n)) 。</p><blockquote><p>C++</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序（标志优化）*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSortWithFlag</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外循环：待排序元素数量为 n-1, n-2, ..., 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">// 初始化标志位</span></span><br><span class="line">        <span class="comment">// 内循环：冒泡操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                <span class="comment">// 这里使用了 std::swap() 函数</span></span><br><span class="line">                <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">                flag = <span class="literal">true</span>;  <span class="comment">// 记录交换元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;     <span class="comment">// 此轮冒泡未交换任何元素，直接跳出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Python</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 冒泡排序（标志优化） &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort_with_flag</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 外循环：待排序元素数量为 n-1, n-2, ..., 1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        flag = <span class="literal">False</span>  <span class="comment"># 初始化标志位</span></span><br><span class="line">        <span class="comment"># 内循环：冒泡操作</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br><span class="line">                flag = <span class="literal">True</span>  <span class="comment"># 记录交换元素</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="keyword">break</span>            <span class="comment"># 此轮冒泡未交换任何元素，直接跳出</span></span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>「插入排序 Insertion Sort」是一种基于 <strong>数组插入操作</strong> 的排序算法。</p><p>「插入操作」原理：选定某个待排序元素为基准数 <code>base</code>，将 <code>base</code> 与其左侧已排序区间元素依次对比大小，并插入到正确位置。</p><p>回忆数组插入操作，我们需要将从目标索引到 <code>base</code> 之间的所有元素向右移动一位，然后再将 <code>base</code> 赋值给目标索引。</p><blockquote><p>插入操作:</p></blockquote><p><img src="https://picbed.wuzhentao.com/img/InsertionSort/p1.png" alt="p1"></p><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><ol><li>第 1 轮先选取数组的 <strong>第 2 个元素</strong> 为 <code>base</code> ，执行「插入操作」后，<strong>数组前 2 个元素已完成排序</strong>。</li><li>第 2 轮选取 <strong>第 3 个元素</strong> 为 <code>base</code> ，执行「插入操作」后，<strong>数组前 3 个元素已完成排序</strong>。</li><li>以此类推……最后一轮选取 <strong>数组尾元素</strong> 为 <code>base</code> ，执行「插入操作」后，<strong>所有元素已完成排序</strong>。</li></ol><blockquote><p>插入排序流程</p></blockquote><p><img src="https://picbed.wuzhentao.com/img/InsertionSort/p2.png"></p><blockquote><p>C++</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外循环：base = nums[1], nums[2], ..., nums[n-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> base = nums[i], j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 内循环：将 base 插入到左边的正确位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; base) &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];  <span class="comment">// 1. 将 nums[j] 向右移动一位</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + <span class="number">1</span>] = base;         <span class="comment">// 2. 将 base 赋值到正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法特性-1"><a href="#算法特性-1" class="headerlink" title="算法特性"></a>算法特性</h3><p><strong>时间复杂度 (O(n^2))</strong> ：最差情况下，各轮插入操作循环 (n - 1) , (n-2) , (\cdots) , (2) , (1) 次，求和为 (\frac{(n - 1) n}{2}) ，使用 (O(n^2)) 时间。</p><p><strong>空间复杂度 (O(1))</strong> ：指针 (i) , (j) 使用常数大小的额外空间。</p><p><strong>原地排序</strong>：指针变量仅使用常数大小额外空间。</p><p><strong>稳定排序</strong>：不交换相等元素。</p><p><strong>自适应排序</strong>：最佳情况下，时间复杂度为 (O(n)) 。</p><h3 id="插入排序-vs-冒泡排序"><a href="#插入排序-vs-冒泡排序" class="headerlink" title="插入排序 vs 冒泡排序"></a>插入排序 vs 冒泡排序</h3><blockquote><p>虽然「插入排序」和「冒泡排序」的时间复杂度皆为 (O(n^2)) ，但实际运行速度却有很大差别，这是为什么呢？</p></blockquote><p>回顾复杂度分析，两个方法的循环次数都是 (\frac{(n - 1) n}{2}) 。但不同的是，「冒泡操作」是在做 <strong>元素交换</strong>，需要借助一个临时变量实现，共 3 个单元操作；而「插入操作」是在做 <strong>赋值</strong>，只需 1 个单元操作；因此，可以粗略估计出冒泡排序的计算开销约为插入排序的 3 倍。</p><p>插入排序运行速度快，并且具有原地、稳定、自适应的优点，因此很受欢迎。实际上，包括 Java 在内的许多编程语言的排序库函数的实现都用到了插入排序。库函数的大致思路：</p><ul><li>对于 <strong>长数组</strong>，采用基于分治的排序算法，例如「快速排序」，时间复杂度为 (O(n \log n)) ；</li><li>对于 <strong>短数组</strong>，直接使用「插入排序」，时间复杂度为 (O(n^2)) ；</li></ul><p>在数组较短时，复杂度中的常数项（即每轮中的单元操作数量）占主导作用，此时插入排序运行地更快。这个现象与「线性查找」和「二分查找」的情况类似。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>web笔记</title>
      <link href="/post/9e43dbe9.html"/>
      <url>/post/9e43dbe9.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>学工程课涉及到的知识点比较多，方法上可以不求甚解</p><h1 id="安装配置-VSCode"><a href="#安装配置-VSCode" class="headerlink" title="安装配置 VSCode"></a>安装配置 VSCode</h1><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p><code>Live ServerAuto</code>， <code>Rename Tag</code></p><h3 id="设置自动格式化"><a href="#设置自动格式化" class="headerlink" title="设置自动格式化"></a>设置自动格式化</h3><p>点击<code>settings</code>，然后输入<code>format</code>，然后勾选上<code>Format On Save</code>。</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>网页首页文件一般叫：index.html</p><h3 id="用开发工具探索文档"><a href="#用开发工具探索文档" class="headerlink" title="用开发工具探索文档"></a>用开发工具探索文档</h3><p>DOM(文档对象模型)</p><p>浏览器读取了服务器返回的文档,它会创建一个文档对象模型</p><p>可以用开发者工具调整得到他们想要的样式,得到准确的值,再写入代码</p><h3 id="网站验证"><a href="#网站验证" class="headerlink" title="网站验证"></a>网站验证</h3><p>validator.w3.org 验证 html 是否规范</p><p>jigsaw.w3.org css validator 验证 css 是否规范</p><h3 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h3><p>html 的所有标签为树形结构,例如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web应用课<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>第一讲<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 vscode 中<code> ! + 回车</code>可以自动补全 html 结构</p><p><code>&lt;html&gt;标签</code></p><p>HTML<code>&lt;html&gt;</code>元素 表示一个 HTML 文档的根（顶级元素），所以它也被称为根元素。所有其他元素必须是此元素的后代。</p><p><code>&lt;head&gt;标签</code></p><p>HTML head 元素 规定文档相关的配置信息（元数据），包括文档的标题，引用的文档样式和脚本等。</p><p><code>&lt;body&gt;标签</code><br>HTML body 元素表示文档的内容。document.body 属性提供了可以轻松访问文档的 body 元素的脚本。</p><p><code>&lt;title&gt;标签</code><br>HTML<code> &lt;title&gt;</code> 元素 定义文档的标题，显示在浏览器的标题栏或标签页上。它只应该包含文本，若是包含有标签，则它包含的任何标签都将被忽略。</p><p><code>&lt;meta&gt;</code><br>HTML <code>&lt;meta&gt; </code>元素表示那些不能由其它 HTML 元相关（meta-related）元素（(<code>&lt;base&gt;</code>、<code>&lt;link&gt;</code>,<code> &lt;script&gt;</code>、<code>&lt;style&gt;</code> 或 <code>&lt;title&gt;</code>）之一表示的任何元数据信息。</p><p>常见属性：</p><ul><li><code>charset</code>：这个属性声明了文档的字符编码。如果使用了这个属性，其值必须是与 ASCII 大小写无关（ASCII case-insensitive）的”utf-8”。</li><li><code>name</code>：name 和 content 属性可以一起使用，以名 - 值对的方式给文档提供元数据，其中 name 作为元数据的名称，content 作为元数据的值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;description&quot; content=&quot;算法,计算机,刷题&quot;&gt;</span><br></pre></td></tr></table></figure><p>搜索网站时,会在网站链接下显示 content 里的内容</p><p><code>icon</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;images/icon.png&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>网站 logo</p><p><code>&lt;!-- 多行注释 --&gt;</code></p><p>html 中只有多行注释</p><p><code>ctrl + /</code>将那一行注释,再次点击取消</p><p>示例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--   </span></span><br><span class="line"><span class="comment">        这里的内容均为注释</span></span><br><span class="line"><span class="comment">        &lt;h1&gt;第一讲&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">        &lt;p&gt;</span></span><br><span class="line"><span class="comment">            段落。</span></span><br><span class="line"><span class="comment">        &lt;/p&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h3><p>文本标签虽然很多，但大部分可看成是预定好样式的<code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>。</p><p><code>&lt;div&gt;标签</code></p><p><code>&lt;div&gt;</code>元素 (或 HTML 文档分区元素) 是一个通用型的流内容容器，在不使用 CSS 的情况下，其对内容或布局没有任何影响。<br>其他块级标签例如：<code>&lt;h1&gt;</code>,<code> &lt;p&gt;</code>, <code>&lt;pre&gt;</code>, <code>&lt;ul&gt;</code>,<code> &lt;ol&gt;</code>, <code>&lt;table&gt;</code>。</p><p><code>&lt;span&gt;</code>标签<br><code>&lt;span&gt;</code>元素是短语内容的通用行内容器，并没有任何特殊语义。可以使用它来编组元素以达到某种样式意图（通过使用类或者 Id 属性），或者这些元素有着共同的属性，比如 lang。应该在没有其他合适的语义元素时才使用它。<code>&lt;span&gt; </code>与<code>&lt;div&gt;</code>元素很相似，但 <code>&lt;div&gt;</code> 是一个 块元素 而<code> &lt;span&gt;</code> 则是 行内元素<br>其他内联标签例如：<code>&lt;i&gt;</code>, <code>&lt;b&gt;</code>, <code>&lt;del&gt;</code>, <code>&lt;ins&gt;</code>, <code>&lt;td&gt;</code>, <code>&lt;a&gt;</code>。</p><p><code>&lt;h1&gt; - &lt;h6&gt;</code>标签<br>HTML<code>&lt;h1&gt;–&lt;h6&gt;</code>标题 (Heading) 元素呈现了六个不同的级别的标题，<code>&lt;h1&gt; </code>级别最高，而<code>&lt;h6&gt;</code>级别最低。</p><p><code>&lt;p&gt;</code>标签<br>HTML<code> &lt;p&gt;</code>元素（或者说 HTML 段落元素）表示文本的一个段落。该元素通常表现为一整块与相邻文本分离的文本，或以垂直的空白隔离或以首行缩进。另外，<code>&lt;p&gt;</code> 是块级元素。</p><blockquote><p>样式大部分是靠 CSS 实现,用标签实现的少</p></blockquote><p><code>em</code>标签</p><p>强调文本,默认是斜体</p><p><code>strong</code>标签</p><p>强调文本,默认是粗体</p><p><code>&lt;pre&gt;</code>标签<br>HTML <code>&lt;pre&gt; </code>元素表示预定义格式文本。在该元素中的文本通常按照原文件中的编排，以等宽字体的形式展现出来，文本中的空白符（比如空格和换行符）都会显示出来。(紧跟在 <code>&lt;pre&gt;</code> 开始标签后的换行符也会被省略)</p><p><code>&lt;br&gt;</code>标签<br>HTML <code>&lt;br&gt;</code> 元素在文本中生成一个换行（回车）符号。此元素在写诗和地址时很有用，这些地方的换行都非常重要。</p><p><code>&lt;hr&gt;</code>标签<br>HTML<code> &lt;hr&gt;</code> 元素表示段落级元素之间的主题转换（例如，一个故事中的场景的改变，或一个章节的主题的改变）。</p><p>在 HTML 的早期版本中，它是一个水平线。现在它仍能在可视化浏览器中表现为水平线，但目前被定义为语义上的，而不是表现层面上。所以如果想画一条横线，请使用适当的 css 样式来修饰。</p><p><code>&lt;i&gt;</code>标签<br>HTML 元素 <code>&lt;i&gt; </code>用于表现因某些原因需要区分普通文本的一系列文本。例如技术术语、外文短语或是小说中人物的思想活动等，它的内容通常以斜体显示。</p><p><code>&lt;b&gt;</code>标签<br>HTML 提醒注意（Bring Attention To）元素（<code>&lt;b&gt;</code>）用于吸引读者的注意到该元素的内容上（如果没有另加特别强调）。这个元素过去被认为是粗体（Boldface）元素，并且大多数浏览器仍然将文字显示为粗体。尽管如此，你不应将<code> &lt;b&gt;</code> 元素用于显示粗体文字；替代方案是使用 CSS font-weight 属性来创建粗体文字。</p><p><code>&lt;del&gt;</code>标签<br>HTML 的<code>&lt;del&gt;</code>标签表示一些被从文档中删除的文字内容。比如可以在需要显示修改记录或者源代码差异的情况使用这个标签。<code>&lt;ins&gt;</code>标签的作用恰恰于此相反：表示文档中添加的内容。</p><p><code>&lt;ins&gt;</code>标签<br>HTML <code>&lt;ins&gt; </code>元素定义已经被插入文档中的文本。</p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>HTML <code>&lt;img&gt;</code> 元素将一份图像嵌入文档。<br>默认为行内元素，即 display: inline。</p><p><code>src</code>属性<br>该属性是必须的，它包含了你想嵌入的图片的文件路径。</p><p><code>alt</code>属性<br>该属性包含一条对图像的文本描述，这不是强制性的，但对可访问性而言，它难以置信地有用——屏幕阅读器会将这些描述读给需要使用阅读器的使用者听，让他们知道图像的含义。如果由于某种原因无法加载图像，普通浏览器也会在页面上显示 alt 属性中的备用文本：例如，网络错误、内容被屏蔽或链接过期时。</p><p><code>height</code>属性<br>图像的高度，在 HTML5 中的单位是 CSS 像素，在 HTML 4 中既可以是像素，也可以是百分比。可以只指定 width 和 height 中的一个值，浏览器会根据原始图像进行缩放。</p><p><code>width</code>属性<br>图像的宽度，在 HTML5 中单位是 CSS 像素， 在 HTML 4 中可以是像素也可以是百分比。</p><h3 id="音频与视频"><a href="#音频与视频" class="headerlink" title="音频与视频"></a>音频与视频</h3><p><code>&lt;audio&gt;</code>标签<br>HTML<code>&lt;audio&gt; </code>元素用于在文档中嵌入音频内容。<code>&lt;audio&gt;</code>元素可以包含一个或多个音频资源， 这些音频资源可以使用 src 属性或者<code>&lt;source&gt; </code>元素来进行描述：浏览器将会选择最合适的一个来使用。也可以使用 MediaStream 将这个元素用于流式媒体。</p><ul><li>使用 src 属性播放</li></ul><p>示例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span> <span class="attr">src</span>=<span class="string">&quot;/audios/bgm.mp3&quot;</span>&gt;</span></span><br><span class="line">  Your browser does not support the</span><br><span class="line">  <span class="tag">&lt;<span class="name">code</span>&gt;</span>audio<span class="tag">&lt;/<span class="name">code</span>&gt;</span> element.</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;audio&gt;</code> 与多个 <code>&lt;source&gt; </code>元素</li></ul><p>这个例子包含了多个 <code>&lt;source&gt; </code>元素。如果能够播放的话，浏览器就会试图去加载第一个 source 元素；如果不行，那就退而求其次去加载第二个。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;/audios/sound1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;/audios/sound2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;video&gt;</code>标签<br>HTML <code>&lt;video&gt; </code>元素 用于在 HTML 或者 XHTML 文档中嵌入媒体播放器，用于支持文档内的视频播放。你也可以将 <code>&lt;video&gt; </code>标签用于音频内容，但是 <code>&lt;audio&gt;</code> 元素可能在用户体验上更合适。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span> <span class="attr">src</span>=<span class="string">&quot;./static/videos/program.mp4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>controls:控制开关</p><p>autoplay:自动播放</p><p>loop:循环播放</p><blockquote><p>并不是所有浏览器都支持视频播放</p></blockquote><p>给不支持视屏播放的浏览器提供一个替换文本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span> <span class="attr">src</span>=<span class="string">&quot;./static/videos/program.mp4&quot;</span>&gt;</span></span><br><span class="line">  your browser doesn&#x27;t support videos.</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>HTML <code>&lt;a&gt;</code> 元素（或称锚元素）可以通过它的 href 属性创建通向其他网页、文件、同一页面内的位置、电子邮件地址或任何其他 URL 的超链接。<code>&lt;a&gt; </code>中的内容应该指明链接的意图。如果存在 href 属性，当 <code>&lt;a&gt;</code> 元素聚焦时按下回车键就会激活它。</p><p>里面可以写其他标签,例如:img,点击图片也能跳转</p><p>常用选项</p><ul><li>点击链接打开新标签页面时加入属性：target&#x3D;”_blank”</li><li>加入属性 mailto: 邮箱, 点击链接会自动向指定邮箱发送邮件</li></ul><blockquote><p>链接和超链接的区别</p></blockquote><p>链接只是一个地址,一个 URL,定位到目标页面</p><p>超链接,是页面中完成跳转的元素</p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p><code>&lt;form&gt;</code>标签<br>HTML<code>&lt;form&gt;</code>元素表示文档中的一个区域，此区域包含交互控件，用于向 Web 服务器提交信息。</p><p><code>&lt;form action=&quot;&quot;&gt;</code>点击提交后,表单的 action 属性是在服务器上提交表单，这个属性可以被检索或者设置</p><p>如果里面填的是链接,点击提交后会跳转到链接</p><p><code>&lt;input&gt;</code>标签<br>HTML <code>&lt;input&gt;</code>用来填写内容，常见类型有：</p><ul><li><p><code>&lt;input type=&quot;text&quot;&gt;</code>：创建基础的单行文本框。</p></li><li><p><code>&lt;input type=&quot;number&quot;&gt;</code>：用于让用户输入一个数字。其包括内置验证以拒绝非数字输入。浏览器可能会选择提供步进箭头，让用户可以使用鼠标增加和减少输入的值，或者只需用指尖敲击即可。</p></li><li><p><code>&lt;input type=&quot;email&quot;&gt;</code>：带有 “email” (电子邮箱) 类型标记的输入框元素 (<code>&lt;input&gt;</code>) 能够让用户输入或编辑一个电子邮箱地址，此外，如果指定了 multiple 属性，用户还可以输入多个电子邮箱地址。在表单提交前，输入框会自动验证输入值是否是一个或多个合法的电子邮箱地址 (非空值且符合电子邮箱地址格式). CSS 伪标签 :valid 和 :invalid 能够在校验后自动应用。</p></li><li><p><code>&lt;input type=&quot;password&quot;&gt;</code>：<code>&lt;input&gt; </code>元素 里有一种叫做 “password” 的值，给我们一个方法让用户更加安全的输入密码。这个元素是作为一行纯文本编辑器控件呈现的，其中文本被遮蔽以致于无法读取，通常通过用诸如星号（“*”）或点（“•”）等符号替换每个字符来实现。这个符号会根据用户的浏览器和操作系统来具体显示哪个。</p></li><li><p><code>&lt;input type=&quot;radio&quot;&gt;</code>：<code>&lt;input&gt; </code>的 radio 类型元素默认渲染为小型圆圈图表，填充即为激活，类似于之前描述额复选框（checkbox）类型。单选按钮允许你选择单一的值来提交表单。如果,三个选项的<code>name</code>都一样那么三个里面只能选一个,如果不同则可以多选</p></li><li><p><code>&lt;input type=&quot;file&quot;&gt;</code>:选择文件</p></li></ul><p><code>&lt;labbel&gt;</code>标签一般与 input 捆绑在一块</p><p>for 里面的内容对应 id</p><p>常用属性有：</p><ul><li><code>name</code>: 名称</li><li><code>id</code>: 唯一 ID</li><li><code>maxlength</code>：最大长度</li><li><code>minlength</code>：最小长度</li><li><code>required</code>：是否必填</li><li><code>placeholder</code>：当表单控件为空时，控件中显示的内容(&#x3D;&#x3D;很有用&#x3D;&#x3D;)</li></ul><p><code>&lt;textarea&gt;</code>标签<br>HTML <code>&lt;textarea&gt;</code> 元素表示一个多行纯文本编辑控件，当你希望用户输入一段相当长的、不限格式的文本，例如评论或反馈表单中的一段意见时，这很有用。</p><p>属性:</p><ul><li>row:初始行数</li><li>col:初始列数</li></ul><p><code>&lt;select&gt;</code>与<code>&lt;option&gt;</code>标签<br>HTML<code> &lt;select&gt;</code> 元素表示一个提供选项菜单的控件。<br>示例:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">label</span> for=&quot;pet-select&quot;&gt;Choose <span class="selector-tag">a</span> pet:&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">&lt;select name=<span class="string">&quot;pets&quot;</span> id=<span class="string">&quot;pet-select&quot;</span>&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;&quot;</span>&gt;--Please choose an option--&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;dog&quot;</span>&gt;Dog&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;cat&quot;</span>&gt;Cat&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;hamster&quot;</span>&gt;Hamster&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;parrot&quot;</span>&gt;Parrot&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;spider&quot;</span>&gt;Spider&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;goldfish&quot;</span>&gt;Goldfish&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;button&gt;</code>标签<br>HTML <code>&lt;button&gt;</code> 元素表示一个可点击的按钮，可以用在表单或文档其它需要使用简单标准按钮的地方。 默认情况下，HTML 按钮的显示样式接近于 user agent 所在的宿主系统平台（用户操作系统）的按钮， 但你可以使用 CSS 来改变按钮的样貌。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><code>&lt;ul&gt;</code>与<code>&lt;li&gt;</code>标签</p><p>HTML <code>&lt;ul&gt; </code>元素（或称 HTML 无序列表元素）表示一个内可含多个元素的无序列表或项目符号列表。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first item&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second item&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;third item&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>常应用于表示导航栏按钮,</p><p>无序列表可以表现任何顺序无关的对象</p><p>可以列出图片,产品或者购物车</p></blockquote><p><code>&lt;ol&gt;</code>与<code>&lt;li&gt;</code>标签<br>HTML<code> &lt;ol&gt;</code>元素表示有序列表，通常渲染为一个带编号的列表。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">  &lt;li&gt;Fee&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Fi&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Fo&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Fum&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;dl&gt;</code>、<code>&lt;dt&gt;</code>与<code>&lt;dd&gt;</code>标签</p><p>HTML <code>&lt;dl&gt; </code>元素 （或 HTML 描述列表元素）是一个包含术语定义以及描述的列表，通常用于展示词汇表或者元数据 (键 - 值对列表)。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">    &lt;dt&gt;Name&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;Godzilla&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;Born&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;1952&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;Birthplace&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;Japan&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;Color&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;Green&lt;/dd&gt;</span><br><span class="line">    &lt;dd&gt;Orange&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><code>&lt;table&gt;</code>标签<br>HTML 的 table 元素表示表格数据 — 即通过二维数据表表示的信息。</p><p><code>&lt;thead&gt;</code>标签<br>HTML 的<code>&lt;thead&gt;</code>元素定义了一组定义表格的列头的行。</p><p><code>&lt;tbody&gt;</code>标签<br>HTML 的<code>&lt;tbody&gt;</code>元素定义一组数据行。</p><p><code>&lt;tr&gt;</code>标签<br>HTML<code>&lt;tr&gt;</code>元素定义表格中的行。 同一行可同时出现<code>&lt;td&gt; </code>和<code>&lt;th&gt;</code> 元素。</p><p><code>&lt;th&gt;</code>标签<br>HTML<code> &lt;th&gt;</code>元素定义表格内的表头单元格。</p><p><code>&lt;td&gt;</code>标签<br>HTML<code>&lt;td&gt; </code>元素 定义了一个包含数据的表格单元格。</p><p><code>&lt;caption&gt;</code>标签<br>HTML<code> &lt;caption&gt;</code>元素 (or HTML 表格标题元素) 展示一个表格的标题， 它常常作为 <code>&lt;table&gt; </code>的第一个子元素出现，同时显示在表格内容的最前面，但是，它同样可以被 CSS 样式化，所以，它同样可以出现在相对于表格的任意位置。</p><p>示例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">caption</span>&gt;</span></span><br><span class="line">    My Table</span><br><span class="line">  <span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>The table header<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>The table body<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>with two columns<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="语义标签"><a href="#语义标签" class="headerlink" title="语义标签"></a>语义标签</h3><p><code>&lt;header&gt;</code><br>HTML <code>&lt;header&gt; </code>元素用于展示介绍性内容，通常包含一组介绍性的或是辅助导航的实用元素。它可能包含一些标题元素，但也可能包含其他元素，比如 Logo、搜索框、作者名称，等等。</p><p><code>&lt;nav&gt;</code><br>HTML <code>&lt;nav&gt;</code>元素表示页面的一部分，其目的是在当前文档或其他文档中提供导航链接。导航部分的常见示例是菜单，目录和索引。</p><p><code>&lt;section&gt;</code><br>HTML <code>&lt;section&gt;</code>元素表示一个包含在 HTML 文档中的独立部分，它没有更具体的语义元素来表示，一般来说会有包含一个标题。</p><p><code>main</code>表示网页的主体,每个页面只有一个 main 标签</p><p><code>&lt;figure&gt;</code><br>HTML <code>&lt;figure&gt; </code>元素代表一段独立的内容，经常与说明（caption）<code>&lt;figcaption&gt; </code>配合使用，并且作为一个独立的引用单元。当它属于主内容流（main flow）时，它的位置独立于主体。这个标签经常是在主文中引用的图片，插图，表格，代码段等等，当这部分转移到附录中或者其他页面时不会影响到主体。</p><p><code>&lt;figcaption&gt;</code><br>HTML <code>&lt;figcaption&gt; </code>元素 是与其相关联的图片的说明&#x2F;标题，用于描述其父节点<code> &lt;figure&gt;</code>元素里的其他数据。这意味着 <code>&lt;figcaption&gt; </code>在<code>&lt;figure&gt; </code>块里是第一个或最后一个。同时 HTML Figcaption 元素是可选的；如果没有该元素，这个父节点的图片只是会没有说明&#x2F;标题。</p><p><code>&lt;article&gt;</code><br>HTML <code>&lt;article&gt;</code>元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。</p><p><code>&lt;aside&gt;</code><br>HTML<code> &lt;aside&gt;</code> 元素表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者标注框（call-out boxes）。</p><p><code>&lt;footer&gt;</code><br>HTML <code>&lt;footer&gt; </code>元素表示最近一个章节内容或者根节点（sectioning root ）元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。</p><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><table><thead><tr><th>HTML 源代码</th><th>显示结果</th><th>描述</th></tr></thead><tbody><tr><td><code>&amp;lt;</code></td><td>&lt;</td><td>小于号或显示标记</td></tr><tr><td><code>&amp;gt;</code></td><td>&gt;</td><td>大于号或显示标记</td></tr><tr><td><code>&amp;reg;</code></td><td>®</td><td>已注册</td></tr><tr><td><code>&amp;copy;</code></td><td>©</td><td>版权</td></tr><tr><td><code>&amp;trade;</code></td><td>™</td><td>商标</td></tr><tr><td><code>&amp;nbsp;</code></td><td></td><td>不断行的空白</td></tr><tr><td><code>&amp;quot;</code></td><td>“</td><td>引号</td></tr><tr><td><code>&amp;amp;</code></td><td>&amp;</td><td>可用于显示其它特殊字符</td></tr></tbody></table><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h3 id="不同的浏览器对-CSS-的渲染不同"><a href="#不同的浏览器对-CSS-的渲染不同" class="headerlink" title="不同的浏览器对 CSS 的渲染不同"></a>不同的浏览器对 CSS 的渲染不同</h3><p>为了避免这个问题,我们需要用到一个工具</p><p>normalize.css</p><p>下载,并且把文件放到项目 CSS 文件夹下</p><p>nomalize.css 只是把不同浏览器的设置统一了</p><blockquote><p>使用方法</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;normalize<span class="selector-class">.css</span>&quot;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>CSS 一致化是前端开发中非常重要的一点</p></blockquote><h3 id="对象适应"><a href="#对象适应" class="headerlink" title="对象适应"></a>对象适应</h3><p>可以将对象适应设为某个值,大部分时间我们使用覆盖</p><p>这样图片就会覆盖它的容器盒子,</p><p>我们的图片尺寸会重新设置,以实现覆盖整个盒子的目的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">object-fit</span>: cover;</span><br></pre></td></tr></table></figure><p>容器盒子:</p><p>概念上任何 HTML 元素都被包裹在一个盒子里,我们看不到盒子,</p><p>但是浏览器能根据盒子来决定如何显示页面</p><blockquote><p>绝对单位:</p><p>px</p><p>pt,打印时才有意义的单位</p><p>相对单位:</p><p>%,百分比就是于容器的大小相关的</p><p>vw 和 vh 是和显示器视域相关的</p><p>em 和 rem 是和字体相关的</p><p>fr 可用空间百分比</p></blockquote><blockquote><p>使用相对单位可以创建响应式的页面</p></blockquote><h3 id="样式定义方式"><a href="#样式定义方式" class="headerlink" title="样式定义方式"></a>样式定义方式</h3><h4 id="行内样式表（inline-style-sheet）"><a href="#行内样式表（inline-style-sheet）" class="headerlink" title="行内样式表（inline style sheet）"></a>行内样式表（inline style sheet）</h4><p>直接定义在标签的&#x3D;&#x3D;style&#x3D;&#x3D;属性中。</p><ul><li>作用范围：仅对当前标签产生影响。</li></ul><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;/images/mountain<span class="selector-class">.jpg</span>&quot; alt=&quot;&quot; style=&quot;<span class="attribute">width</span>: <span class="number">300px</span>; <span class="attribute">height</span>: <span class="number">200px</span>;&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="内部样式表（internal-style-sheet）"><a href="#内部样式表（internal-style-sheet）" class="headerlink" title="内部样式表（internal style sheet）"></a>内部样式表（internal style sheet）</h4><p>定义在 style 标签中，通过选择器影响对应的标签。</p><p>理论在 head 标签下写,其实在 body 写也可以</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        <span class="selector-tag">img</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>也可以自定义</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        <span class="selector-class">.big</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">70px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">70px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">p</span> class=&quot;big&quot;&gt;<span class="number">2</span>&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">p</span> class=&quot;big&quot;&gt;<span class="number">4</span>&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br></pre></td></tr></table></figure><p>批量变化可以选择设置 class</p><ul><li>作用范围：可以对同一个页面中的多个元素产生影响。</li></ul><p>border-radius 属性:设置圆弧状,50%时就是圆形</p><p>内部样式表只能对一个网页生效,如果要批量改一个网站几百个网页,那么工作量会很高,而外部样式表可以解决</p><h4 id="外部样式表（external-style-sheet）"><a href="#外部样式表（external-style-sheet）" class="headerlink" title="外部样式表（external style sheet）"></a>外部样式表（external style sheet）</h4><p>定义在&#x3D;&#x3D;css 样式文件&#x3D;&#x3D;中，通过选择器影响对应的标签。可以用 link 标签引入某些页面。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/CSS/style<span class="selector-class">.css</span>&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>作用范围：可以对多个页面产生影响。</li></ul><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>注意不能使用&#x2F;&#x2F;。<br>只有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* 注释 */</span><br></pre></td></tr></table></figure><p>快捷键:<code>ctrl + /</code></p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><p>选择所有<code>div</code>标签：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a>ID 选择器</h4><p>选择 ID 为<code>rect-1</code>的标签：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#rect-1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ID 选择器与类选择器的区别:</p><p>不能有多个元素拥有同一 ID</p><p>但是多个元素可以共用一个类</p></blockquote><h4 id="类选择器-最常用"><a href="#类选择器-最常用" class="headerlink" title="类选择器(最常用)"></a>类选择器(最常用)</h4><p>选择所有<code>rectangle</code>类的标签：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.rectangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个标签里可以填多个 class,但只能有一个 id</p><h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><p>伪类用于定义元素的特殊状态。</p><p>链接伪类选择器：</p><ul><li><code>:link</code>：链接访问前的样式</li><li><code>:visited</code>：链接访问后的样式</li><li><code>:hover</code>：鼠标悬停时的样式</li><li><code>:active</code>：鼠标点击后长按时的样式</li><li><code>:focus</code>：聚焦后的样式</li></ul><p>位置伪类选择器：</p><ul><li><code>:nth-child(n)</code>：选择是其父标签第 n 个子元素的所有元素。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(odd)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*选中所有奇数的,even选中所有偶数的,3n每跨3个选择</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">140%</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*article标签下第一个*/</span></span><br></pre></td></tr></table></figure><blockquote><p>这种选择虽然常用但是也很脆弱</p></blockquote><p>为我们可以用另一个伪类选择器</p><ul><li><code>first-of-type</code>:会应用到不同类型标签第一次出现的地方</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">140%</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*选择第一个p</span></span><br><span class="line"><span class="comment">如果不加p会选择article下所有第一次出现的标签*/</span></span><br></pre></td></tr></table></figure><p>目标伪类选择器：</p><ul><li><code>:target</code>：当 url 指向该元素时生效。</li></ul><p>用链接跳转到 id 为 1 的地方</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">a</span> href=&quot;<span class="selector-id">#1</span>&quot;&gt;&lt;/<span class="selector-tag">a</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h4><p>由两个及以上基础选择器组合而成的选择器。</p><ul><li><code>element1, element2</code>：同时选择元素 element1 和元素 element2。</li><li><code>element.class</code>：选则包含某类的 element 元素。</li></ul><p>element 可以是标签也可以是 id</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#id</span><span class="selector-class">.class</span> <span class="selector-tag">div</span><span class="selector-class">.class</span>;</span><br></pre></td></tr></table></figure><ul><li><code>element1 + element2</code>：选择紧跟 element1 的 element2 元素</li><li><code>element1 element2</code>：选择 element1 内的所有 element2 元素。</li><li><code>element1 &gt; element2</code>：选择父标签是 element1 的所有 element2 元素。</li><li><code>element1 ~ element2</code>:选中所有和 element1 同级的 element2 标签</li></ul><blockquote><p>缺点</p></blockquote><ul><li>代码很脆弱,稍微一点变动就不管用了</li><li>效率不如基本选择器</li></ul><h4 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h4><ul><li><code>*</code>：选择所有标签</li><li><code>[attribute]</code>：选择具有某个属性的所有标签</li><li><code>[attribute=value]</code>：选择 attribute 值为 value 的所有标签</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-attr">[lang^=<span class="string">&quot;en&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line">*<span class="selector-class">.warning</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">*<span class="selector-id">#maincontent</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h4><p>将特定内容当做一个元素，选择这些元素的选择器被称为伪元素选择器。</p><ul><li><p><code>::first-letter</code>：选择第一个字母</p></li><li><p><code>::first-line</code>：选择第一行</p></li><li><p><code>::selection</code>：选择已被选中的内容</p></li><li><p><code>::after</code>：可以在元素后插入内容</p></li><li><p><code>::before</code>：可以在元素前插入内容</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>::::first-letter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="样式渲染优先级"><a href="#样式渲染优先级" class="headerlink" title="样式渲染优先级"></a>样式渲染优先级</h4><ul><li><p>权重大小，越具体的选择器权重越大：<code>!important </code>&gt; 行内样式 &gt; ID 选择器 &gt; 类与伪类选择器 &gt; 标签选择器 &gt; 通用选择器</p></li><li><p>权重相同时，后面的样式会覆盖前面的样式</p></li><li><p>继承自父元素的权重最低</p></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>一些 CSS 规则可以从它们的父级元素继承下来</p></blockquote><p>例如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor <span class="tag">&lt;<span class="name">strong</span>&gt;</span>dolor<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>&gt;sit amet consectetur<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要重复设置 strong, stong 内的元素 也会继承父元素,变红</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stong&#123;</span><br><span class="line">    <span class="attribute">color</span>: initial;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果不想继承将值设为默认值</span></span><br></pre></td></tr></table></figure><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><h4 id="预定义的颜色值"><a href="#预定义的颜色值" class="headerlink" title="预定义的颜色值"></a>预定义的颜色值</h4><p>black、white、red、green、blue、lightblue 等。</p><h4 id="16-进制表示法"><a href="#16-进制表示法" class="headerlink" title="16 进制表示法"></a>16 进制表示法</h4><p>使用 6 位 16 进制数表示颜色，例如：<code>#ADD8E6</code>。<br>其中第 1-2 位表示红色，第 3-4 位表示绿色，第 5-6 位表示蓝色</p><p>简写方式：<code>#ABC</code>，等价于<code>#AABBCC</code>。</p><h4 id="RGB-表示法"><a href="#RGB-表示法" class="headerlink" title="RGB 表示法"></a>RGB 表示法</h4><p><code>rgb(173, 216, 230)</code>。</p><p>其中第一个数表示红色，第二个数表示绿色，第三个数表示蓝色。</p><h4 id="RGBA-表示法"><a href="#RGBA-表示法" class="headerlink" title="RGBA 表示法"></a>RGBA 表示法</h4><p><code>rgba(173, 216, 230, 0.5)</code>。</p><p>a 是透明度</p><h4 id="取色方式"><a href="#取色方式" class="headerlink" title="取色方式"></a>取色方式</h4><ul><li>网页里的颜色，可以在 chrome 的调试模式下获取</li><li>其他颜色可以使用 QQ 的截图软件：<ul><li>直接按<code>c</code>键，可以复制 rgb 颜色值</li><li>按住<code>shift</code>再按 c 键，可以复制 16 进制颜色值</li></ul></li></ul><h4 id="渐变色"><a href="#渐变色" class="headerlink" title="渐变色"></a>渐变色</h4><ul><li>渐变函数<code>linear-gradient()</code></li><li>径向渐变函数<code>radial-gradient()</code></li></ul><blockquote><p>生成渐变色的网站 cssgradient.io</p></blockquote><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><ul><li><code>box-shadow</code> 阴影到元素的水平距离</li></ul><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p><code>text-align</code><br><code>text-align</code> CSS 属性定义行内内容（例如文字）如何相对它的块父元素对齐。text-align 并不控制块元素自己的对齐，只控制它的行内内容的对齐。</p><p><code>line-height</code><br><code>line-height</code> CSS 属性用于设置多行元素的空间量，如多行文本的间距。对于块级元素，它指定元素行盒（line boxes）的最小高度。对于非替代的 inline 元素，它用于计算行盒（line box）的高度</p><ul><li>补充知识点:长度单位</li></ul><table><thead><tr><th>单位</th><th>描述</th></tr></thead><tbody><tr><td>px</td><td>设备上的像素点</td></tr><tr><td>%</td><td>相对于父元素的百分比</td></tr><tr><td>em</td><td>相对于当前元素的字体大小</td></tr><tr><td>rem</td><td>相对于根元素的字体大小</td></tr><tr><td>vw</td><td>相对于视窗宽度的百分比</td></tr><tr><td>vh</td><td>相对于视窗高度的百分比</td></tr></tbody></table><p><code>letter-spacing</code><br>CSS 的 <code>letter-spacing </code>属性用于设置文本字符的间距。</p><p><code>text-indent</code><br><code>text-indent</code>属性能定义一个块元素首行文本内容之前的缩进量。</p><p><code>text-decoration</code><br><code>text-decoration</code> 这个 CSS 属性是用于设置文本的修饰线外观的（下划线、上划线、贯穿线&#x2F;删除线 或 闪烁）它是 text-decoration-line, text-decoration-color, text-decoration-style, 和新出现的 text-decoration-thickness 属性的缩写。</p><p><code>text-shadow</code><br><code>text-shadow</code>为文字添加阴影。可以为文字与 text-decorations 添加多个阴影，阴影值之间用逗号隔开。每个阴影值由元素在 X 和 Y 方向的偏移量、模糊半径和颜色值组成。</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p><code>font-size</code><br><code>font-size</code> CSS 属性指定字体的大小。因为该属性的值会被用于计算 em 和 ex 长度单位，定义该值可能改变其他元素的大小。</p><blockquote><p>单位一般用 rem,因为能完美响应设备</p></blockquote><p><code>font-style</code><br><code>font-style</code> CSS 属性允许你选择<code> font-family</code> 字体下的 italic 或 oblique 样式。</p><p><code>font-weight</code><br><code>font-weight</code> CSS 属性指定了字体的粗细程度。 一些字体只提供 normal 和 bold 两种值。</p><p><code>font-family</code><br>CSS 属性<code> font-family</code> 允许您通过给定一个有先后顺序的，由字体名或者字体族名组成的列表来为选定的元素设置字体。<br>属性值用逗号隔开。浏览器会选择列表中第一个该计算机上有安装的字体，或者是通过 @font-face 指定的可以直接下载的字体。</p><blockquote><p>字体分类</p></blockquote><ul><li><p>衬线字体</p><ul><li>常被大量用于书籍,报纸和杂志, Georgia 和 Times 新罗马体是最常见的</li></ul></li><li><p>无衬线字体</p><ul><li>更加活泼和时尚,有 Avenir, Arial,Futura, Helvetica,Roboto</li></ul></li><li><p>等宽字体:</p><ul><li>每个字符所占的宽度是一样的</li><li>所以这是显示代码的最佳字体</li></ul></li></ul><blockquote><p>字体颜色不要设置纯黑的,可以设为灰色,对眼睛友好</p></blockquote><blockquote><p>免费字体网站</p></blockquote><p>fontsquirrel.com</p><p>在这个网站下载 TTF 格式并转换为 WOFF 后</p><p>解压会得到一个 style.css 文件,里面是使用规则</p><p>把里面的内容复制粘贴到自己 css 文件顶部</p><blockquote><p>因为要先注册字体才能使用</p><p>之后还需要自己手动修改</p></blockquote><p>字体文件分为很多格式,比如 TTF, OTF, EOT, WOFF,</p><blockquote><p>对于网站来说,最好使用 WOFF 或者 WOFF2</p><p>因为这些字体压缩比更高,在网络传输中效率更高</p></blockquote><blockquote><p>无样式字体闪现问题</p></blockquote><p>当浏览器下载自定义字体时,它会先使用一个替代字体来显示</p><blockquote><p>我们可以使用字体显示属性来告诉浏览器如何处理此类问题</p></blockquote><p>font-display: optional; (用户体验最好的选项)</p><blockquote><p>排版垂直空间</p></blockquote><p>文章与文章之间要有间隙</p><p>行之间也要也间隙</p><p>字体大小为 1rem, 行高一般设置为 1.5rem</p><p>line-height 行高</p><blockquote><p>水平排版</p></blockquote><ul><li><p>letter-spacing 字符间距</p></li><li><p>word-spacing 词间距</p></li><li><p>width 宽度</p></li></ul><p>最佳行款 50-70 个字符</p><p>width: 50ch; 意思是 50 个 0 的宽度</p><blockquote><p>文字排版</p></blockquote><ul><li>text-align 文字对齐</li><li>text-indent 文字缩进</li><li>text-decoration 文字装饰, 就是加下划线</li><li>text-transform 文字转换, 就是字符转为大写或小写</li><li>white-space 空白, 来管理换行</li><li>column-* 可以设置多列文本</li><li>direction 方向, 设置从右向左阅读的文字</li></ul><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><code>background-color</code><br>CSS 属性中的<code>background-color</code>会设置元素的背景色, 属性的值为颜色值或关键字”transparent”二者选其一。</p><p><code>background-image</code><br>CSS <code>background-image</code> 属性用于为一个元素设置一个或者多个背景图像。</p><ul><li>渐变色：<code>linear-gradient(rgba(0, 0, 255, 0.5), rgba(255, 255, 0, 0.5))</code></li></ul><p><code>background-size</code><br><code>background-size</code> 设置背景图片大小。图片可以保有其原有的尺寸，或者拉伸到新的尺寸，或者在保持其原有比例的同时缩放到元素的可用空间的尺寸。</p><p><code>background-repeat</code><br><code>background-repeat</code> CSS 属性定义背景图像的重复方式。背景图像可以沿着水平轴，垂直轴，两个轴重复，或者根本不重复。</p><p><code>background-position</code><br><code>background-position</code> 为背景图片设置初始位置。</p><p><code>background-attachment</code><br><code>background-attachment </code>CSS 属性决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动。</p><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p><code>border-style</code><br><code>border-style</code> 是一个 CSS 简写属性，用来设定元素所有边框的样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-style</span>: solid dotted inset none;</span><br></pre></td></tr></table></figure><p>顺序是上右下左</p><p>可以只写一个或任意</p><p><code>border-width</code><br><code>border-width</code>属性可以设置盒子模型的边框宽度。</p><p><code>border-color</code><br>CSS 属性<code>border-color</code> 是一个用于设置元素四个边框颜色的快捷属性： <code>border-top-color</code>, <code>border-right-color</code>, <code>border-bottom-color</code>, <code>border-left-color</code></p><p><code>border-radius</code><br>CSS 属性<code>border-radius</code>允许你设置元素的外边框圆角。当使用一个半径时确定一个圆形，当使用两个半径时确定一个椭圆。这个(椭)圆与边框的交集形成圆角效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br></pre></td></tr></table></figure><p><code>border-collapse</code><br><code>border-collapse</code> CSS 属性是用来决定表格的边框是分开的还是合并的。在分隔模式下，相邻的单元格都拥有独立的边框。在合并模式下，相邻单元格共享边框。</p><h3 id="元素展示格式"><a href="#元素展示格式" class="headerlink" title="元素展示格式"></a>元素展示格式</h3><p><code>display</code></p><ul><li><code>block</code>：<ul><li>独占一行</li><li>width、height、margin(外边距)、padding(内边距)均可控制</li><li>width 默认 100%。</li></ul></li><li><code>inline</code>：<ul><li>可以共占一行</li><li>width 与 height 无效，水平方向的 margin 与 padding 有效，竖直方向的 margin 与 padding 无效</li><li>width 默认为本身内容宽度</li></ul></li><li><code>inline-block</code><ul><li>可以共占一行</li><li>width、height、margin、padding 均可控制</li><li>width 默认为本身内容宽度</li></ul></li></ul><p><code>white-space</code><br><code>white-space</code> CSS 属性是用来设置如何处理元素中的 空白 (en-US)。</p><p><code>text-overflow</code><br><code>text-overflow</code> CSS 属性确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号或显示一个自定义字符串。</p><blockquote><p>当你的元素是固定大小时,应该注意有可能溢出就会发生</p></blockquote><p>当你的容器元素是固定大小的,但是里面的内容却太多了,内容就不完全适配容器了</p><p><code>overflow</code><br>CSS 属性 <code>overflow</code> 定义当一个元素的内容太大而无法适应 块级格式化上下文 时候该做什么。它是<code>overflow-x</code>和<code>overflow-y</code>的 简写属性 。</p><h3 id="内边距与外边距"><a href="#内边距与外边距" class="headerlink" title="内边距与外边距"></a>内边距与外边距</h3><p><code>margin</code><br><code>margin</code>属性为给定元素设置所有四个（上下左右）方向的外边距属性。</p><ul><li><p>可以接受 1~4 个值（上、右、下、左的顺序）</p></li><li><p>可以分别指明四个方向：margin-top、margin-right、margin-bottom、margin-left</p></li><li><p>可取值</p><ul><li><p><code>length</code>：固定值</p></li><li><p><code>percentage</code>：相对于包含块的宽度，以百分比值为外边距。</p></li><li><p><code>auto</code>：让浏览器自己选择一个合适的外边距。有时，在一些特殊情况下，该值可以使元素居中。</p></li></ul></li><li><p>外边距重叠</p><ul><li>块的上外边距(margin-top)和下外边距(margin-bottom)有时合并(折叠)为单个边距，其大小为单个边距的最大值(或如果它们相等，则仅为其中一个)，这种行为称为边距折叠。</li><li>父元素与后代元素：父元素没有上边框和 padding 时，后代元素的<code>margin-top</code>会溢出，溢出后父元素的 margin-top 会与后代元素取最大值。</li></ul></li></ul><p><code>padding</code><br><code>padding</code> CSS 简写属性控制元素所有四条边的内边距区域。</p><ul><li>可以接受 1~4 个值（上、右、下、左的顺序）</li><li>可以分别指明四个方向：<code>padding-top</code>、<code>padding-right</code>、<code>padding-bottom</code>、<code>padding-left</code></li><li>可取值<ul><li><code>length</code>：固定值</li><li><code>percentage</code>：相对于包含块的宽度，以百分比值为内边距。</li></ul></li></ul><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>当浏览器渲染元素的时候，就会将它装进一个不可见的盒子</p><p>在盒子当中是内容部分，这是内容显示的地方，</p><p>如果段落中有些文字，文字就显示在这里，在内容的外面是内边距区域，是为了给内容一些外部空间，然后还有边框区域，最后是外边距区域，这是元素之间的空间</p><p><code>box-sizing</code><br>CSS 中的 <code>box-sizing</code> 属性定义了 user agent 应该如何计算一个元素的总宽度和总高度。</p><ul><li><code>content-box</code>：是默认值，设置<code>border</code>和<code>padding</code>均会增加元素的宽高。</li><li><code>border-box</code>：设置<code>border</code>和<code>padding</code>不会改变元素的宽高，而是挤占内容区域。</li></ul><blockquote><p>默认情况下,宽和高属性是给内容区域设定的,任何内边距和边框都会增加盒子的实际大小</p><p>外边距对盒子大小没有影响,它只是将盒子从别的元素旁移开</p></blockquote><p>全局设置例子</p><blockquote><p>*{}对有伪元素的不起作用</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">&#125;<span class="comment">/*不起作用</span></span><br><span class="line"><span class="comment">/*需要加上所有元素的为元素的before和after</span></span><br><span class="line"><span class="comment">*, *::before, *::after&#123;&#125; /*现在这个属性应用于所有元素以及所有元素的before和after的为元素</span></span><br></pre></td></tr></table></figure><blockquote><p>宽和高属性支队块级元素有效,块级元素占据一整行,会占满整行所有可用空间,再添加一个盒子会另起一行</p></blockquote><blockquote><p>行内元素是无法设置宽和高的,为了给它设置宽高,我们需要将它的显示模式设置为行内块级元素 display: inline-block;</p></blockquote><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p><code>position</code><br><code>CSS position</code>属性用于指定一个元素在文档中的定位方式。</p><p>定位类型：</p><ul><li>定位元素（positioned element）是其计算后位置属性为 relative, absolute, fixed 或 sticky 的一个元素（换句话说，除 static 以外的任何东西）。</li><li>相对定位元素（relatively positioned element）是计算后位置属性为 relative 的元素。</li><li>绝对定位元素（absolutely positioned element）是计算后位置属性为 absolute 或 fixed 的元素。</li><li>粘性定位元素（stickily positioned element）是计算后位置属性为 sticky 的元素。<br>取值：</li><li><code>static</code>：该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。</li><li><code>relative</code>：该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。top, right, bottom, left 等调整元素相对于初始位置的偏移量。</li><li><code>absolute</code>：元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。</li><li><code>fixed</code>：元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。</li><li><code>sticky</code>：元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block (最近块级祖先 nearest block-level ancestor)，包括 table-related 元素，基于 top, right, bottom, 和 left 的值进行偏移。偏移值不会影响任何其他元素的位置。</li></ul><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p><code>float</code></p><p><code>float</code> CSS 属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动(文档流)中移除，尽管仍然保持部分的流动性（与绝对定位相反）。</p><p>由于 float 意味着使用块布局，它在某些情况下修改 display 值的计算值：</p><ul><li>display 为 inline 或 inline-block 时，使用 float 后会统一变成 block。</li></ul><p>取值：</p><ul><li><p>left：表明元素必须浮动在其所在的块容器左侧的关键字。</p></li><li><p>right：表明元素必须浮动在其所在的块容器右侧的关键字。</p></li></ul><p><code>clear</code><br>有时，你可能想要强制元素移至任何浮动元素下方。比如说，你可能希望某个段落与浮动元素保持相邻的位置，但又希望这个段落从头开始强制独占一行。此时可以使用<code>clear</code>。</p><p>取值：</p><ul><li><code>left</code>：清除左侧浮动。</li><li><code>right</code>：清除右侧浮动。</li><li><code>both</code>：清除左右两侧浮动</li></ul><h3 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h3><p><code>flex</code> CSS 简写属性设置了弹性项目如何增大或缩小以适应其弹性容器中可用的空间。</p><p><code>flex-direction</code><br>CSS <code>flex-direction </code>属性指定了内部元素是如何在 flex 容器中布局的，定义了主轴的方向(正方向或反方向)。</p><p>取值：</p><ul><li><code>row</code>：flex 容器的主轴被定义为与文本方向相同。 主轴起点和主轴终点与内容方向相同。</li><li><code>row-reverse</code>：表现和 row 相同，但是置换了主轴起点和主轴终点。</li><li><code>column</code>：flex 容器的主轴和块轴相同。主轴起点与主轴终点和书写模式的前后点相同</li><li><code>column-reverse</code>：表现和 column 相同，但是置换了主轴起点和主轴终点</li></ul><p><code>flex-wrap</code></p><p>CSS 的 <code>flex-wrap</code> 属性指定 flex 元素单行显示还是多行显示。如果允许换行，这个属性允许你控制行的堆叠方向。</p><p>取值：</p><ul><li><code>nowrap</code>：默认值。不换行。</li><li><code>wrap</code>：换行，第一行在上方。</li><li><code>wrap-reverse</code>：换行，第一行在下方。</li></ul><p><code>flex-flow</code><br>CSS <code>flex-flow</code> 属性是<code> flex-direction</code> 和 <code>flex-wrap</code> 的简写。默认值为：<code>row nowrap</code>。</p><p><code>justify-content</code><br>CSS<code>justify-content</code>属性定义了浏览器之间，如何分配顺着弹性容器主轴(或者网格行轴) 的元素之间及其周围的空间。</p><p>取值：</p><ul><li><code>flex-start</code>：默认值。左对齐。</li><li><code>flex-end</code>：右对齐。</li><li><code>space-between</code>：左右两段对齐。</li><li><code>space-around</code>：在每行上均匀分配弹性元素。相邻元素间距离相同。每行第一个元素到行首的距离和每行最后一个元素到行尾的距离将会是相邻元素之间距离的一半。</li><li><code>space-evenly</code>：flex 项都沿着主轴均匀分布在指定的对齐容器中。相邻 flex 项之间的间距，主轴起始位置到第一个 flex 项的间距，主轴结束位置到最后一个 flex 项的间距，都完全一样。</li></ul><p><code>align-items</code><br>CSS <code>align-items</code>属性将所有直接子节点上的 align-self 值设置为一个组。 <code>align-self</code>属性设置项目在其包含块中在交叉轴方向上的对齐方式。</p><p>取值：</p><ul><li><code>flex-start</code>：元素向主轴起点对齐。</li><li><code>flex-end</code>：元素向主轴终点对齐。</li><li><code>center</code>：元素在侧轴居中。</li><li><code>stretch</code>：弹性元素被在侧轴方向被拉伸到与容器相同的高度或宽度。</li></ul><p><code>order</code><br>定义 flex 项目的顺序，值越小越靠前。</p><p><code>flex-grow</code><br>CSS 属性 <code>flex-grow</code> CSS 设置 flex 项主尺寸 的 flex 增长系数。</p><p>负值无效，默认为 0。</p><p><code>flex-shrink</code><br>CSS flex-shrink 属性指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。</p><p>负值无效，默认为 1。</p><p><code>flex-basis</code><br>CSS 属性 flex-basis 指定了 flex 元素在主轴方向上的初始大小。</p><p>取值：<br>width 值可以是 <code>&lt;length&gt;</code>; 该值也可以是一个相对于其父弹性盒容器主轴尺寸的百分数 。负值是不被允许的。默认为 auto。</p><p><code>flex</code><br><code>flex-grow</code>、<code>flex-shrink</code>、<code>flex-basis</code>的缩写。</p><p>常用取值：</p><ul><li><code>auto</code>：<code>flex: 1 1 auto</code></li><li><code>none</code>：<code>flex: 0 0 auto</code></li></ul><h3 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h3><p>常用于设置照片墙布局</p><blockquote><p>再网格中,我们需要一个容器,将容器的显示模式设为网格</p></blockquote><blockquote><p>display:grid</p><p>grid-template-rows</p><p>grid-template-columns</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid lightgrey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想修改列的大小就需要修改两个地方,</p><p>更好的方法是使用 repeat 函数</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">100px</span>);</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100px</span>);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid lightgrey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>grid-template(这是设置模板行和列的缩写)</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">grid-template</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">100px</span>) / <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100px</span>);</span><br></pre></td></tr></table></figure><p>元素:</p><blockquote><p>justify-items(横轴对齐)</p><p>align-items(纵轴对齐)</p></blockquote><p>网格整体:</p><blockquote><p>justify-content(横轴对齐)</p><p>align-content(纵轴对齐)</p></blockquote><p>间隔:</p><blockquote><p>row-gap</p><p>column-gap</p><p>gap(行间隔和列间隔的缩写)</p></blockquote><p>合并单元格:</p><blockquote><p>grid-row</p><p>grid-column</p><p>grid-area(合并区域)</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">grid-column</span>: <span class="number">1</span> / span <span class="number">3</span>;<span class="comment">/*占据1到3列*/</span></span><br><span class="line"><span class="attribute">grid-row</span>: <span class="number">2</span> / span <span class="number">4</span>; <span class="comment">/*占据2到4行*/</span></span><br><span class="line"><span class="attribute">grid-area</span>: <span class="number">1</span> / <span class="number">1</span> / <span class="number">1</span>/ <span class="number">3</span>; <span class="comment">/*头两个数字代表起始位置,后两个数字代表结束位置</span></span><br></pre></td></tr></table></figure><blockquote><p>另一个合并方式:先指定一个特殊范围,再用元素来填充</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">grid-template-areas</span>:</span><br><span class="line">  <span class="string">&quot;header header&quot;</span></span><br><span class="line">  <span class="string">&quot;sidebar main&quot;</span></span><br><span class="line">  <span class="string">&quot;footer footer&quot;</span>;</span><br><span class="line"><span class="comment">/*给单元格起名*/</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box-one</span>&#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: header;</span><br><span class="line">&#125;<span class="comment">/*直接写名字,不用引号,否则不会识别</span></span><br></pre></td></tr></table></figure><h3 id="隐藏元素"><a href="#隐藏元素" class="headerlink" title="隐藏元素"></a>隐藏元素</h3><blockquote><p>第一种方法设置 display: none;</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.first</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第二种方法设置属性不可见 visibility: visible</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.first</span> &#123;</span><br><span class="line">  <span class="attribute">visibility</span>: visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>区别</p></blockquote><p>第一种,后面的元素会占据隐藏元素的位置</p><p>第二种,后面的元素不会占据隐藏元素的位置</p><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><blockquote><p>使用媒体查询,可以在不同设备上提供不同样式,取决于它们的分辨率</p></blockquote><p>有了它,就可以创建在手机,平板或者 PC 上都完美的网页</p><p>我们称这种网页叫响应式网页,因为它可以针对不同介质做出调整</p><p>创建响应式网页是需要有针对性的,</p><p>我们可以优先设计桌面网页,而针对平板和手机进行调整</p><p>不同的网页设计思路不同</p><p>但是大部分人都是以手机页面为主的,</p><p>因为创建手机页面要简单的多</p><blockquote><p>媒体查询</p><p>需要设置中止点</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">600px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">900px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果条件满足最小宽度 600px,最大宽度 900px</p><p>大括号中的样式就会执行,否则就不会执行</p><p>当屏幕小于 600px 或大于 900px 就变成纵向排列,否则就是横向</p><blockquote><p>案例:</p><p>将媒体类型设置为打印机</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> print &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12pt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结</p></blockquote><ul><li>使用媒体查询,可以检查当前设备的类型以及大小</li><li>然后提供只在某些场合下使用的样式</li></ul><p>或者</p><p>使用 Bootstrap</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建</title>
      <link href="/post/afcbc60d.html"/>
      <url>/post/afcbc60d.html</url>
      
        <content type="html"><![CDATA[<h1 id="环境与工具准备"><a href="#环境与工具准备" class="headerlink" title="环境与工具准备"></a>环境与工具准备</h1><p><strong>本教程主要面对的是 Windows 用户</strong></p><ul><li>操作系统：Windows10</li><li>Node</li><li>Git</li><li>Hexo</li><li>文本编辑器(强烈推荐 VSCODE)</li><li>GitHub 帐号</li><li>一个域名（强烈推荐买个域名）</li><li>云服务器（可选）</li></ul><h1 id="Node-的安装"><a href="#Node-的安装" class="headerlink" title="Node 的安装"></a>Node 的安装</h1><ol><li><p>打开 Node 官网，下载和自己系统相配的 Node 的安装程序，否则会出现安装问题。下载地址：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><br>我个人的版本是 12.19.0，目前版本已经更新到 19.0.0，按照个人经验，可以选个低一些的版本，可以和我的一样，否则后面会出现各种不兼容的问题！我之前就是安装 16 的，系统无法识别，如果大家遇到问题建议选个低版本的！历史版本下载页面：<a href="https://nodejs.org/en/download/releases/">https://nodejs.org/en/download/releases/</a><br><a href="https://s1.vika.cn/space/2022/10/27/876780920daf4f8fb319d49ff68f17a3"><img src="https://s1.vika.cn/space/2022/10/27/876780920daf4f8fb319d49ff68f17a3" alt="image-20221027173738226"></a></p></li><li><p>下载后安装，安装的目录可以使用默认目录【C:&#x2F;Program Files&#x2F;nodejs&#x2F;】，也可以自定义路径。<br>这个环境路径切换坑也很多，如果大家 C 盘空间足够可以直接装 C 盘，如果想切换其他盘或者把环境遍历切换到自定义路径也可以，具体教程百度(不过坑比较多就是了)!</p></li><li><p>安装完成后，检查是否安装成功。在键盘按下 win + R 键，输入 CMD，然后回车，打开 CMD 窗口，执行 node -v 命令，看到版本信息，则说明安装成功。</p></li><li><p>修改 npm 源。npm 下载各种模块，默认是从国处服务器下载，速度较慢，建议配置成淘宝镜像。打开 CMD 窗口，运行如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li></ol><h1 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h1><ol><li><p>在<code>Git BASH</code>输入如下命令安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li><li><p>安装完后输入 hexo -v 验证是否安装成功。</p></li></ol><p><a href="https://s1.vika.cn/space/2022/10/27/f05830f48da44ea98d2a55c3a6663004"><img src="https://s1.vika.cn/space/2022/10/27/f05830f48da44ea98d2a55c3a6663004" alt="image-20221027173525181"></a></p><h1 id="Github-注册与创建仓库"><a href="#Github-注册与创建仓库" class="headerlink" title="Github 注册与创建仓库"></a>Github 注册与创建仓库</h1><ol><li>进入官网 <a href="https://github.com/">https://github.com/</a><br><a href="https://bu.dusays.com/2022/05/12/627d2c0449341.webp"><img src="https://bu.dusays.com/2022/05/12/627d2c0449341.webp" alt="Github注册"></a></li><li>点击右上角的 Sign up(注册)<br><a href="https://bu.dusays.com/2022/05/12/627d2c05ee628.png"><img src="https://bu.dusays.com/2022/05/12/627d2c05ee628.png" alt="Github注册"></a></li><li>填写自己的邮箱、密码、用户名等信息，然后用邮箱验证即可完成。</li><li>注册完成后，点击右上角的<code>+</code>按钮，选择<code>New repository</code>，创建一个<code>&lt;用户名&gt;.github.io</code>的仓库。</li></ol><p><a href="https://s1.vika.cn/space/2022/10/27/7a06143d180d47088833a486732dccf5"><img src="https://s1.vika.cn/space/2022/10/27/7a06143d180d47088833a486732dccf5" alt="image-20221027110619071"></a></p><ul><li>仓库的格式必须为：<code>&lt;用户名&gt;.github.io</code> (注意：前缀必须为用户名，不要等后面 404 了再来为什么！！！)</li><li>Description：为描述仓库（选填）</li><li>勾选 Initialize this repository with a README 初始化一个 <a href="http://readme.md/">README.md</a> 文件</li><li>点击 Creat repository 进行创建</li></ul><p><a href="https://s1.vika.cn/space/2022/10/27/0a4dbb10ca69422ca9ccb7493d0f177a"><img src="https://s1.vika.cn/space/2022/10/27/0a4dbb10ca69422ca9ccb7493d0f177a" alt="image-20221027111641909"></a></p><h1 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h1><ol><li><p>进入官网：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> ，由于官网下载太慢可以通过淘宝的开源镜像下载 网址：<a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/v2.36.1.windows.1/">https://registry.npmmirror.com/binary.html?path=git-for-windows/v2.36.1.windows.1/</a> ，下载版本更具自己的需求选择即可。</p><p><a href="https://s1.vika.cn/space/2022/10/27/28a7d7e6ef3f4df080da8d7e8337431b"><img src="https://s1.vika.cn/space/2022/10/27/28a7d7e6ef3f4df080da8d7e8337431b" alt="image-20221027111755697"></a></p></li><li><p>下载后傻瓜式安装 Git 即可，安装的目录可以使用默认目录【C:&#x2F;Program Files&#x2F;Git】，也可以自定义路径。</p></li><li><p>点击电脑左下角开始即可看见<code>Git Bash</code>。</p></li></ol><p><a href="https://bu.dusays.com/2022/05/13/627d410ddc940.webp"><img src="https://bu.dusays.com/2022/05/13/627d410ddc940.webp" alt="Git Bash"></a></p><ul><li><code>Git CMD</code> 是 windows 命令行的指令风格</li><li><code>Git Bash</code> 是 linux 系统的指令风格（建议使用）</li><li><code>Git GUI</code>是图形化界面（新手学习不建议使用）</li></ul><ol><li><p>常用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">git config -l  //查看所有配置</span><br><span class="line">git config --system --list //查看系统配置</span><br><span class="line">git config --global --list //查看用户（全局）配置</span><br></pre></td></tr></table></figure></li><li><p>配置用户名和邮箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>git config -l</code> 检查是否配置成功，至此 git 安装及配置全部完成。</p><p><a href="https://s1.vika.cn/space/2022/10/27/9115d60b377a47f3a8b79779a287ee65"><img src="https://s1.vika.cn/space/2022/10/27/9115d60b377a47f3a8b79779a287ee65" alt="image-20221027112049822"></a></p></li></ol><h1 id="连接至-Github"><a href="#连接至-Github" class="headerlink" title="连接至 Github"></a>连接至 Github</h1><ol><li><p>执行以下命令生成 ssh 公钥，此公钥用于你的计算机连接 Github</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p>之后打开 C 盘下用户文件夹下的.ssh 的文件夹，会看到 id_rsa.pub</p><p><a href="https://bu.dusays.com/2022/05/14/627e87126fc59.png"><img src="https://bu.dusays.com/2022/05/14/627e87126fc59.png" alt="公钥"></a></p><p>用记事本打开上述图片中的公钥（id_rsa.pub），复制里面的内容，然后开始在 github 中配置 ssh 密钥。</p><p><a href="https://bu.dusays.com/2022/05/14/627e87156038a.png"><img src="https://bu.dusays.com/2022/05/14/627e87156038a.png" alt="记事本打开公钥"></a></p></li><li><p>将 SSH KEY 配置到 GitHub<br>进入 github，点击右上角头像 选择<code>settings</code>，进入设置页后选择 <code>SSH and GPG keys</code>，名字随便起，公钥填到<code>Key</code>那一栏。</p><p><img src="https://s1.vika.cn/space/2022/10/27/4a69d999fed54ff78a5b84805d3c6a12" alt="image-20221027112347632"></p><p><a href="https://s1.vika.cn/space/2022/10/27/aa20ae7d8db34e2596638f5f031f0814"><img src="https://s1.vika.cn/space/2022/10/27/aa20ae7d8db34e2596638f5f031f0814" alt="image-20221027112416710"></a></p><p><a href="https://s1.vika.cn/space/2022/10/27/eaccde8a10eb4cde945a1ed221bb6ace"><img src="https://s1.vika.cn/space/2022/10/27/eaccde8a10eb4cde945a1ed221bb6ace" alt="image-20221027112657256"></a></p></li><li><p>测试连接，输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><a href="https://s1.vika.cn/space/2022/10/27/122bb1ef33074bee84030a525ce1ec56"><img src="https://s1.vika.cn/space/2022/10/27/122bb1ef33074bee84030a525ce1ec56" alt="image-20221027112918539"></a></p><p>出现连接到账户的信息，说明已经大功告成，至此完成了环境准备工作。</p></li></ol><h1 id="初始化-Hexo-项目"><a href="#初始化-Hexo-项目" class="headerlink" title="初始化 Hexo 项目"></a>初始化 Hexo 项目</h1><ol><li><p>在目标路径（我这里选的路径为【C:&#x2F;Hexo-Blog】）打开 cmd 命令窗口，执行<code>hexo init</code>初始化项目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">hexo init blog-demo(项目名)</span><br></pre></td></tr></table></figure><p><a href="https://s1.vika.cn/space/2022/10/27/1fbeb52671cf4b1daeca3660d1a31a2f"><img src="https://s1.vika.cn/space/2022/10/27/1fbeb52671cf4b1daeca3660d1a31a2f" alt="image-20221027113206776"></a></p></li><li><p>进入<code>blog-demo</code> ，输入<code>npm i</code>安装相关依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">cd blog-demo  //进入blog-demo文件夹</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p><a href="https://s1.vika.cn/space/2022/10/27/150eeb3e61c94b89a1cad2a3079b1f94"><img src="https://s1.vika.cn/space/2022/10/27/150eeb3e61c94b89a1cad2a3079b1f94" alt="image-20221027113331624"></a></p></li><li><p>初始化项目后，<code>blog-demo</code>有如下结构：</p></li></ol><p><a href="https://s1.vika.cn/space/2022/10/27/70cf503f27c54d30a31c6b13735023b7"><img src="https://s1.vika.cn/space/2022/10/27/70cf503f27c54d30a31c6b13735023b7" alt="image-20221027113438707"></a></p><p>【node_modules】：依赖包<br>【scaffolds】：生成文章的一些模板<br>【source】：用来存放你的文章<br>【themes】：主题<br>【.npmignore】：发布时忽略的文件（可忽略）<br>【_config.landscape.yml】：主题的配置文件<br>【config.yml】：博客的配置文件<br>【package.json】：项目名称、描述、版本、运行和开发等信息</p><ol><li><p>输入 hexo server 或者 hexo s 启动项目</p><p><a href="https://s1.vika.cn/space/2022/10/27/688592f6db1448d29a2f722fc7a0bb0a"><img src="https://s1.vika.cn/space/2022/10/27/688592f6db1448d29a2f722fc7a0bb0a" alt="image-20221027113534970"></a></p></li><li><p>打开浏览器，输入地址：<a href="http://localhost:4000/">http://localhost:4000/</a> ，看到下面的效果，说明你的博客已经构建成功了。</p><p><a href="https://bu.dusays.com/2022/05/26/628e5423df640.webp"><img src="https://bu.dusays.com/2022/05/26/628e5423df640.webp" alt="博客首页"></a></p></li></ol><h1 id="将静态博客挂载到-GitHub-Pages"><a href="#将静态博客挂载到-GitHub-Pages" class="headerlink" title="将静态博客挂载到 GitHub Pages"></a>将静态博客挂载到 GitHub Pages</h1><ol><li><p>安装 hexo-deployer-git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>修改 _config.yml 文件<br>在 blog-demo 目录下的_config.yml，就是整个 Hexo 框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的<a href="https://hexo.io/zh-cn/docs/configuration">配置描述</a>。<br>修改最后一行的配置，将 repository 修改为你自己的 github 项目地址即可，还有分支要改为<code>main</code>代表主分支（注意缩进）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:Fomalhaut-Blog/Fomalhaut-Blog.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure></li><li><p>修改好配置后，运行如下命令，将代码部署到 GitHub（Hexo 三连）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy  // Git BASH终端</span><br><span class="line">hexo clean; hexo generate; hexo deploy  // VSCODE终端</span><br></pre></td></tr></table></figure><ul><li><p>hexo clean：删除之前生成的文件，若未生成过静态文件，可忽略此命令。</p></li><li><p>hexo generate：生成静态文章，可以用<code>hexo g</code>缩写</p></li><li><p>hexo deploy：部署文章，可以用<code>hexo d</code>缩写</p><p><a href="https://s1.vika.cn/space/2022/10/27/7ed7b8256d75408aa86e90cd37d0ea53"><img src="https://s1.vika.cn/space/2022/10/27/7ed7b8256d75408aa86e90cd37d0ea53" alt="image-20221027113704801"></a></p><p>注意：deploy 时可能要你输入 username 和 password。</p><p>如果出现<code>Deploy done</code>，则说明部署成功了。</p><p><a href="https://s1.vika.cn/space/2022/10/27/85b61e7242214d368539d744b4778a5d"><img src="https://s1.vika.cn/space/2022/10/27/85b61e7242214d368539d744b4778a5d" alt="image-20221027113756069"></a></p><p>稍等两分钟，打开浏览器访问：<a href="https://fomalhaut-blog.github.io/">https://Fomalhaut-Blog.github.io</a> ，这时候我们就可以看到博客内容了。</p><p><a href="https://s1.vika.cn/space/2022/10/27/6de50dfe03604b07aa26fb7dd5fe1f99"><img src="https://s1.vika.cn/space/2022/10/27/6de50dfe03604b07aa26fb7dd5fe1f99" alt="image-20221027113923949"></a></p></li></ul></li></ol><h2 id="10-无法连接至-Github-的解决方案"><a href="#10-无法连接至-Github-的解决方案" class="headerlink" title="10. 无法连接至 Github 的解决方案"></a>10. 无法连接至 Github 的解决方案</h2><p>注意：当你在与 Github 进行 ssh 通信时候出现超时或者是连接被关闭的情况，可以尝试以下解决方案。</p><ol><li><p>挂代理和换网络（这个就不用多说了）</p></li><li><p><a href="https://blog.csdn.net/weixin_41287260/article/details/124368189">Git 问题：解决“ssh:connect to host github.com port 22: Connection timed out”</a></p><p>这是评论区的朋友提供的，可以解决 SSH 连接超时等问题</p></li><li><p>开源项目<a href="https://github.com/521xueweihan/GitHub520">Github520</a></p><p>通过修改 Host 文件的方法解决访问速度慢的问题</p></li></ol><p>连接有效性检验：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 任选其一即可</span><br><span class="line">ping github.com</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/post/5751eea2.html"/>
      <url>/post/5751eea2.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><strong>问题 1</strong>：c++头文件为什么没有.h？</p><p>​ 在 c 语言中头文件使用扩展名.h,将其作为一种通过名称标识文件类型的简单方式。但是 c++得用法改变了，c++头文件没有扩展名。但是有些 c 语言的头文件被转换为 c++的头文件，这些文件被重新命名，丢掉了扩展名.h(使之成为 c++风格头文件)，并在文件名称前面加上前缀 c(表明来自 c 语言)。例如 c++版本的 math.h 为 cmath.</p><p>​ 由于 C 使用不同的扩展名来表示不同文件类型，因此用一些特殊的扩展名(如 hpp 或 hxx)表示 c++的头文件也是可以的，ANSI&#x2F;IOS 标准委员会也认为是可以的，但是关键问题是用哪个比较好，最后一致同意不适用任何扩展名。</p><table><thead><tr><th>头文件类型</th><th>约定</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>c++旧式风格</td><td>以.h 结尾</td><td>iostream.h</td><td>c++程序可用</td></tr><tr><td>c 旧式风格</td><td>以.h 结尾</td><td>math.h</td><td>c&#x2F;c++程序可用</td></tr><tr><td>c++新式风格</td><td>无扩展名</td><td>iostream</td><td>c++程序可用，使用 namespace std</td></tr><tr><td>转换后的 c</td><td>加上前缀 c,无扩展名</td><td>cmath</td><td>c++程序可用，可使用非 c 特性，如 namespace std</td></tr></tbody></table><p><strong>问题 2</strong>：using namespace std 是什么?</p><p>​ namespace 是指标识符的各种可见范围。命名空间用关键字 namespace 来定义。命名空间是 C++的一种机制，用来把单个标识符下的大量有逻辑联系的程序实体组合到一起。此标识符作为此组群的名字。</p><p><strong>问题 3</strong>：cout 、endl 是什么？</p><p>​ cout 是 c++中的标准输出流，endl 是输出换行并刷新缓冲区。</p><h1 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h1><blockquote><p>封装</p></blockquote><ul><li><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p></li><li><p>类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态。</p></li></ul><blockquote><p>继承</p></blockquote><ul><li><p>继承所表达的是类之间相关的关系，这种关系使得对象可以继承另外一类对象的特征和能力。</p></li><li><p>继承的作用：避免公用代码的重复开发，减少代码和数据冗余。</p></li></ul><blockquote><p>多态</p></blockquote><ul><li>多态性可以简单地概括为“一个接口，多种方法”，字面意思为多种形态。程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。</li></ul><h1 id="C-对-C-的扩展"><a href="#C-对-C-的扩展" class="headerlink" title="C++对 C 的扩展"></a>C++对 C 的扩展</h1><h3 id="作用域运算符"><a href="#作用域运算符" class="headerlink" title="::作用域运算符"></a>::作用域运算符</h3><blockquote><p>通常情况下，如果有两个同名变量，一个是全局变量，</p><p>另一个是局部变量，那么局部变量在其作用域内具有较高的优先权，</p><p>它将屏蔽全局变量。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//1. 局部变量和全局变量同名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//打印局部变量a</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="comment">//打印全局变量a</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量a:&quot;</span> &lt;&lt; ::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>作用域运算符可以用来解决局部变量与全局变量的重名问题，</p></blockquote><p>即在局部变量的作用域内，可用::对被屏蔽的同名的全局变量进行访问。</p><h3 id="C-命名空间-namespace"><a href="#C-命名空间-namespace" class="headerlink" title="C++命名空间(namespace)"></a>C++命名空间(namespace)</h3><blockquote><p>命名空间的用途:解决名称冲突</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::a : &quot;</span> &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间可以嵌套</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::B::a : &quot;</span> &lt;&lt; A::B::a &lt;&lt; endl;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间下可以存储 变量, 函数,结构体,类…..</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数的声明和实现可分离</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MySpace&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> param)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySpace::func2</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MySpace::func2 : &quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间必须声明在全局作用域下</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//namespace B  //不能定义在局部中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间是开放的,可以随时向空间中添加新成员</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间可以是匿名的,只能在本文件内访问</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line">cout &lt;&lt; ::b;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间可以起别名</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> veryLongName&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> shortName = veryLongName;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;veryLongName::a : &quot;</span> &lt;&lt; shortName::a &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><blockquote><p>using 声明</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LOL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sunWuKongId = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int sunWuKongId = 2; 会报错</span></span><br><span class="line">    <span class="comment">//using声明和就近原则不要同时出现,尽量避免这种情况</span></span><br><span class="line">    <span class="keyword">using</span> LOL::sunWuKongId;</span><br><span class="line">    cout &lt;&lt; sunWuKongId &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>using 编译指令</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int sunWuKongId = 2; 会输出2, 就近原则</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> LOL;</span><br><span class="line">cout &lt;&lt; sunWuKongId &lt;&lt;endl;</span><br><span class="line"><span class="comment">//using编译指令和就近原则同时出现,优先使用就近原则</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LOL和KingGlory里都有sunWuKongId</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> LOL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> KingGlory;</span><br><span class="line">cout &lt;&lt; LOL::sunWuKongId &lt;&lt;endl;</span><br><span class="line"><span class="comment">//当出现多个编译指令,并且出现同名情况,使用数据依然加zon</span></span><br></pre></td></tr></table></figure><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><h3 id="内联函数引出"><a href="#内联函数引出" class="headerlink" title="内联函数引出"></a>内联函数引出</h3><blockquote><p>在 c 中我们经常把一些短并且执行频繁的计算写成宏，而不是函数，这样做的理由是为了执行效率，宏可以避免函数调用的开销，这些都由预处理来完成。</p></blockquote><p>但是在 c++出现之后，使用预处理宏会出现两个问题：</p><ul><li><p>第一个在 c 中也会出现，宏看起来像一个函数调用，但是会有隐藏一些难以发现的错误。</p></li><li><p>第二个问题是 c++特有的，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类类的成员函数。</p></li></ul><p>为了保持预处理宏的效率又增加安全性，而且还能像一般成员函数那样可以在类里访问自如，c++引入了内联函数(inline function).</p><p>内联函数为了继承宏函数的效率，没有函数调用时开销，然后又可以像普通函数那样，可以进行参数，返回值类型的安全检查，又可以作为成员函数。</p><h3 id="预处理宏的缺陷"><a href="#预处理宏的缺陷" class="headerlink" title="预处理宏的缺陷"></a>预处理宏的缺陷</h3><blockquote><p>问题一:需要加括号保证运算的完整</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(x,y) x+y</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ret1 = <span class="built_in">ADD</span>(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span>; <span class="comment">//希望的结果是300</span></span><br><span class="line">    <span class="comment">//展开变成了 10 + 20 * 10</span></span><br><span class="line"><span class="type">int</span> ret2 = <span class="built_in">Add</span>(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span>; <span class="comment">//希望结果也是300</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret1:&quot;</span> &lt;&lt; ret1 &lt;&lt; endl; <span class="comment">//210</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret2:&quot;</span> &lt;&lt; ret2 &lt;&lt; endl; <span class="comment">//300</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解决方案, 需要加括号保证运算的完整</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(x,y) ((x) + (y))</span></span><br></pre></td></tr></table></figure><blockquote><p>问题二:即使加了括号,有些情况依然与预期效果不符</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COMPARE(x,y) ((x) &lt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Compare</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;COMPARE(++a, b):&quot; &lt;&lt; COMPARE(++a, b) &lt;&lt; endl; // 3</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Compare(int x,int y):&quot;</span> &lt;&lt; <span class="built_in">Compare</span>(++a, b) &lt;&lt; endl; <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为宏展开后是((++a) &lt; (b) ? (++a) : (b))</span></span><br></pre></td></tr></table></figure><h3 id="内联函数基本概念"><a href="#内联函数基本概念" class="headerlink" title="内联函数基本概念"></a>内联函数基本概念</h3><p>在 c++中，预定义宏的概念是用内联函数来实现的，而<strong>内联函数本身也是一个真正的函数</strong>。内联函数具有普通函数的所有行为。唯一不同之处在于内联函数会在适当的地方像预定义宏一样展开，所以不需要函数调用的开销。因此应该不使用宏，使用内联函数。</p><ul><li>在普通函数(非成员函数)函数前面加上 inline 关键字使之成为内联函数。</li><li>但是必须注意必须函数体和声明结合在一起，否则编译器将它作为普通函数来对待。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure><p>以上写法没有任何效果，仅仅是声明函数，应该如下方式来做:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="keyword">return</span> ++;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意: 编译器将会检查函数参数列表使用是否正确，并返回值(进行必要的转换)。这些事预处理器无法完成的。</p></li><li><p>内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用时候的压栈，跳转，返回的开销。我们可以理解为内联函数是以<strong>空间换时间</strong>。</p></li></ul><p>总结:</p><blockquote><p>内联函数优点</p></blockquote><p>解决了宏的缺陷,因为是普通函数,又带来了宏的优点,以空间换时间</p><blockquote><p>关键字 inline</p></blockquote><blockquote><p>函数的声明和函数的实现同时拥有 inline 才算内联</p></blockquote><h3 id="类内部的内联函数"><a href="#类内部的内联函数" class="headerlink" title="类内部的内联函数"></a>类内部的内联函数</h3><blockquote><p>类内部的成员函数,都隐藏的加了 inline 关键字</p><p>任何在类内部定义的函数自动成为内联函数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()&#123; cout &lt;&lt; <span class="string">&quot;构造函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;输出Person!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内联函数和编译器"><a href="#内联函数和编译器" class="headerlink" title="内联函数和编译器"></a>内联函数和编译器</h3><blockquote><p>c++内联编译会有一些限制，以下情况编译器可能考虑不会将函数进行内联编译：</p></blockquote><ul><li>不能存在任何形式的循环语句</li><li>不能存在过多的条件判断语句</li><li>函数体不能过于庞大</li><li>不能对函数进行取址操作</li></ul><p><strong>内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。</strong></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 5;</span><br><span class="line">int&amp; ref = a;</span><br></pre></td></tr></table></figure><p>ref 并不是一个变量,只是 a 的别名,并不占用内存空间</p><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><h3 id="把引用作为参数"><a href="#把引用作为参数" class="headerlink" title="把引用作为参数"></a>把引用作为参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> temp;</span><br><span class="line">   temp = x; <span class="comment">/* 保存地址 x 的值 */</span></span><br><span class="line">   x = y;    <span class="comment">/* 把 y 赋值给 x */</span></span><br><span class="line">   y = temp; <span class="comment">/* 把 x 赋值给 y  */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h3 id="stringstream-用法"><a href="#stringstream-用法" class="headerlink" title="stringstream 用法"></a>stringstream 用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b, c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getline</span>(cin, a);</span><br><span class="line">    cin &gt;&gt; b &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function">stringstream <span class="title">ssin</span><span class="params">(a)</span></span>;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span> (ssin &gt;&gt; str)</span><br><span class="line">        <span class="keyword">if</span> (str == b) cout &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; str &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>stringstream ssin(a); 将字符串初始化成字符串流</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swapping ostringstream objects</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>       <span class="comment">// std::string</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>      <span class="comment">// std::stringstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::stringstream ss;</span><br><span class="line"></span><br><span class="line">  ss &lt;&lt; <span class="number">100</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> foo,bar;</span><br><span class="line">  ss &gt;&gt; foo &gt;&gt; bar;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;foo: &quot;</span> &lt;&lt; foo &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;bar: &quot;</span> &lt;&lt; bar &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><blockquote><p>foo: 100<br>bar: 200</p></blockquote><h4 id="从-string-对象-str-中读取字符。遇空格结束"><a href="#从-string-对象-str-中读取字符。遇空格结束" class="headerlink" title="从 string 对象 str 中读取字符。遇空格结束"></a>从 string 对象 str 中读取字符。遇空格结束</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>; <span class="comment">//将str复制到ss</span></span><br><span class="line">string abc;</span><br><span class="line"><span class="keyword">while</span>(ss &gt;&gt; abc) <span class="comment">//相当于输入一个个的单词</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; abc &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>OUTPUT:</p><blockquote><p>hello world</p><p>hello</p><p>world</p></blockquote><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><blockquote><p>若使用普通的变量来存储的话，数据是分散的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br></pre></td></tr></table></figure><blockquote><p>但是，使用 struct 关键词，可以聚合这几种数据类型成为一个新的数据类型。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面这一串结构类型虽然很长，但是，就相当于 int 类型一样。 如同在 int 后填变量名可以声明一个整型变量。 在结构类型后面填写变量名可以声明一个结构变量。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;timmy;</span><br></pre></td></tr></table></figure><p>timmy 是由该结构声明的变量，它由 4 个成员组成。</p><p><strong>使用成员运算符 . 加上 字段名 可以访问到结构的各个成员。</strong></p><blockquote><p>timmy.name;</p><p>timmy.gender;</p><p>timmy.height;</p><p>timmy.weight;</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;timmy;</span><br><span class="line"><span class="comment">// 将Timmy的数据装入结构变量</span></span><br><span class="line"><span class="built_in">strcpy</span>(timmy.name, <span class="string">&quot;Timmy&quot;</span>);</span><br><span class="line">timmy.gender = <span class="number">1</span>;</span><br><span class="line">timmy.height = <span class="number">170.00</span>;</span><br><span class="line">timmy.weight = <span class="number">60</span>;</span><br><span class="line"><span class="comment">// 从结构变量中显示Timmy的数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, timmy.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.weight);</span><br></pre></td></tr></table></figure><h3 id="结构别名"><a href="#结构别名" class="headerlink" title="结构别名"></a>结构别名</h3><p>现在，我们想定义多个人员信息结构变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;timmy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;david;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;jane;</span><br></pre></td></tr></table></figure><blockquote><p>由于这几个结构变量的内部成员都是一致的，能不能只声明一次结构类型，后续继续使用呢？ 我们可以给结构类型声明取一个别名。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;timmy;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> david;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> jane;</span><br></pre></td></tr></table></figure><p>在第一次声明结构变量时，在 <code>struct</code> 与<code>&#123;</code>之间可以填写一个<strong>结构别名</strong>。</p><p>若以后再次需要使用这种结 构，仅需要使用 struct 加 别名 即可声明这种结构的变量。</p><p>事实上，我们可以将结构类型声明提取到最开头。让所有的结构变量均由别名来声明。相当于我们先造 了一个模板，然后，用这个模板生成各个变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> david;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> jane;</span><br></pre></td></tr></table></figure><blockquote><p>请注意，如果结构类型声明在一个函数中，那么别名只能在函数内部使用。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 别名person无法在func2中使用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> david;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 func1 声明了一个结构类型，它的别名为 person 。并且使用别名声明了一个结构变量 timmy 。</p><p>函数 func2 中，使用别名 person ，声明另一个结构变量，但是别名 person 无法在函数 func2 中使用， 因此将编译报错。</p><p>如果需要在多个函数中使用结构别名，那么可以把它放到函数外面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> david;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化结构"><a href="#初始化结构" class="headerlink" title="初始化结构"></a>初始化结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, timmy.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.weight);</span><br></pre></td></tr></table></figure><blockquote><p>结构的初始化列表的写法需要注意如下 4 点：</p></blockquote><ul><li>初始化列表由花括号包括。</li><li>花括号内为结构成员需要被初始化的值。</li><li>**初始化值按照结构成员声明时的顺序依次排列 **</li><li>每个初始化值之间由逗号分隔。</li></ul><p>对于第三点， person 结构成员声明的顺序依次为 name 、 gender 、 height 、 weight 。 对应的初始化列表中的初始化值顺序为”timmy”、 1、170.00、 60.00。 需要严格地对应顺序。</p><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> people[<span class="number">3</span>] = &#123;</span><br><span class="line">&#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;david&quot;</span>, <span class="number">1</span>, <span class="number">175.00</span>, <span class="number">65.00</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;jane&quot;</span>, <span class="number">2</span>, <span class="number">165.00</span>, <span class="number">55.00</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> per = people[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, per.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, per.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>, per.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, per.weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套结构"><a href="#嵌套结构" class="headerlink" title="嵌套结构"></a>嵌套结构</h3><blockquote><p>一个结构可以作为另一个结构的成员。</p></blockquote><p>例如，我们声明一个结构，用于存储通讯方式。通讯方式由电话号码，邮箱组成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">contact</span> &#123;</span><br><span class="line"><span class="type">char</span> phone[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> email[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>现在，我们需要记录每个人员的通讯方式。可以把这个结构作为人员结构的成员。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">contact</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;</span><br><span class="line"><span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>, &#123;<span class="string">&quot;130123456678&quot;</span>, <span class="string">&quot;timmy@xxx.com&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 . 加 字段名 可以访问到通讯方式结构。但是，你肯定还想访问其内部的成员，再次使 用 . 加 字段名 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">contact</span> &#123;</span><br><span class="line"><span class="type">char</span> phone[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> email[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">contact</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;</span><br><span class="line"><span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>, &#123;<span class="string">&quot;130123456678&quot;</span>, <span class="string">&quot;timmy@xxx.com&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, timmy.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, timmy.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>, timmy.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.weight);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.c.phone);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.c.email);</span><br></pre></td></tr></table></figure><h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> *pTimmy = &amp;timmy;</span><br></pre></td></tr></table></figure><blockquote><p>由于取地址 &amp; 与取值 * 它们具有可逆关系，我们可以把指针先转为结构再使用。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (*pTimmy).name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*pTimmy).gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, (*pTimmy).height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, (*pTimmy).weight);</span><br></pre></td></tr></table></figure><blockquote><p>由于成员运算符 . 的优先级高于取值 _ 。为了让取值 _ 先运算符，必须使用括号 *pTimmy 包括。</p><p>另外，C 语言中提供了更加方便的写法，成员间接运算符<code> -&gt;</code> 。</p></blockquote><p><code>(*pTimmy).name</code> 等价于<code> pTimmy-&gt;name</code> 。</p><h3 id="结构在函数中传递"><a href="#结构在函数中传递" class="headerlink" title="结构在函数中传递"></a>结构在函数中传递</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="keyword">struct</span> person per)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(per.name, <span class="string">&quot;david&quot;</span>);</span><br><span class="line">per.gender = <span class="number">1</span>;</span><br><span class="line">per.height = <span class="number">175.00</span>;</span><br><span class="line">per.weight = <span class="number">65.00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;;</span><br><span class="line"><span class="built_in">change</span>(timmy);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, timmy.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.weight);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>现在，我们将结构当作参数传入函数。在函数内部修改传入的参数。 很显然，由于实参 timmy 与实参 per 是相互独立的。修改函数 change 内的 per 无法改动实参 timmy 。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="keyword">struct</span> person *per)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(per-&gt;name, <span class="string">&quot;david&quot;</span>);</span><br><span class="line">per-&gt;gender = <span class="number">1</span>;</span><br><span class="line">per-&gt;height = <span class="number">175.00</span>;</span><br><span class="line">per-&gt;weight = <span class="number">65.00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;;</span><br><span class="line"><span class="built_in">change</span>(&amp;timmy);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, timmy.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.weight);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是，如果将 change 函数的参数改为指向结构的指针，情况就大不相同了。在函数 change 内部可以通 过指针，找到结构变量 timmy 。并且，对其进行修改</p></blockquote><blockquote><p>最后，将一个结构从函数返回也是可以的。从函数返回了 david 的数据，并且在将其赋值给了 timmy。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> <span class="built_in">change</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> per;</span><br><span class="line"><span class="built_in">strcpy</span>(per.name, <span class="string">&quot;david&quot;</span>);</span><br><span class="line">per.gender = <span class="number">1</span>;</span><br><span class="line">per.height = <span class="number">175.00</span>;</span><br><span class="line">per.weight = <span class="number">65.00</span>;</span><br><span class="line"><span class="keyword">return</span> per;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;;</span><br><span class="line">timmy = <span class="built_in">change</span>();</span><br></pre></td></tr></table></figure><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类中的变量和函数被统一称为类的成员变量。</p><p><code>private</code>后面的内容是私有成员变量，在类的外部不能访问；<code>public</code>后面的内容是公有成员变量，在类的外部可以访问。</p><p>类的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> age, height;</span><br><span class="line">        <span class="type">double</span> money;</span><br><span class="line">        string books[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;I&#x27;m &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">add_money</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            money += x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; person_a, person_b, persons[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person c;</span><br><span class="line"></span><br><span class="line">    c.name = <span class="string">&quot;yxc&quot;</span>;      <span class="comment">// 正确！访问公有变量</span></span><br><span class="line">    c.age = <span class="number">18</span>;          <span class="comment">// 错误！访问私有变量</span></span><br><span class="line">    c.<span class="built_in">set_age</span>(<span class="number">18</span>);       <span class="comment">// 正确！set_age()是共有成员变量</span></span><br><span class="line">    c.<span class="built_in">add_money</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    c.<span class="built_in">say</span>();</span><br><span class="line">    cout &lt;&lt; c.<span class="built_in">get_age</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成变量特殊方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">player</span> &#123;</span><br><span class="line"> <span class="type">int</span> x, y;</span><br><span class="line"> <span class="type">int</span> speed;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">     x += a * speed;</span><br><span class="line">     y += b * speed;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;c, player[<span class="number">1000</span>]; <span class="comment">//生成变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    player players[<span class="number">1000</span>]; <span class="comment">//生成变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类默认私有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class player &#123;</span><br><span class="line"> int x, y;</span><br><span class="line"> int speed;</span><br><span class="line"> void move(int a, int b)&#123;</span><br><span class="line">     x += a * speed;</span><br><span class="line">     y += b * speed;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>访问控制（private、public）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class player &#123;</span><br><span class="line">public:</span><br><span class="line"> int x, y;</span><br><span class="line"> int speed;</span><br><span class="line">private:</span><br><span class="line"> void move(int a, int b)&#123;</span><br><span class="line">     x += a * speed;</span><br><span class="line">     y += b * speed;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="C-类与结构体对比"><a href="#C-类与结构体对比" class="headerlink" title="C++类与结构体对比"></a>C++类与结构体对比</h1><p>区别：</p><blockquote><p>作用上：class 默认 private，struct 默认 public。<br>使用上：引入 struct 是为了让 C++向后兼容 C。</p></blockquote><p>推荐选用：</p><blockquote><p>若只包含一些变量结构或 POD(plain old data)时，选用 struct。例</p><p>如数学中的向量类。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec2</span>&#123;</span><br><span class="line"> <span class="type">float</span> x, y;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Vec2&amp; other)</span></span>&#123;</span><br><span class="line">     x += other.x;</span><br><span class="line">     y += other.y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>若要实现很多功能的类，则选用 class</p><p>若是只有数据,函数较少的,用 struct</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么数组的下标从0开始</title>
      <link href="/post/4d963d9c.html"/>
      <url>/post/4d963d9c.html</url>
      
        <content type="html"><![CDATA[<p>很多小伙伴初学编程的时候一定都被元素下标折磨过，<strong>为什么很多编程语言要把 0 作为第一个下标索引，而不是直观的 1 呢？</strong></p><p>这个问题 Dijkstra 已经解答过了，没错，就是你知道的 Dijkstra，Dijkstra 最短路径算法，荷兰语全名是 Edsger Wybe Dijkstra，于 1972 年获得了图灵奖，除了上面说的最短路径算法，还有众所周知的信号量和 PV 原语、银行家算法等也是这位巨佬提出的。</p><p>原文在这里：<a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html">https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html</a></p><p>感兴趣的小伙伴可以去看下全文，下面我总结几段核心的观点：</p><p>首先来看个案例，如何用一个不等式（或者说表达式）来表示 <code>[2,3,4,5,6,7,8,9,10,11,12]</code> 这个连续的整数序列（一共 11 个数）？</p><p>假设 <code>i</code> 是一个整数，那么我们能够迅速的写出如下四个符合上述连续序列的不等式：</p><p>1）<code>2 &lt;= i &lt; 13</code></p><p>2）<code>1 &lt; i &lt;= 12</code></p><p>3）<code>2 &lt;= i &lt;= 12</code></p><p>4）<code>1 &lt; i &lt; 13</code></p><p>以上四个不等式均满足要求，那是否有理由选择其中的一种而不是另一种？</p><p>Dijkstra 说有的，选 1 和 2，因为这俩不等式有个很突出的有点，就是不等式边界的差（不等式右边 - 不等式左边）正好等于连续序列的长度</p><p>这里可以排除掉 3 和 4，那么 1 和 2 该如何选出最优的表示？</p><p>1 和 2 不等式的区别就在于：</p><ul><li>1 不等式左边（下界）等于序列中的最小值，不等式右边（上界）大于序列中的最大值</li><li>2 不等式左边（下界）小于序列中的最小值，不等式右边（上界）等于序列中的最大值</li></ul><p>对于第 2 个不等式来说，下界小于序列中的最小值，这会出现一个问题，比如我们的连续序列是 <code>[0,1,2,3,4]</code></p><p>那么按照第 2 个不等式的写法，不等式的左边就是 -1，-1 是非自然数，而我们需要表示的连续序列是自然数序列，所以第 2 个不等式很不优雅：我们需要用一个 非自然数 来作为 全是自然数的序列 的下界</p><p>因此，综上所述，不等式 1 是最优雅的选择。</p><p>那么，选出一个看着非常顺眼的不等式来表达长度为 N 的连续序列之后，下一个令人烦恼的问题是该为起始元素分配什么下标值？</p><p>遵循不等式 1 的规则：</p><ul><li>当从下标 1 开始时，下标范围 <code>1 ≤ i &lt; N+1</code></li><li>当从下标 0 开始时，下标范围 <code>0 ≤ i &lt; N</code></li></ul><p>哪个更优雅？</p><p>Dijkstra 是这样解释的：从下标 0 开始能够给出更好的不等式，因为元素的下标就等于序列中它前面的元素数（或者说 “偏移量”）。</p><p>问题解决！</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/post/3c50d03d.html"/>
      <url>/post/3c50d03d.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Markdown-Typora-x2F-VSCode-超全教程"><a href="#Markdown-Typora-x2F-VSCode-超全教程" class="headerlink" title="[Markdown+Typora&#x2F;VSCode 超全教程]"></a>[Markdown+Typora&#x2F;VSCode 超全教程]</h1><p>Sakiyary 2022&#x2F;7&#x2F;16</p><h2 id="😂-简要介绍"><a href="#😂-简要介绍" class="headerlink" title="😂 简要介绍"></a>😂 简要介绍</h2><p><strong>Markdown</strong> 是一种轻量型标记语言, 是一种语法. 以 <code>.md</code> 结尾的文本文件就是 Markdown 文件. 相较于 <strong>Word</strong>, 它更加像是 <strong>HTML</strong> 语言或是 $\LaTeX$, 并不是最淳朴的那种”所见即所得”. 它处处透露着一种极简主义. 高效简洁清晰的同时, 又很简单. 看起来舒服, 语法简单, 尤其在处理纯文本上有很大的优势.</p><p>它相较于 <strong>Word</strong>, 兼容性非常高, 可以跨平台使用, 不用担心奇奇怪怪的版本兼容问题. 同时, 有许多网站都支持或正在使用 <strong>Markdown</strong> 语法. 如 <strong>Github</strong> (等一系列代码托管平台), StackOverflow(等答疑平台), 简书, 语雀 (等一系列笔记平台).</p><h2 id="📐-实际应用"><a href="#📐-实际应用" class="headerlink" title="📐 实际应用"></a>📐 实际应用</h2><p>所有要写文本的时候都可以用上 <strong>Markdown</strong>!</p><p>它可以让你不再纠结什么字体, 什么样式, 什么排版. 而且逻辑清晰, 层次分明.</p><p>像我大一的时候就用 Markdown 来写各种笔记, 演讲稿, 课程论文, 实验报告, 代码的 <code>README.md</code> … 包括本教程文档.</p><h2 id="🍴-工具"><a href="#🍴-工具" class="headerlink" title="🍴 工具"></a>🍴 工具</h2><p>Markdown 只是一种语法. 那么用来写 Markdown 的文本编辑器呢? 我推荐的是 <strong>Typora</strong> 或者 <strong>VS Code</strong></p><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p>Typora 应该是被广泛用于写 Markdown 的文本软件, 就和 Markdown 语法一样高效. 而且它还有很实用的扩展语法与自定义样式的功能. 其能将 <code>.md</code> 导出成多种文件, 如 <code>.pdf</code>, <code>.html</code>, <code>.docx</code> (没想到吧, 能导出到 Word)</p><p>但是现在 Typora 已经发布正式版并且变为收费软件. 中文官网在此 <a href="https://typoraio.cn/">Typora 官方中文站 </a>.</p><p>我当然是推荐大家都用正版啦. 不过价格是永久版￥ 89, 好在可以用在 3 台设备上. 如果和你的两位同学&#x2F;舍友均摊一下, 每人就只要￥ 30, 和一张游戏月卡差不多.</p><p>至于盗版以及破解方法<a href="https://www.only4.work/blog/?id=379">在此随便找一种改注册表时间方法的</a><del>不介绍(还挺多的其实)</del>.</p><p><del>还有一种免费白嫖的方法就是安装测试版&#x2F;Beta 版. 官网有历史版本的下载链接 <a href="https://typoraio.cn/windows/dev_release.html">Typora 历史版本下载页</a></del></p><p>白嫖 Beta 版已经寄了, 要么支持正版要么去学习一下破解方法吧 (还是忍不住啦, 看上面的链接 👆)</p><h3 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h3><p>这是微软家的开源文本编辑器, 理论上来说所有代码, 语言, 都可以用 VS Code 来写, 同样是非常的简洁好用. 在下载插件 <strong>Markdown All in One</strong> 后对 Markdown 的基础支持也是非常的好. 若在 VS Code 下载 Markdown 各种附加扩展, 就能获得比 Typora 更加丰富的扩展语法与操作.</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>大部分 IDE, 像 Jetbrain 的全家桶里应该每一款, 都支持 Markdown 语法, 在此不多赘述.</p><p>本文档主要使用 Typora 进行演示, 同时会介绍许多 Typora 所包含的扩展语法.</p><h2 id="🍭-基础教程"><a href="#🍭-基础教程" class="headerlink" title="🍭 基础教程"></a>🍭 基础教程</h2><p>当有多种标记方法时我会倾向其中一种.</p><p>标题有 <code>*</code> 表示该为扩展语法, 仅在 Typora 或 添加了扩展的 VS Code <strong>本地生效</strong>, 在大多数平台上<strong>并不认可</strong>.</p><h3 id="0-写-Markdown-的第零步"><a href="#0-写-Markdown-的第零步" class="headerlink" title="0. 写 Markdown 的第零步"></a>0. 写 Markdown 的第零步</h3><p>我们写文本的时候大多写的是中文, 可是输入法在输中文时使用的标点为全角标点, 如 <code>，。？！（）【】：；“”</code>. 这些标点是不被 Markdown 所认可的, 也是无法转义的.</p><p>我建议大家写 Markdown 的时候都用半角标点, 即英文标点, 如 <code>,.?!()[]:;&quot;&quot;</code>. 且每个半角标点在文本使用时加上后置空格, 符合英文标点的书写规范, 也更加美观.</p><p>以微软自带输入法举例, 在使用中文输入法时按下 <code>Ctrl</code> + <code>.(这是个句号)</code>, 切换标点的全角与半角. 这样即可中文输入+半角标点.</p><h3 id="1-标题-数个-“-”-空格-前置"><a href="#1-标题-数个-“-”-空格-前置" class="headerlink" title="1. 标题 [数个 “#” + 空格 前置]"></a>1. 标题 [数个 “#” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>标题会在目录与大纲分级显示, 可以跳转.</p><p>在 Typora 中建议开启 <code>严格模式</code>, 即不应为 <code>#标题</code>, 应为 <code># 标题</code>.</p><p>应该要手动补上空格, 使得 Markdown 语法在其他文本编辑器上兼容.</p><h3 id="2-强调-用-“-”-或-“-”-包围"><a href="#2-强调-用-“-”-或-“-”-包围" class="headerlink" title="2. 强调 [用 “**” 或 “__” 包围]"></a>2. 强调 [用 “**” 或 “__” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**欢迎报考南京大学!** (我喜欢用这种)</span><br><span class="line">__欢迎报考南京大学!__</span><br></pre></td></tr></table></figure><p>或者选中想要强调的文字按下 <code>Ctrl</code> + <code>B</code>.</p><p>E.G.</p><p><strong>欢迎报考南京大学!</strong></p><h3 id="3-斜体-用-“-”-或-“-”-包围"><a href="#3-斜体-用-“-”-或-“-”-包围" class="headerlink" title="3. 斜体 [用 “*” 或 “_” 包围]"></a>3. 斜体 [用 “*” 或 “_” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*欢迎大佬来浇浇我各种知识* (我喜欢用这种)</span><br><span class="line">_欢迎大佬来浇浇我各种知识_</span><br></pre></td></tr></table></figure><p>或者选中想要强调的文字按下 <code>Ctrl</code> + <code>I</code>.</p><p>E.G.</p><p><em>欢迎大佬来浇浇我各种知识</em></p><p>(P.S. <strong><em>斜体并强调</em></strong> [用 “***” 或 “___” 包围])</p><h3 id="4-删除线-用-“-”-包围"><a href="#4-删除线-用-“-”-包围" class="headerlink" title="4. 删除线 [用 “~~” 包围]"></a>4. 删除线 [用 “~~” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~我宣布个事儿, 我是Sabiyary!~~</span><br></pre></td></tr></table></figure><p>E.G.</p><p><del>我宣布个事儿, 我是 Sabiyary!</del></p><h3 id="5-高亮-用-“-x3D-x3D-”-包围"><a href="#5-高亮-用-“-x3D-x3D-”-包围" class="headerlink" title="5. *高亮 [用 “&#x3D;&#x3D;” 包围]"></a>5. *高亮 [用 “&#x3D;&#x3D;” 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==我喜欢黄色, 也喜欢绿色==</span><br></pre></td></tr></table></figure><p>E.G.</p><p>&#x3D;&#x3D;我喜欢黄色, 也喜欢绿色&#x3D;&#x3D;</p><h3 id="6-代码-用-“-96-”-包围"><a href="#6-代码-用-“-96-”-包围" class="headerlink" title="6. 代码 [用 “&#96;” 包围]"></a>6. 代码 [用 “&#96;” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`sudo rm -rf /*`</span><br></pre></td></tr></table></figure><p>E.G.</p><p><code>sudo rm -rf /*</code> (没事别乱敲这个! )</p><p><del>“请输入管理员密码: (闪烁的光标)”</del></p><h3 id="7-代码块-按三个-“-96-”-并敲回车"><a href="#7-代码块-按三个-“-96-”-并敲回车" class="headerlink" title="7. 代码块 [按三个 “&#96;” 并敲回车]"></a>7. 代码块 [按三个 “&#96;” 并敲回车]</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="comment">// 这里就可以开始输入你要的代码了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mian</span><span class="params">()</span> &#123;</span><br><span class="line">    print（“Hello, world!\n<span class="string">&quot;）;</span></span><br><span class="line"><span class="string">    retrun O;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">``` // (这三个&quot;</span>`<span class="string">&quot;文本编辑器会帮你自动补全 一般不用手动输)</span></span><br></pre></td></tr></table></figure><p>(我之前都是用这个来展示各种语法的, 应该不用举例了吧)</p><p>要想显示行数的话, 一般要在 Typora 的设置里勾上这个显示行数的选项.</p><p>代码块里可以选择语言, 其会根据语言来自动高亮各个语句. 在选择语言后, <code>```</code> 会变为 <code>````</code> + <code>对应语言</code>.</p><h3 id="8-引用-“-gt-”-空格-前置"><a href="#8-引用-“-gt-”-空格-前置" class="headerlink" title="8. 引用 [“&gt;” + 空格 前置]"></a>8. 引用 [“&gt;” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 24岁, 是学生.</span><br><span class="line">&gt; &gt; 学生特有的无处不在(恼)</span><br></pre></td></tr></table></figure><p>引用是可以嵌套的!</p><p>E.G.</p><blockquote><p>24 岁, 是学生.</p><blockquote><p>学生特有的无处不在(恼)</p></blockquote></blockquote><h3 id="9-无序列表-“-“-或-“-”-空格-前置"><a href="#9-无序列表-“-“-或-“-”-空格-前置" class="headerlink" title="9. 无序列表 [“-“ 或 “+” + 空格 前置]"></a>9. 无序列表 [“-“ 或 “+” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 一颗是枣树 (我喜欢用这种)</span><br><span class="line">+ 另一颗还是枣树</span><br><span class="line">* (其实这种也可以, 不过由于在 Typora 中很难单个输入, 故不常用)</span><br></pre></td></tr></table></figure><p>三种前置符都可以, 敲回车会自动补全, 可在 Typora 设置中调整补全的符号, 敲回车后按下 <code>Tab</code> 会缩进一级.</p><p>E.G.</p><ul><li>一颗是枣树</li><li>另一颗还是枣树</li></ul><h3 id="10-有序列表-数字-“-”-空格-前置"><a href="#10-有序列表-数字-“-”-空格-前置" class="headerlink" title="10. 有序列表 [数字 + “.” + 空格 前置]"></a>10. 有序列表 [数字 + “.” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我来这里就为了三件事:</span><br><span class="line">1. 公平</span><br><span class="line">2. 公平</span><br><span class="line">3. 还是tm的公平!</span><br></pre></td></tr></table></figure><p>敲回车会自动补全, 敲回车后按下 <code>Tab</code> 会缩进一级.</p><p>E.G.</p><p>我来这里就为了三件事:</p><ol><li><p>公平</p></li><li><p>公平</p></li><li><p>还是 tm 的公平!</p></li></ol><h3 id="11-上标-用-“-”-包围"><a href="#11-上标-用-“-”-包围" class="headerlink" title="11. *上标 [用 “^” 包围]"></a>11. *上标 [用 “^” 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中int的上限是 2^31^ - 1 = 2147483647</span><br></pre></td></tr></table></figure><p>E.G.</p><p>C 语言中 <code>int</code> 的上限是 2^31^ - 1 &#x3D; 2147483647</p><h3 id="12-下标-用-“-”-包围"><a href="#12-下标-用-“-”-包围" class="headerlink" title="12. *下标 [用 “~” 包围]"></a>12. *下标 [用 “~” 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H~2~O 是剧毒的!</span><br></pre></td></tr></table></figure><p>E.G.</p><p>H<del>2</del>O 是剧毒的!</p><h3 id="13-注释-“-”-后置"><a href="#13-注释-“-”-后置" class="headerlink" title="13. *注释 [“[^]” 后置]"></a>13. *注释 [“[^]” 后置]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励![^1]</span><br><span class="line"></span><br><span class="line">[^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.</span><br></pre></td></tr></table></figure><p>需要在文末写上注释对应的内容</p><p>E.G.</p><blockquote><p>今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励![^1]</p></blockquote><p>[^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.</p><h3 id="14-链接-常用-“-”-“-”-分别包围文本与链接"><a href="#14-链接-常用-“-”-“-”-分别包围文本与链接" class="headerlink" title="14. 链接 [常用 “[ ]” + “( )” 分别包围文本与链接]"></a>14. 链接 [常用 “[ ]” + “( )” 分别包围文本与链接]</h3><p><strong>(注意: 文内跳转为扩展用法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[来看看我贫瘠的仓库罢](https://github.com/Sakiyary)</span><br><span class="line">[基础教程: 12. 下标](#12. 下标 [用 &quot;~&quot; 包围])</span><br></pre></td></tr></table></figure><p>支持网页链接与文内跳转, 按住 <code>Ctrl</code> 并 <code>单击鼠标左键</code> 即可跳转.</p><p>E.G.</p><p><a href="https://github.com/Sakiyary">来看看我贫瘠的仓库罢</a></p><p>[基础教程: 12. 下标](#12. 下标 [用 “~” 包围])</p><h3 id="15-任务列表-“-”-空格-前置"><a href="#15-任务列表-“-”-空格-前置" class="headerlink" title="15. 任务列表 [“- [ ]” + 空格 前置]"></a>15. 任务列表 [“- [ ]” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TodoList:</span><br><span class="line">- [ ] 刷B站</span><br><span class="line">- [ ] 写代码</span><br><span class="line">- [x] 起床</span><br></pre></td></tr></table></figure><p>用 <code>x</code> 代替 <code>[ ]</code> 中的空格来勾选任务列表. 在 Typora 中可以直接用鼠标左键单击勾选框.</p><p>E.G. TodoList:</p><ul><li><input disabled="" type="checkbox"> 刷 B 站</li><li><input disabled="" type="checkbox"> 写代码</li><li><input checked="" disabled="" type="checkbox"> 起床</li></ul><h3 id="16-表格-用-“-”-绘制表格边框"><a href="#16-表格-用-“-”-绘制表格边框" class="headerlink" title="16. 表格 [用 “|” 绘制表格边框]"></a>16. 表格 [用 “|” 绘制表格边框]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 学号 | 姓名  | 年龄 |</span><br><span class="line">| :--- | :---: | ---: | (引号的位置代表着 左对齐, 居中, 右对齐)</span><br><span class="line">|114514|田所|24|</span><br><span class="line">|1919810|浩三|25|</span><br></pre></td></tr></table></figure><p>第一行为表头, 并由第二行分割线决定对齐方式与长度, 第三行及之后即表格数据</p><p>E.G.</p><table><thead><tr><th align="left">学号</th><th align="center">姓名</th><th align="right">年龄</th></tr></thead><tbody><tr><td align="left">114514</td><td align="center">田所</td><td align="right">24</td></tr><tr><td align="left">1919810</td><td align="center">浩三</td><td align="right">25</td></tr></tbody></table><h3 id="17-图片-直接拖进来或者复制粘贴"><a href="#17-图片-直接拖进来或者复制粘贴" class="headerlink" title="17. 图片 [直接拖进来或者复制粘贴]"></a>17. 图片 [直接拖进来或者复制粘贴]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片](图片的位置)</span><br></pre></td></tr></table></figure><p>我还是会选择拖进来或者复制粘贴啦~ 在 Typora 的设置里也可以改图片的储存方式.</p><h3 id="18-分割线-按三个-“-”-或-“-“-或-“-”-并敲回车"><a href="#18-分割线-按三个-“-”-或-“-“-或-“-”-并敲回车" class="headerlink" title="18. 分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]"></a>18. 分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">--- (我喜欢用这种)</span><br><span class="line">___</span><br><span class="line">// (其实按三个及以上都可以)</span><br></pre></td></tr></table></figure><p>由于 <code>*</code> 与 <code>_</code> 均会自动补全, 所以我觉得 <code>-</code> 最为方便.</p><p>E.G.</p><hr><hr><hr><h3 id="19-Emoji-表情-“-”-前置"><a href="#19-Emoji-表情-“-”-前置" class="headerlink" title="19. Emoji 表情 [“:” 前置]"></a>19. Emoji 表情 [“:” 前置]</h3><p><strong>(注意: 英文输入为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:sweat_smile:</span><br><span class="line">:drooling_face:</span><br><span class="line">:clown_face:</span><br><span class="line">// (敲回车或者鼠标点击, 后置的&quot;:&quot;一般不需要手动输)</span><br></pre></td></tr></table></figure><p>这个功能唯一的要求就是英语水平要高, 或者大概记得各个 Emoji 的英文名.</p><p>E.G.</p><p>:sweat_smile:<br>:drooling_face:<br>:clown_face:</p><p>对于其余普通的 Markdown 文本编辑器, 可以直接将 Emoji 表情复制进来, 这是直接<strong>硬编码</strong>的 (<del>刻进 DNA 里</del>)</p><p>E.G.</p><p>😅🤤🤡</p><p>用好这个功能可以让你的文本非常的可爱! <del>太抽象了</del></p><p>这里分享一个可以复制<a href="https://emojipedia.org/apple/">全 Emoji 的网站</a>, 非常好用! 我之前的 C 语言大作业也是从这里下载的资源!</p><h2 id="🔥-进阶教程"><a href="#🔥-进阶教程" class="headerlink" title="🔥 进阶教程"></a>🔥 进阶教程</h2><h3 id="1-目录-自动生成"><a href="#1-目录-自动生成" class="headerlink" title="1. 目录 [自动生成]"></a>1. 目录 [自动生成]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TOC] (此为 Typora 特有的, 如本文档开头)</span><br></pre></td></tr></table></figure><p>若使用 VS Code 搭配 Markdown All in One 扩展, 可在 VS Code 的<code>命令面板</code> (即 <a href="https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette">VS Code Command Palette</a>) 输入 <code>Create Table of Contents</code> 自动生成目录, 且可在扩展设置中细调目录参数.</p><h3 id="2-内联-HTML-代码-用-“-lt-gt-lt-x2F-gt-”-包围"><a href="#2-内联-HTML-代码-用-“-lt-gt-lt-x2F-gt-”-包围" class="headerlink" title="2. 内联 HTML 代码 [用 “&lt;&gt; &lt;&#x2F;&gt;” 包围]"></a>2. 内联 HTML 代码 [用 “&lt;&gt; &lt;&#x2F;&gt;” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align:center&quot;&gt;</span><br><span class="line">  &lt;font style=&quot;color:red&quot;&gt;我不会 HTML 呜呜呜... 浇浇我&lt;/font&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;center&gt;简单的文字居中也可以这样&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">&lt;u&gt;我差点忘了还有下划线这东西...&lt;/u&gt;</span><br></pre></td></tr></table></figure><p>只要你会写, 你完全可以把 Markdown 当作 <strong>HTML</strong> 来写.</p><p>同时, <code>.md</code> 文件可以直接导出成一个网页.</p><p>下划线可以选中想要下划的文字按下 <code>Ctrl</code> + <code>U</code>.</p><p>E.G.</p><div style="text-align:center">  <font style="color:red">我不会 HTML 呜呜呜... 浇浇我</font></div><center>简单的文字居中也可以这样</center><p><u>我差点忘了还有下划线这东西…</u></p><h3 id="3-内联-LaTeX-公式-用-“-”-包围"><a href="#3-内联-LaTeX-公式-用-“-”-包围" class="headerlink" title="3. 内联 $\LaTeX$ 公式 [用 “$” 包围]"></a>3. 内联 $\LaTeX$ 公式 [用 “$” 包围]</h3><p><strong>(注意: 部分编译器会不识别部分符号)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$\LaTeX$ 是最好用的论文排版语言! 不信你看!</span><br><span class="line"></span><br><span class="line">$a^n+b^n=c^n$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">%\usepackage&#123;unicode-math&#125;</span><br><span class="line">\displaystyle \ointctrclockwise\mathcal&#123;D&#125;[x(t)]</span><br><span class="line">\sqrt&#123;\frac&#123;\displaystyle3\uppi^2-\sum_&#123;q=0&#125;^&#123;\infty&#125;(z+\hat L)^&#123;q&#125;</span><br><span class="line">\exp(\symrm&#123;i&#125;q^2 \hbar x)&#125;&#123;\displaystyle (\symsfup&#123;Tr&#125;\symbfcal&#123;A&#125;)</span><br><span class="line">\left(\symbf\Lambda_&#123;j_1j_2&#125;^&#123;i_1i_2&#125;\Gamma_&#123;i_1i_2&#125;^&#123;j_1j_2&#125;</span><br><span class="line">\hookrightarrow\vec D\cdot \symbf P \right)&#125;&#125;</span><br><span class="line">=\underbrace&#123;\widetilde&#123;\left\langle \frac&#123;\notin \emptyset&#125;</span><br><span class="line">&#123;\varpi\alpha_&#123;k\uparrow&#125;&#125;\middle\vert</span><br><span class="line">\frac&#123;\partial_\mu T_&#123;\mu\nu&#125;&#125;&#123;2&#125;\right\rangle&#125;&#125;_&#123;\mathrm&#123;K&#125;_3</span><br><span class="line">\mathrm&#123;Fe&#125;(\mathrm&#123;CN&#125;)_6&#125; ,\forall z \in \mathbb&#123;R&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>用 <code>$</code> 包围为单条公式, 按下两个 <code>$</code> 并敲回车即生成公式块.</p><p>E.G.</p><p>$\LaTeX$ 是最好用的论文排版语言! 不信你看!</p><p>$a^n+b^n&#x3D;c^n$</p><p>$$<br>%\usepackage{unicode-math}<br>\displaystyle \ointctrclockwise\mathcal{D}[x(t)]<br>\sqrt{\frac{\displaystyle3\uppi^2-\sum_{q&#x3D;0}^{\infty}(z+\hat L)^{q}<br>\exp(\symrm{i}q^2 \hbar x)}{\displaystyle (\symsfup{Tr}\symbfcal{A})<br>\left(\symbf\Lambda_{j_1j_2}^{i_1i_2}\Gamma_{i_1i_2}^{j_1j_2}<br>\hookrightarrow\vec D\cdot \symbf P \right)}}<br>&#x3D;\underbrace{\widetilde{\left\langle \frac{\notin \emptyset}<br>{\varpi\alpha_{k\uparrow}}\middle\vert<br>\frac{\partial_\mu T_{\mu\nu}}{2}\right\rangle}}_{\mathrm{K}_3<br>\mathrm{Fe}(\mathrm{CN})_6} ,\forall z \in \mathbb{R}<br>$$</p><h3 id="4-网络图床"><a href="#4-网络图床" class="headerlink" title="4. *网络图床"></a>4. *网络图床</h3><p>(这是学长给我的网络图床教程, 我并未实践过…)</p><p>分享一个 Typora 搭配腾讯云 COS&#x2F;阿里云 OSS 图床的<a href="https://blog.csdn.net/guo_ridgepole/article/details/108257277">例子</a>. 新用户免费试用 6 个月, 另外还可选择七牛云或者路过图床.</p><h3 id="5-Typora-的常用快捷键"><a href="#5-Typora-的常用快捷键" class="headerlink" title="5. *Typora 的常用快捷键"></a>5. *Typora 的常用快捷键</h3><table><thead><tr><th align="center">按键</th><th align="center">效果</th><th align="center">按键</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center"><code>Ctrl</code> + <code>D</code></td><td align="center">选中当前词</td><td align="center"><code>Ctrl</code> + <code>L</code></td><td align="center">选中当前句&#x2F;行</td></tr><tr><td align="center"><code>Ctrl</code> + <code>E</code></td><td align="center">选中当前区块</td><td align="center"><code>Ctrl</code> + <code>F</code></td><td align="center">搜索当前选中</td></tr><tr><td align="center"><code>Ctrl</code> + <code>B</code></td><td align="center">加粗当前选中</td><td align="center"><code>Ctrl</code> + <code>H</code></td><td align="center">替换当前选中</td></tr><tr><td align="center"><code>Ctrl</code> + <code>I</code></td><td align="center">倾斜当前选中</td><td align="center"><code>Ctrl</code> + <code>U</code></td><td align="center">下划当前选中</td></tr><tr><td align="center"><code>Ctrl</code> + <code>K</code></td><td align="center">将当前选中生成链接</td><td align="center"><code>Ctrl</code> + <code>J</code></td><td align="center">滚动屏幕将选中滚至顶部</td></tr><tr><td align="center"><code>Ctrl</code> + <code>W</code></td><td align="center">关闭当前窗口</td><td align="center"><code>Ctrl</code> + <code>N</code></td><td align="center">打开新窗口</td></tr><tr><td align="center"><code>Ctrl</code> + <code>O</code></td><td align="center">打开文件</td><td align="center"><code>Ctrl</code> + <code>P</code></td><td align="center">搜索文件并打开</td></tr><tr><td align="center"><code>Ctrl</code> + <code>回车</code></td><td align="center">表格下方插入行</td><td align="center"><code>Ctrl</code> + <code>,</code></td><td align="center">打开偏好设置</td></tr><tr><td align="center"><code>Ctrl</code> + <code>.</code></td><td align="center">切换全角&#x2F;半角标点</td><td align="center"><code>Ctrl</code> + <code>/</code></td><td align="center">切换正常&#x2F;源代码视图</td></tr><tr><td align="center"><code>Ctrl</code> + <code>Shift</code> + <code>-</code></td><td align="center">缩小视图缩放</td><td align="center"><code>Ctrl</code> + <code>Shift</code> + <code>+</code></td><td align="center">放大视图缩放</td></tr></tbody></table><p>还有一些不常用的&#x2F;三键的快捷键不在此列出.</p><h3 id="6-Typora-的主题样式与检查元素"><a href="#6-Typora-的主题样式与检查元素" class="headerlink" title="6. *Typora 的主题样式与检查元素"></a>6. *Typora 的主题样式与检查元素</h3><p>Markdown 在编译后约等于 HTML. 而 Typora 的正常视图就是编译后的 Markdown, 故 Typora 的主题样式本质就是 CSS 文件.</p><p>可以下载各种好看的主题给 Typora 换上, 同时也可以自己调整对应的 CSS 文件, 或者自己手搓.</p><p>在 Typora 设置中开启 <code>调试模式</code> 后即可在正常视图右击打开 <code>检查元素</code>, 在其中就可以完全将 Markdown 文件当成 HTML 来编辑.</p><h2 id="💯-总结"><a href="#💯-总结" class="headerlink" title="💯 总结"></a>💯 总结</h2><p>至此, <strong>Markdown + Typora &#x2F; VSCode</strong> 的手册教程也告一段落.</p><p>不知你看完这么长的教程&#x2F;手册, 是否能体会到 Markdown 的精妙简洁之处呢?</p><p>其实 Markdown 只是标记语言的最开始, 我的感受是会了 Markdown 之后对于理解 HTML 也有帮助, 对于用 $\LaTeX$ 来写论文也有帮助. 标记语言正是为了摆脱 Word 那种虽然”所见即所得”, 但又过于花哨浮华, 很差的兼容性与闭源的编码的缺陷. 当你能掌握这样的”所写即所得”时, 你肯定会感受到用 Markdown 这类语言来处理文本的妙处!</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
