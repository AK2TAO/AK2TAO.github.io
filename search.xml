<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MongoDB 教程</title>
      <link href="/post/18ca68ec.html"/>
      <url>/post/18ca68ec.html</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB-教程"><a href="#MongoDB-教程" class="headerlink" title="MongoDB 教程"></a>MongoDB 教程</h1><p><img src="https://picbed.wuzhentao.com/MongoDBimage/mongodb-logo.png" alt="mongodb-logo"></p><ul><li>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</li><li>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</li></ul><h2 id="MongoDB简介"><a href="#MongoDB简介" class="headerlink" title="MongoDB简介"></a>MongoDB简介</h2><blockquote><p>什么是MongoDB？</p></blockquote><ul><li>MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。</li><li>在高负载的情况下，添加更多的节点，可以保证服务器性能。</li><li>MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。</li><li>MongoDB 将数据存储为一个文档，数据结构由键值(key&#x3D;&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。</li></ul><p><img src="https://picbed.wuzhentao.com/MongoDBimage/crud-annotated-document.png" alt="crud-annotated-document"></p><h1 id="window安装MongoDB"><a href="#window安装MongoDB" class="headerlink" title="window安装MongoDB"></a>window安装MongoDB</h1><p><strong>MongoDB安装包括两部分，一个是将MongoDB的服务下载下来并且安装到自己电脑；</strong></p><p><strong>一个是可视化界面</strong>（<strong>解释：你下了MongoDB服务当然要用起来啊，固然你可以使用命令行的客户端，但是建议你安装MongoDB Compass可视化界面，用起来很方便</strong>）   </p><p> 进入页面 <a href="https://www.mongodb.com/download-center/community">https://www.mongodb.com/download-center/community </a>，我安装这个版本</p><p><img src="https://picbed.wuzhentao.com/MongoDBimage/%E4%B8%8B%E8%BD%BD%E9%80%89%E9%A1%B9.PNG" alt="下载选项"></p><p>下载好后的文件:</p><p><img src="https://img-blog.csdnimg.cn/20200405141118829.png" alt="img"></p><p>  双击开始安装（以下几步注意，其他全部next）：</p><p><img src="https://picbed.wuzhentao.com/MongoDBimage/%E5%AE%89%E8%A3%85.PNG" alt="安装"></p><p> 这里我选择的是自定义安装，选择你想安装到的位置</p><p><img src="https://picbed.wuzhentao.com/MongoDBimage/%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE.PNG" alt="文件位置"></p><p> 点击ok，然后点击next 点击之后 新版的Mongodb会主动在安装目录下创建log和data文件，这相比较早期版本有了改善 ，早期需要自己手动创建 <strong>但我们仍然需要在data下创建db文件夹  笔者的在C:\MongoDB\data\db（记住一定要再建个db文件夹）</strong></p><p><img src="https://picbed.wuzhentao.com/MongoDBimage/%E5%88%9B%E5%BB%BA.PNG" alt="创建"></p><p><strong>重重之重（下图一定要取消安装，compass客户端可视化界面我会另外下载。你要是选中了，那就是安装了一天也完成不了）</strong></p><p><img src="https://picbed.wuzhentao.com/MongoDBimage/%E5%8F%96%E6%B6%88.PNG" alt="取消"></p><p> <strong>最后安装成功会弹出一个警告框，选中 Ignore 就好</strong></p><p><img src="https://picbed.wuzhentao.com/MongoDBimage/%E7%A1%AE%E8%AE%A4.PNG" alt="确认"></p><p><strong>配置环境变量</strong></p><p><img src="https://picbed.wuzhentao.com/MongoDBimage/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.PNG" alt="环境变量"></p><p>至此，MongoDB客户端已经安装完毕</p><p>由于我们已经创建了C:\MongoDB\data\db文件夹  这里就不需要再创建  否者还要创建  然后在cmd进入C:\MongoDB\bin目录下（在windows资源管理器中shift+右键打开powershell也行）然后执行mongod -dbpath C:\MongoDB\data\db 命令  如下图（这条命令是开启服务，它会一直运行，只要你要使用Mongodb，这个窗口就不能关）</p><p><img src="https://picbed.wuzhentao.com/MongoDBimage/%E6%89%A7%E8%A1%8C.PNG" alt="执行"></p><p>已经启动了MongoDB服务</p><p>但是我们需要Mongo.exe这个文件连接到MongoDB数据库,</p><p>可是有的版本安装目录bin下并没有mongo.exe这个文件,需要我们手动下载</p><p><img src="https://picbed.wuzhentao.com/MongoDBimage/%E4%B8%8B%E8%BD%BDshell.PNG" alt="下载shell"></p><p>下载文件是一个压缩包,打开进入bin,把bin目录下的文件解压到本地bin下</p><p><img src="https://picbed.wuzhentao.com/MongoDBimage/%E8%A7%A3%E5%8E%8B.PNG" alt="解压"></p><p>执行mongo.exe,回车</p><p><img src="https://picbed.wuzhentao.com/MongoDBimage/%E7%82%B9%E5%87%BB.PNG" alt="点击"></p><p>自带三个数据库</p><h1 id="python连接MongoDB"><a href="#python连接MongoDB" class="headerlink" title="python连接MongoDB"></a>python连接MongoDB</h1><p><strong>下载python中MongoDB的驱动程序</strong></p><p><code>pip install pymongo</code></p><h2 id="python操作mongodb"><a href="#python操作mongodb" class="headerlink" title="python操作mongodb"></a>python操作mongodb</h2><h3 id="1-连接mongodb"><a href="#1-连接mongodb" class="headerlink" title="1.连接mongodb"></a>1.连接mongodb</h3><p><strong>无需权限认证方式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">&quot;mongodb://localhost:27017&quot;</span>)</span><br><span class="line"><span class="comment"># myclient = pymongo.MongoClient(&#x27;localhost&#x27;,27017)</span></span><br><span class="line"><span class="comment"># host = 自己的ip</span></span><br><span class="line"><span class="comment"># myclient = pymongo.MongoClient(host,27017)</span></span><br><span class="line"><span class="built_in">print</span>(myclient.list_database_names())</span><br><span class="line">输出：</span><br><span class="line">[<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;config&#x27;</span>, <span class="string">&#x27;local&#x27;</span>, <span class="string">&#x27;test&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>权限认证方式</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">27017</span>)</span><br><span class="line">db = mongo_client.admin</span><br><span class="line">db.authenticate(<span class="string">&#x27;用户名&#x27;</span>, <span class="string">&#x27;密码&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-指定数据库和集合"><a href="#2-指定数据库和集合" class="headerlink" title="2.指定数据库和集合"></a><strong>2.指定数据库和集合</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">获取数据库</span><br><span class="line">方法一：db = client.test</span><br><span class="line">方法二：db = client[<span class="string">&#x27;test&#x27;</span>]</span><br><span class="line">指定集合</span><br><span class="line">方法一：collection = db.stu</span><br><span class="line">方法二：collection = db[<span class="string">&#x27;stu&#x27;</span>]</span><br></pre></td></tr></table></figure><h3 id="3-插入数据"><a href="#3-插入数据" class="headerlink" title="3.插入数据"></a><strong>3.插入数据</strong></h3><p>可以使用insert方法插入数据，但在pymongo中，官方推荐使用 <code>insert_one</code> 完成单个数据的写入，<code>insert_many</code> 完成多条数据的插入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#增加一条</span></span><br><span class="line">stu1=&#123;<span class="string">&#x27;id&#x27;</span>:<span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">10</span>&#125;</span><br><span class="line">result = collection.insert_one(stu1)</span><br><span class="line"><span class="comment">#增加多条</span></span><br><span class="line">stu2=&#123;<span class="string">&#x27;id&#x27;</span>:<span class="string">&#x27;002&#x27;</span>,<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;lisi&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">15</span>&#125;</span><br><span class="line">stu3=&#123;<span class="string">&#x27;id&#x27;</span>:<span class="string">&#x27;003&#x27;</span>,<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;wangwu&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">20</span>&#125;</span><br><span class="line">result = collection.insert_many([stu2,stu3])</span><br></pre></td></tr></table></figure><h3 id="4-删除数据"><a href="#4-删除数据" class="headerlink" title="4.删除数据"></a><strong>4.删除数据</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可以直接使用remove方法删除指定的数据</span></span><br><span class="line">result = collection.remove(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;zhangsan&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">#使用delete_one()删除一条数据</span></span><br><span class="line">result = collection.delete_one(&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;zhangsan&quot;</span>&#125;)</span><br><span class="line"><span class="comment">#delete_many()删除多条数据</span></span><br><span class="line">result = collection.delete_many(&#123;<span class="string">&quot;age&quot;</span>:&#123;<span class="string">&#x27;$lt&#x27;</span>:<span class="number">20</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><h3 id="5-修改数据"><a href="#5-修改数据" class="headerlink" title="5.修改数据"></a><strong>5.修改数据</strong></h3><p>可以使用update方法修改数据，但在pymongo中，官方推荐使用 <code>update_one</code> 完成单个数据的修改，<code>update_many</code> 完成多条数据的修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#update_one,第 2 个参数需要使用$类型操作符作为字典的键名</span></span><br><span class="line"><span class="comment">#姓名为zhangsan的记录，age修改为22</span></span><br><span class="line">condition = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;zhangsan&#x27;</span>&#125;</span><br><span class="line">res = collection.find_one(condition)</span><br><span class="line">res[<span class="string">&#x27;age&#x27;</span>] = <span class="number">22</span></span><br><span class="line">result = collection.update_one(condition, &#123;<span class="string">&#x27;$set&#x27;</span>: res&#125;)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment">#返回结果是UpdateResult类型</span></span><br><span class="line"><span class="built_in">print</span>(result.matched_count,result.modified_count) <span class="comment">#获得匹配的数据条数1、影响的数据条数1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#update_many,所有年龄为15的name修改为xixi</span></span><br><span class="line">condition = &#123;<span class="string">&#x27;age&#x27;</span>: <span class="number">15</span>&#125;</span><br><span class="line">res = collection.find_one(condition)</span><br><span class="line">res[<span class="string">&#x27;age&#x27;</span>] = <span class="number">30</span></span><br><span class="line">result = collection.update_many(condition, &#123;<span class="string">&#x27;$set&#x27;</span>:&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;xixi&#x27;</span>&#125;&#125;)</span><br><span class="line"><span class="built_in">print</span>(result) <span class="comment">#返回结果是UpdateResult类型</span></span><br><span class="line"><span class="built_in">print</span>(result.matched_count,result.modified_count) <span class="comment">#获得匹配的数据条数3、影响的数据条数3</span></span><br></pre></td></tr></table></figure><h3 id="6-查询数据"><a href="#6-查询数据" class="headerlink" title="6.查询数据"></a><strong>6.查询数据</strong></h3><p><strong>find()查找全部数据</strong></p><p>返回所有满足条件的结果，如果条件为空，则返回全部结果，返回结果是一个Cursor游标可迭代对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rets = collection.find(&#123;<span class="string">&quot;age&quot;</span>:<span class="number">20</span>&#125;)，</span><br><span class="line"><span class="keyword">for</span> ret <span class="keyword">in</span> rets:</span><br><span class="line">    <span class="built_in">print</span>(ret)</span><br><span class="line"> <span class="comment"># 查询结果有多少条数据</span></span><br><span class="line"> count = collection.find().count()</span><br><span class="line"> <span class="comment"># 查询结果按年龄升序排序</span></span><br><span class="line">results = collection.find().sort(<span class="string">&#x27;age&#x27;</span>, pymongo.ASCENDING)</span><br><span class="line"><span class="built_in">print</span>([result[<span class="string">&#x27;age&#x27;</span>] <span class="keyword">for</span> result <span class="keyword">in</span> results])</span><br></pre></td></tr></table></figure><blockquote><p>1.游标是什么？   </p><p>用来存储多条查询数据的一种数据结构（’结果集’），   它有一个 ‘指针’，从上往下移动（’fetch’），从而能够 ‘遍历每条记录’    </p><p>2.优缺点  </p><p>(1) 提高 sql ‘执行效率’   </p><p>(2) 牺牲 ‘内存’</p></blockquote><p><strong>find_one()查找一条数据</strong></p><p>接收一个字典形式的条件，返回字典形式的整条数据，如果条件为空，则返回第一条。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret =collection.find_one(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;zhangsan&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度分析Jieba</title>
      <link href="/post/6b2110a3.html"/>
      <url>/post/6b2110a3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Jieba"><a href="#Jieba" class="headerlink" title="Jieba"></a>Jieba</h1><p><code>jieba</code>库是一款优秀的 Python 第三方中文分词库</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>支持三种分词模式：<ul><li>精确模式：试图将语句最精确的切分，不存在冗余数据，适合做文本分析</li><li>全模式：将语句中所有可能是词的词语都切分出来，速度很快，但是存在冗余数据</li><li>搜索引擎模式：在精确模式的基础上，对长词再次进行切分</li></ul></li><li>支持繁体分词</li><li>支持自定义词典</li><li>MIT 授权协议</li></ul><h2 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h2><p>代码对 Python 2&#x2F;3 均兼容</p><ul><li>全自动安装：<code>easy_install jieba</code> 或者 <code>pip install jieba</code> &#x2F; <code>pip3 install jieba</code></li><li>半自动安装：先下载 <a href="http://pypi.python.org/pypi/jieba/">http://pypi.python.org/pypi/jieba/</a> ，解压后运行 <code>python setup.py install</code></li><li>手动安装：将 jieba 目录放置于当前目录或者 site-packages 目录</li><li>通过 <code>import jieba</code> 来引用</li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul><li>基于前缀词典实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图 (DAG)</li><li>采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合</li><li>对于未登录词，采用了基于汉字成词能力的 HMM 模型，使用了 Viterbi 算法</li></ul><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul><li><strong><code>jieba.cut</code></strong> 方法接受三个输入参数: 需要分词的字符串；cut_all 参数用来控制是否采用全模式；HMM 参数用来控制是否使用 HMM 模型</li><li>待分词的字符串可以是 unicode 或 UTF-8 字符串、GBK 字符串。注意：不建议直接输入 GBK 字符串，可能无法预料地错误解码成 UTF-8</li><li><strong><code>jieba.lcut</code></strong> 以及 <strong><code>jieba.lcut_for_search</code></strong> 直接返回 list</li></ul><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">seg_str = <span class="string">&quot;义乌哥们名叫丁真&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;/&quot;</span>.join(jieba.lcut(seg_str, cut_all = <span class="literal">False</span>)))    <span class="comment"># 精简模式，返回一个列表类型的结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;/&quot;</span>.join(jieba.lcut(seg_str))) <span class="comment"># 默认是精确模式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;/&quot;</span>.join(jieba.lcut(seg_str, cut_all=<span class="literal">True</span>)))      <span class="comment"># 全模式，使用 &#x27;cut_all=True&#x27; 指定 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;/&quot;</span>.join(jieba.lcut_for_search(seg_str)))     <span class="comment"># 搜索引擎模式</span></span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[全模式]: 义乌/哥们/名叫/丁/真</span><br><span class="line"> </span><br><span class="line">[精确模式]: 义乌/哥们/名叫/丁真</span><br><span class="line"> </span><br><span class="line">[搜索引擎模式]： 义乌/哥们/名叫/丁真</span><br><span class="line"></span><br><span class="line">[新词识别]：义乌/哥们/名叫/丁真    (此处，“丁真”并没有在词典中，但是也被Viterbi算法识别出来了)</span><br></pre></td></tr></table></figure><ul><li><strong><code>jieba.cut_for_search</code></strong> 方法接受两个参数：需要分词的字符串；是否使用 HMM 模型。该方法适合用于搜索引擎构建倒排索引的分词，粒度比较细</li></ul><p>参数解释:</p><p><strong>「strs」</strong>： 需要分词的字符串；<br><strong>「HMM」</strong>：用来控制是否使用 HMM 模型；</p><ul><li><strong><code>jieba.cut</code></strong> 以及 <strong><code>jieba.cut_for_search</code></strong> 返回的结构都是一个可迭代的 generator，可以使用 for 循环来获得分词后得到的每一个词语(unicode)，或者用</li><li><code>cut</code>和<code>cut_for_search</code>方法都是支持繁体字的。</li></ul><h2 id="载入字典"><a href="#载入字典" class="headerlink" title="载入字典"></a>载入字典</h2><p>如果是对专业新闻或者小说进行分词，会有很多的新词汇，jieba库里没有就没办法识别，那么就需要添加自定义的词汇，比如：丁真。</p><p>添加自定义词汇的方法： <code>jieba.load_userdict(file_name)</code> 参数是文本文件，txt、csv都可以。</p><p>自定义词典文件的词汇格式是一个词占一行，每一行分三部分：词语、词频（可省略）、词性（可省略），用空格隔开，顺序不可颠倒。 比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">理塘王 2</span><br><span class="line">丁丁丁丁真 2 i</span><br><span class="line">义乌</span><br></pre></td></tr></table></figure><p>以”义乌,哥们丁丁丁丁真理塘王” 这段话为例， 如果不添加自定义词典，很多词没办法识别出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seg_list = jieba.cut(<span class="string">&quot;义乌,哥们丁丁丁丁真理塘王&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;/ &quot;</span>.join(seg_list))  </span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">义乌/ ,/ 哥们/ 丁丁/ 丁丁/ 真/ 理塘王</span><br></pre></td></tr></table></figure><p>添加自定义词典后，新词、人名、电影名都可以识别出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 载入词典</span></span><br><span class="line">jieba.load_userdict(<span class="string">&quot;dict.txt&quot;</span>)</span><br><span class="line">seg_list = jieba.cut(<span class="string">&quot;义乌,哥们丁丁丁丁真理塘王&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;/ &quot;</span>.join(seg_list))  </span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">义乌/ ,/ 哥们/ 丁丁丁丁真/ 理塘王</span><br></pre></td></tr></table></figure><p>注意:</p><p>如果<code>jieba</code>自己的分词词典<code>dict.txt</code>和自己的定义的字典冲突,会优先用<code>jieba</code>自己的分词词典</p><ul><li>开发者可以指定自己自定义的词典，以便包含 jieba 词库里没有的词。虽然 jieba 有新词识别能力，但是自行添加新词可以保证更高的正确率</li><li>用法： jieba.load_userdict(file_name) # file_name 为文件类对象或自定义词典的路径</li><li>词典格式和 <strong><code>dict.txt</code></strong> 一样，一个词占一行；每一行分三部分：词语、词频（可省略）、词性（可省略），用空格隔开，顺序不可颠倒。**<code>file_name</code>** 若为路径或二进制方式打开的文件，则文件必须为<code> UTF-8 编码!!!!</code>。</li><li>词频省略时使用自动计算的能保证分出该词的词频。</li></ul><h2 id="调整词典"><a href="#调整词典" class="headerlink" title="调整词典"></a><strong>调整词典</strong></h2><ul><li>使用 <strong><code>add_word(word, freq=None, tag=None)</code></strong> 和 <strong><code>del_word(word)</code></strong> 可在程序中动态修改词典。</li><li>使用 <strong><code>suggest_freq(segment, tune=True)</code></strong> 可调节单个词语的词频，使其能（或不能）被分出来。</li><li>注意：自动计算的词频在使用 HMM 新词发现功能时可能无效。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">print</span>(<span class="string">&#x27;/&#x27;</span>.join(jieba.cut(<span class="string">&#x27;如果放到post中将出错。&#x27;</span>, HMM=<span class="literal">False</span>)))</span><br><span class="line">如果/放到/post/中将/出错/。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jieba.suggest_freq((<span class="string">&#x27;中&#x27;</span>, <span class="string">&#x27;将&#x27;</span>), <span class="literal">True</span>)</span><br><span class="line"><span class="number">494</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;/&#x27;</span>.join(jieba.cut(<span class="string">&#x27;如果放到post中将出错。&#x27;</span>, HMM=<span class="literal">False</span>)))</span><br><span class="line">如果/放到/post/中/将/出错/。</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;/&#x27;</span>.join(jieba.cut(<span class="string">&#x27;「台中」正确应该不会被切开&#x27;</span>, HMM=<span class="literal">False</span>)))</span><br><span class="line">「/台/中/」/正确/应该/不会/被/切开</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jieba.suggest_freq(<span class="string">&#x27;台中&#x27;</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="number">69</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;/&#x27;</span>.join(jieba.cut(<span class="string">&#x27;「台中」正确应该不会被切开&#x27;</span>, HMM=<span class="literal">False</span>)))</span><br><span class="line">「/台中/」/正确/应该/不会/被/切开</span><br></pre></td></tr></table></figure><h2 id="jieba实现基于tf-idf算法的关键词提取"><a href="#jieba实现基于tf-idf算法的关键词提取" class="headerlink" title="jieba实现基于tf-idf算法的关键词提取"></a>jieba实现基于tf-idf算法的关键词提取</h2><h3 id="TF-IDF算法介绍"><a href="#TF-IDF算法介绍" class="headerlink" title="TF-IDF算法介绍"></a>TF-IDF算法介绍</h3><p>一篇文章的关键词基本都是能体现文章的内容，而且几乎是在文章中频繁出现的词，统计文章中各个词出现的次数，出现最多的则是这篇文章的关键词了，</p><p>那具体是怎么统计呢，这里有一个专业术语叫词频（term frequency），简称TF。计算公式如下：</p><p><strong>TF（词频） &#x3D; 某次在文章中出现的次数 &#x2F; 文章\中的总词数</strong></p><p><img src="https://picbed.wuzhentao.com/%E5%85%AC%E5%BC%8F/formula1.png" alt="image-20230315195735881"></p><p>举例子：我正在学习人工智能，并且我一定会成功的。<br><strong>通过jieba分词得到分词：</strong>我&#x2F; 正在&#x2F; 学习&#x2F; 人工智能&#x2F; 并且&#x2F; 我&#x2F; 一定&#x2F; 会&#x2F; 成功&#x2F; 的&#x2F;<br>分词之后这句话总共出现9个分词我 2 正在 1 学习 1 人工智能 1 并且 1 一定 1 会 1 成功 1 的 1<br>我们计算 “人工智能”出现的词频 0.11 &#x3D; 1&#x2F;9</p><p>但实际上我们肉眼就能判断出有一类词出现的很频繁,</p><p>比如“的”、“了”、“在”，显然这类词根本体现不出文章的重要性，肯定不是文章的关键词，这类词有一个专业名词叫停用词（stop words），一般在处理中会将这类词过滤掉。</p><p>还有一类词比如阮一峰大神举例中的“中国的蜜蜂养殖”，我们一眼就能看出，蜜蜂、养殖这类词虽然很少，但才是这篇文章的关键词，而“中国”，在各个文章集中经常能见到。“蜜蜂”、“养殖”的权值应该要比“中国”高才对，</p><p>分词出现的权重叫做”逆文档频率”（Inverse Document Frequency，缩写为IDF），因此比较经常见到的分词应该给与较低的权限，相反比较不常见的分词则应该给与较高的权重。IDF计算方式是这样的：</p><p><strong>IDF &#x3D; log(语料库出现的文章总数 &#x2F; 包含该词的文章总数+1)，计算IDF的公式并不是唯一的也有其他公式。</strong></p><p><img src="https://picbed.wuzhentao.com/%E5%85%AC%E5%BC%8F/formula2.png" alt="hongxia.webp (942×942) (wuzhentao.com)"></p><p><strong>因此 TF-IDF &#x3D; TF * IDF。值越大表示该词在文章中越重要</strong></p><h2 id="通过jieba-的python库提取关键词"><a href="#通过jieba-的python库提取关键词" class="headerlink" title="通过jieba 的python库提取关键词"></a>通过jieba 的python库提取关键词</h2><p>jieba 的python插件已经将TF-IDF算法封装好了，因为我们直接引用就可以直接使用。<br>基于 TF-IDF 算法的关键词抽取方法：</p><p><code>import jieba.analyse</code></p><p><code>jieba.analyse.extract_tags(sentence, topK=20, withWeight=False, allowPOS=())</code><br><code>sentence</code> 为待提取的文本<br><code>topK </code>为返回几个 TF&#x2F;IDF 权重最大的关键词，默认值为 20<br><code>withWeight </code>为是否一并返回关键词权重值，默认值为 False<br><code>allowPOS </code>仅包括指定词性的词，默认值为空，即不筛选</p><p>词性对应字符如下表所示：</p><table><thead><tr><th>标签</th><th>含义</th><th>标签</th><th>含义</th></tr></thead><tbody><tr><td>n</td><td>普通名词</td><td>f</td><td>方位名词</td></tr><tr><td>nr</td><td>人名</td><td>ns</td><td>地名</td></tr><tr><td>nz</td><td>其他专名</td><td>v</td><td>普通动词</td></tr><tr><td>a</td><td>形容词</td><td>ad</td><td>副形词</td></tr><tr><td>m</td><td>数量词</td><td>q</td><td>量词</td></tr><tr><td>c</td><td>连词</td><td>u</td><td>助词</td></tr><tr><td>REP</td><td>人名</td><td>LOC</td><td>地名</td></tr><tr><td>s</td><td>处所名词</td><td>t</td><td>时间</td></tr><tr><td>nt&#x2F;ORG</td><td>机构名</td><td>nw</td><td>作品名</td></tr><tr><td>r</td><td>代词</td><td>p</td><td>借此</td></tr><tr><td>TIME&#x2F;t</td><td>时间</td><td>w</td><td>标点符号</td></tr></tbody></table><p>基于tfidf算法的关键词提取代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> jieba.analyse</span><br><span class="line">sentence = <span class="string">&#x27;中华蜜蜂原产于中国，是中国的土著蜂，适应中国各地的气候和蜜源条件，适于定地饲养且稳产，尤其是在南方山区，有着其他蜂种不可替代的地位&#x27;</span></span><br><span class="line"></span><br><span class="line">seg_list = jieba.cut(sentence, cut_all=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;, &quot;</span>.join(seg_list))</span><br><span class="line">keywords = jieba.analyse.extract_tags(sentence, topK=<span class="number">20</span>, withWeight=<span class="literal">True</span>, allowPOS=(<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;nr&#x27;</span>,<span class="string">&#x27;ns&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(keywords)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python基础部分和numpy简单应用</title>
      <link href="/post/cf078df3.html"/>
      <url>/post/cf078df3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python基础部分"><a href="#Python基础部分" class="headerlink" title="Python基础部分"></a>Python基础部分</h1><p>我们首先巩固一下Python的基础知识。Python有6种标准数据类型：Number（数字）,String（字符串）,List（列表）,Tuple（元组）,Set（集合）,Dictionary（字典）。<br>其中：<br>不可变数据：Number（数字）、String（字符串）、Tuple（元组）。<br>可变数据：List（列表）、Dictionary（字典）、Set（集合）。</p><p><strong>1. List[列表]</strong></p><ul><li>列表由方括号<code>[]</code>包裹,每个位置的数值可变</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><ul><li>根据位置取值，如取第2个位置的值：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>[<span class="number">1</span>]</span><br><span class="line">out: <span class="number">2</span></span><br><span class="line">a[<span class="number">2</span>: ]</span><br><span class="line">out: [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><ul><li>改变指定位置的值：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list[0] = 9</span><br></pre></td></tr></table></figure><ul><li>列表a此时输出为 <code>[9, 2, 3, 4, 5, 6]</code>。</li></ul><p><strong>2.  Tuple(元组)</strong></p><ul><li>元组由圆括号 <code>( )</code> 包裹，每个位置的数值<strong>不可变</strong>。允许数据<strong>重复</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span> = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;a, &#x27;</span>c<span class="string">&#x27;, 1, 2, 3.0)</span></span><br></pre></td></tr></table></figure><p>输出<code>(&#39;a&#39;, &#39;a&#39;, &#39;c&#39;, 1, 2, 3.0)</code>。</p><ul><li>取最后一个位置的元素：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tuple</span>[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>输出 <code>3.0</code>。</p><p>元组操作与列表类似，但不可改变元组内元素的值，否则会报错。</p><p><strong>3. Set{集合}</strong></p><ul><li>集合是包含<strong>不重复</strong>元素的集体，由花括号 <code>&#123; &#125;</code> 包裹。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set1 = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;</span><br><span class="line">set2 = &#123;<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>set1的输出结果为：<code>&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;&#125;</code>。<strong>注意：集合会删除重复元素。</strong><br>set2的输出结果为：<code>&#123;&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;&#125;</code>。</p><ul><li>与列表和元组不同，集合是不可下标的，如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set1[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>会报错</p><ul><li>集合运算:</li></ul><p>set1和set2的<strong>差集</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set1 - set2</span><br><span class="line"><span class="comment">#set1.difference(set2) </span></span><br></pre></td></tr></table></figure><p>输出：<code>&#123;&#39;a&#39;&#125;</code>。</p><ul><li>set1和set2的<strong>并集</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set1 | set2</span><br><span class="line"><span class="comment">#set1.union(set2) </span></span><br></pre></td></tr></table></figure><p>输出：<code>&#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;&#125;</code>。</p><ul><li>set1和set2的<strong>交集</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set1 &amp; set2</span><br><span class="line"><span class="comment">#set1.intersection(set2) </span></span><br></pre></td></tr></table></figure><p>输出：<code>&#123;&#39;b&#39;, &#39;c&#39;&#125;</code>。</p><ul><li>set1和set2的<strong>对称差集</strong>：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set1 ^ set2 </span><br><span class="line"><span class="comment">#(set1 - set2) | (set2 - set1)</span></span><br><span class="line"><span class="comment">#set1.symmetric_difference(set2)</span></span><br></pre></td></tr></table></figure><p>输出：<code>&#123;&#39;a&#39;, &#39;d&#39;, &#39;e&#39;&#125;</code>。</p><p><strong>4. Dictionary{字典:Dictionary}</strong></p><ul><li>字典是一种映射关系，是无序有键值对（key-value）集合。字典不允许重复的键(key)，但允许重复的值(value)。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = &#123;<span class="string">&#x27;wangzhan&#x27;</span>:<span class="string">&#x27;wuwenjian&#x27;</span>,<span class="string">&#x27;website&#x27;</span>:<span class="string">&#x27;wuzhentao.com&#x27;</span>, <span class="string">&#x27;website&#x27;</span>:<span class="string">&#x27;blog.wuzhentao.com&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>字典输出<code>&#123;&#39;wangzhan&#39;: &#39;wuwenjian&#39;, &#39;website&#39;: &#39;blog.wuzhentao.com&#39;&#125;</code>，需要注意的是，当字典包含重复键，后面的会覆盖前面的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;wangzhan&#x27;</span>]</span><br></pre></td></tr></table></figure><ul><li>输出字符串 <code>wuwenjian</code>。我们也可以使用<code>get</code>方法得到相同效果。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span>.get(<span class="string">&#x27;wangzhan&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>查看所有的键(key):</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span>.keys()</span><br></pre></td></tr></table></figure><p>输出 <code>dict_keys([&#39;wangzhan&#39;, &#39;website&#39;])</code>。</p><ul><li>查看所有的值(value):</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span>.values()</span><br></pre></td></tr></table></figure><p>输出 <code>dict_values([&#39;wuwenjian&#39;, &#39;blog.wuzhentao.com&#39;])</code>。</p><ul><li>改变某一项的值：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;website&#x27;</span>] = <span class="string">&#x27;wuzhentao.com&#x27;</span></span><br><span class="line"><span class="built_in">dict</span></span><br></pre></td></tr></table></figure><p>输出 <code>&#123;&#39;wangzhan&#39;: &#39;wuwenjian&#39;, &#39;website&#39;: &#39;wuzhentao.com&#39;&#125;</code>。</p><blockquote><p>了解了Python的数据类型，我们可以学着使用NumPy了。</p></blockquote><h1 id="Numpy常见用法"><a href="#Numpy常见用法" class="headerlink" title="Numpy常见用法"></a>Numpy常见用法</h1><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure><p>arr的输出为<code>array([1, 2, 3, 4, 5])</code>。</p><ul><li>我们输入以下代码创建二维数组：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">mtrx= np.array(my_matrix)</span><br></pre></td></tr></table></figure><p>mtrx的输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 2, 3],</span><br><span class="line">       [4, 5, 6],</span><br><span class="line">       [7, 8, 9]])</span><br></pre></td></tr></table></figure><h2 id="切片与索引"><a href="#切片与索引" class="headerlink" title="切片与索引"></a>切片与索引</h2><ul><li>索引一维数组与二位数组如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;arr[0]=&#x27;</span>,arr[<span class="number">0</span>],<span class="string">&#x27;mtrx[1,1]=&#x27;</span>,mtrx[<span class="number">1</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>输出 <code>arr[0]= 1 mtrx[1,1]= 5</code>。</p><ul><li>对数组切片：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>输出结果为 <code>array([1, 2, 3])</code>。</p><ul><li>倒数切片：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[-<span class="number">3</span>:-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>输出 <code>array([3, 4])</code>。</p><ul><li>加入步长(step)，步长决定了切片间隔：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>输出 <code>array([2, 4])</code>。</p><ul><li>二维数组切片：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtrx[<span class="number">0</span>:<span class="number">2</span>, <span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>输出，代码意义为取第1、2行，第1、2列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 2],</span><br><span class="line">       [4, 5]])</span><br></pre></td></tr></table></figure><h2 id="dtype"><a href="#dtype" class="headerlink" title="dtype"></a>dtype</h2><p>NumPy的dtpe有如下几种数据类型：</p><ul><li>i - integer</li><li>b - boolean</li><li>u - unsigned integer</li><li>f - float</li><li>c - complex float</li><li>m - timedelta</li><li>M - datetime</li><li>O - object</li><li>S - string</li><li>U - unicode string</li><li>V - fixed chunk of memory for other type ( void )</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">arr1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">arr2 = np.array([<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;arr1.dtype=&#x27;</span>,arr1.dtype,<span class="string">&#x27;arr2.dtype=&#x27;</span>,arr2.dtype)</span><br></pre></td></tr></table></figure><p>输出为 <code>arr1.dtype= int32 arr2.dtype= &lt;U6</code>。arr1数据类型为int32，arr2的&lt;U6表示不超过6位Unicode字符串。</p><ul><li>我们可以指定dtype类型。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>], dtype=<span class="string">&#x27;f&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果位 <code>array([1., 2., 3.], dtype=float32)</code>，其中1.表示1.0，可以看到dtype被设置位float32数据类型。</p><h2 id="一般方法"><a href="#一般方法" class="headerlink" title="一般方法"></a>一般方法</h2><h3 id="4-1-arange"><a href="#4-1-arange" class="headerlink" title="4.1 arange"></a>4.1 arange</h3><p><code>np.arange(0,101,2)</code>输出结果如下，该命令表示，在[0,101)区间内均匀地生成数据，间隔步长为2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([  0,   2,   4,   6,   8,  10,  12,  14,  16,  18,  20,  22,  24,</span><br><span class="line">        26,  28,  30,  32,  34,  36,  38,  40,  42,  44,  46,  48,  50,</span><br><span class="line">        52,  54,  56,  58,  60,  62,  64,  66,  68,  70,  72,  74,  76,</span><br><span class="line">        78,  80,  82,  84,  86,  88,  90,  92,  94,  96,  98, 100])</span><br></pre></td></tr></table></figure><h3 id="4-2-zeros"><a href="#4-2-zeros" class="headerlink" title="4.2 zeros"></a>4.2 zeros</h3><p><code>np.zeros((2,5))</code>输出结果如下，该命令表示，输出2行5列全为0的矩阵（二维数组）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[0., 0., 0., 0., 0.],</span><br><span class="line">       [0., 0., 0., 0., 0.]])</span><br></pre></td></tr></table></figure><h3 id="4-3-ones"><a href="#4-3-ones" class="headerlink" title="4.3 ones"></a>4.3 ones</h3><p><code>np.ones((4,4))</code>输出结果如下，该命令表示，输出4行4列全为1的矩阵。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([[1., 1., 1., 1.],</span><br><span class="line">       [1., 1., 1., 1.],</span><br><span class="line">       [1., 1., 1., 1.],</span><br><span class="line">       [1., 1., 1., 1.]])</span><br></pre></td></tr></table></figure><h3 id="4-4-eye"><a href="#4-4-eye" class="headerlink" title="4.4 eye"></a>4.4 eye</h3><p><code>np.eye(5)</code>输出结果如下，该命令表示，输出对角线为1其余全为0的5行5列方阵。<em>方阵为行列相同的矩阵。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[1., 0., 0., 0., 0.],</span><br><span class="line">       [0., 1., 0., 0., 0.],</span><br><span class="line">       [0., 0., 1., 0., 0.],</span><br><span class="line">       [0., 0., 0., 1., 0.],</span><br><span class="line">       [0., 0., 0., 0., 1.]])</span><br></pre></td></tr></table></figure><h3 id="4-5-rand"><a href="#4-5-rand" class="headerlink" title="4.5 rand"></a>4.5 rand</h3><p><code>np.random.rand(5,2)</code> 命令生成5行2列的随机数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[0.67227856, 0.4880784 ],</span><br><span class="line">       [0.82549517, 0.03144639],</span><br><span class="line">       [0.80804996, 0.56561742],</span><br><span class="line">       [0.2976225 , 0.04669572],</span><br><span class="line">       [0.9906274 , 0.00682573]])</span><br></pre></td></tr></table></figure><p>如果想保证随机出与本例一样的随机数，可使用与本例相同的随机种子。通过<code>np.random.seed</code>方法设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">99</span>)</span><br><span class="line">np.random.rand(<span class="number">5</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="4-6-randint"><a href="#4-6-randint" class="headerlink" title="4.6 randint"></a>4.6 randint</h3><p><code>np.random.randint(0,101,(4,5))</code>输出结果如下，该命令表示，在[0,101)区间内随机选取<strong>整数</strong>生成4行5列的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([[ 1, 35, 57, 40, 73],</span><br><span class="line">       [82, 68, 69, 52,  1],</span><br><span class="line">       [23, 35, 55, 65, 48],</span><br><span class="line">       [93, 59, 87,  2, 64]])</span><br></pre></td></tr></table></figure><h3 id="4-7-max-min-argmax-argmin"><a href="#4-7-max-min-argmax-argmin" class="headerlink" title="4.7 max min argmax argmin"></a>4.7 max min argmax argmin</h3><p>我们先随机生成一组数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">99</span>)</span><br><span class="line">ranarr = np.random.randint(<span class="number">0</span>,<span class="number">101</span>,<span class="number">10</span>)</span><br><span class="line">ranarr</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([ 1, 35, 57, 40, 73, 82, 68, 69, 52,  1])</span><br></pre></td></tr></table></figure><p>查看最大最小值分别为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ranarr.max()=&#x27;</span>,ranarr.<span class="built_in">max</span>(),<span class="string">&#x27;ranarr.min()=&#x27;</span>,ranarr.<span class="built_in">min</span>())</span><br></pre></td></tr></table></figure><p>输出结果为<code>ranarr.max()= 82 ranarr.min()= 1</code>。<br>其中最大值和最小值的索引位置分别为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ranarr.argmax()=&#x27;</span>,ranarr.argmax(),<span class="string">&#x27;ranarr.argmin()=&#x27;</span>,ranarr.argmin())</span><br></pre></td></tr></table></figure><p>输出：<code>ranarr.argmax()= 5 ranarr.argmin()= 0</code>。注意，当出现多个最大最小值时，取前面的索引位置。</p><h1 id="Numpy进阶用法"><a href="#Numpy进阶用法" class="headerlink" title="Numpy进阶用法"></a>Numpy进阶用法</h1><h2 id="1-reshape"><a href="#1-reshape" class="headerlink" title="1. reshape"></a>1. reshape</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line">newarr = arr.reshape(<span class="number">4</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>其中，arr为一维数组，newarr为二位数组，其中行为4，列为3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;arr.shape=&#x27;</span>,arr.shape,<span class="string">&#x27;newarr.shape=&#x27;</span>,newarr.shape)</span><br></pre></td></tr></table></figure><p>输出 <code>arr.shape= (12,) newarr.shape= (4, 3)</code>。</p><p><code>newarr</code>的输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([[ 1,  2,  3],</span><br><span class="line">       [ 4,  5,  6],</span><br><span class="line">       [ 7,  8,  9],</span><br><span class="line">       [10, 11, 12]])</span><br></pre></td></tr></table></figure><h2 id="2-合并与分割"><a href="#2-合并与分割" class="headerlink" title="2. 合并与分割"></a>2. 合并与分割</h2><h3 id="2-1-concatenate"><a href="#2-1-concatenate" class="headerlink" title="2.1 concatenate"></a>2.1 concatenate</h3><p>一维数组合并：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">arr2 = np.array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">arr = np.concatenate((arr1, arr2))</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><p>输出： <code>array([1, 2, 3, 4, 5, 6])</code>。</p><p>二维数组合并：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">arr2 = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line">arr = np.concatenate((arr1, arr2))</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 2],</span><br><span class="line">       [3, 4],</span><br><span class="line">       [5, 6],</span><br><span class="line">       [7, 8]])</span><br></pre></td></tr></table></figure><p>我们添加参数<strong>axis&#x3D;1</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line">arr2 = np.array([[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line">arr = np.concatenate((arr1, arr2), axis=<span class="number">1</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[1, 2, 5, 6],</span><br><span class="line">       [3, 4, 7, 8]])</span><br></pre></td></tr></table></figure><p><code>concatenate</code>方法沿着现有的轴进行合并操作，默认axis&#x3D;0。当我们设置axis&#x3D;1后，合并操作沿着列进行。</p><h3 id="2-2-array-split"><a href="#2-2-array-split" class="headerlink" title="2.2 array_split"></a>2.2 array_split</h3><p>分割数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>], [<span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">newarr = np.array_split(arr, <span class="number">3</span>)</span><br><span class="line">newarr</span><br></pre></td></tr></table></figure><p>newarr的值为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[array([[1, 2],</span><br><span class="line">        [3, 4]]),</span><br><span class="line"> array([[5, 6],</span><br><span class="line">        [7, 8]]),</span><br><span class="line"> array([[ 9, 10],</span><br><span class="line">        [11, 12]])]</span><br></pre></td></tr></table></figure><h2 id="3-搜索与筛选"><a href="#3-搜索与筛选" class="headerlink" title="3. 搜索与筛选"></a>3. 搜索与筛选</h2><h3 id="3-1-搜索"><a href="#3-1-搜索" class="headerlink" title="3.1 搜索"></a>3.1 搜索</h3><p>NumPy可通过<code>where</code>方法查找满足条件的数组索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">x = np.where(arr%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(array([1, 3, 5, 7], dtype=int64),)</span><br></pre></td></tr></table></figure><h3 id="3-2-筛选"><a href="#3-2-筛选" class="headerlink" title="3.2 筛选"></a>3.2 筛选</h3><p>我们看看下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool_arr = arr &gt; <span class="number">4</span></span><br><span class="line">arr[bool_arr]</span><br></pre></td></tr></table></figure><p>输出：<code>array([5, 6, 7, 8])</code>。这回我们返回的是数组中的值，而非索引。<br>我们看看<code>bool_arr</code>的内容究竟是什么。<br><code>bool_arr</code>的输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array([False, False, False, False,  True,  True,  True,  True])</span><br></pre></td></tr></table></figure><p>所以我们可以用以下命令代替以上筛选。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr[arr &gt; <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h2 id="4-排序"><a href="#4-排序" class="headerlink" title="4. 排序"></a>4. 排序</h2><p><code>sort</code>方法可对ndarry数组进行排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>])</span><br><span class="line">np.sort(arr)</span><br></pre></td></tr></table></figure><p>输出排序后的结果：<code>array([&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;], dtype=&#39;&lt;U6&#39;)</code>。</p><p>针对二维数组，<code>sort</code>方法对每一行单独排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([[<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line">np.sort(arr)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[2, 3, 4],</span><br><span class="line">       [0, 1, 5]])</span><br></pre></td></tr></table></figure><h2 id="5-随机"><a href="#5-随机" class="headerlink" title="5. 随机"></a>5. 随机</h2><h3 id="5-1-随机概率"><a href="#5-1-随机概率" class="headerlink" title="5.1 随机概率"></a>5.1 随机概率</h3><p>如果我们想完成如下需求该如何处理？</p><blockquote><p>生成包含100个值的一维数组，其中每个值必须为3、5、7或9。<br>将该值为3的概率设置为0.1。<br>将该值为5的概率设置为0.3。<br>将该值为7的概率设置为0.6。<br>将该值为9的概率设置为0。</p></blockquote><p>我们用如下命令解决：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.random.choice([<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], p=[<span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0.6</span>, <span class="number">0.0</span>], size=(<span class="number">100</span>))</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([7, 5, 7, 7, 7, 7, 5, 7, 5, 7, 7, 5, 5, 7, 7, 5, 3, 5, 7, 7, 7, 7,</span><br><span class="line">       7, 7, 7, 7, 7, 7, 5, 3, 7, 5, 7, 5, 7, 3, 7, 7, 3, 7, 7, 7, 7, 3,</span><br><span class="line">       5, 7, 7, 5, 7, 7, 5, 3, 5, 7, 7, 5, 5, 5, 5, 5, 7, 7, 7, 7, 7, 5,</span><br><span class="line">       7, 7, 7, 7, 7, 5, 7, 7, 7, 7, 3, 7, 7, 5, 7, 5, 7, 5, 7, 7, 5, 7,</span><br><span class="line">       7, 7, 7, 7, 7, 3, 5, 5, 7, 5, 7, 5])</span><br></pre></td></tr></table></figure><h3 id="5-2-随机排列"><a href="#5-2-随机排列" class="headerlink" title="5.2 随机排列"></a>5.2 随机排列</h3><h4 id="5-2-1-permutation"><a href="#5-2-1-permutation" class="headerlink" title="5.2.1 permutation"></a>5.2.1 permutation</h4><p>根据原有数组生成新的随机排列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">99</span>)</span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">new_arr = np.random.permutation(arr)</span><br><span class="line">new_arr</span><br></pre></td></tr></table></figure><p>输出为：<code>array([3, 1, 5, 4, 2])</code>。原数组<code>arr</code>不变。</p><h4 id="5-2-2-shuffle"><a href="#5-2-2-shuffle" class="headerlink" title="5.2.2 shuffle"></a>5.2.2 shuffle</h4><p>改变原有数组为随机排列。shuffle在英文中有洗牌的意思。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">99</span>)</span><br><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">np.random.shuffle(arr)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><p>输出为：<code>array([3, 1, 5, 4, 2])</code>。原数组<code>arr</code>改变。</p><h3 id="5-3-随机分布"><a href="#5-3-随机分布" class="headerlink" title="5.3 随机分布"></a>5.3 随机分布</h3><h4 id="5-3-1-正太分布"><a href="#5-3-1-正太分布" class="headerlink" title="5.3.1 正太分布"></a>5.3.1 正太分布</h4><p>使用<code>np.random.normal</code>方法生成符合正太分布的随机数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.normal(loc=<span class="number">1</span>, scale=<span class="number">2</span>, size=(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">x</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[ 0.14998973,  3.22564777,  1.48094109],</span><br><span class="line">       [ 2.252752  , -1.64038195,  2.8590667 ]])</span><br></pre></td></tr></table></figure><p>如果我们想查看x的随机分布，需安装seaborn绘制图像。使用pip安装：</p><p><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple seaborn</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.distplot(x, hist=<span class="literal">False</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/machine10.png" alt="image-20230311201629814"></p><h4 id="5-3-2-二项分布"><a href="#5-3-2-二项分布" class="headerlink" title="5.3.2 二项分布"></a>5.3.2 二项分布</h4><p>使用<code>np.random.binomial</code>方法生成符合二项分布的随机数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.binomial(n=<span class="number">10</span>, p=<span class="number">0.5</span>, size=<span class="number">10</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure><p>输出结果为： <code>array([8, 6, 6, 2, 5, 5, 5, 5, 3, 4])</code>。</p><p>绘制图像：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">sns.distplot(x, hist=<span class="literal">True</span>, kde=<span class="literal">False</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/machine11.png" alt="image-20230311201646103"></p><h4 id="5-3-3-多项式分布"><a href="#5-3-3-多项式分布" class="headerlink" title="5.3.3 多项式分布"></a>5.3.3 多项式分布</h4><p>多项式分布是二项分布的一般表示。使用<code>np.random.multinomial</code>方法生成符合多项式分布的随机数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.multinomial(n=<span class="number">6</span>, pvals=[<span class="number">1</span>/<span class="number">6</span>, <span class="number">1</span>/<span class="number">6</span>, <span class="number">1</span>/<span class="number">6</span>, <span class="number">1</span>/<span class="number">6</span>, <span class="number">1</span>/<span class="number">6</span>, <span class="number">1</span>/<span class="number">6</span>])</span><br><span class="line">x</span><br></pre></td></tr></table></figure><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/machine12.png" alt="image-20230311201703659"></p><h4 id="5-3-4-其他"><a href="#5-3-4-其他" class="headerlink" title="5.3.4 其他"></a>5.3.4 其他</h4><p>除以上分布外还有泊松分布、均匀分布、指数分布、卡方分布、帕累托分布等。感兴趣的可自行搜索。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数学符号及希腊字母</title>
      <link href="/post/c049076b.html"/>
      <url>/post/c049076b.html</url>
      
        <content type="html"><![CDATA[<h1 id="数学符号及希腊字母"><a href="#数学符号及希腊字母" class="headerlink" title="数学符号及希腊字母"></a>数学符号及希腊字母</h1><p>本文列出了常用的机器学习数学符号（Mathematical notations），包含代数、微积分、线性代数、概率论、集合论、统计学以及希腊字母。</p><h2 id="代数"><a href="#代数" class="headerlink" title="代数"></a>代数</h2><table><thead><tr><th>符号</th><th>名称</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>(f∘g)</td><td>复合函数</td><td>嵌套函数</td><td>(f∘g)(x)&#x3D;f(g(x))</td></tr><tr><td>∆</td><td>德耳塔</td><td>变化&#x2F;区别</td><td>∆x&#x3D;x_1-x_0</td></tr><tr><td>e</td><td>欧拉数</td><td>e&#x3D;2.718281828</td><td>$ s&#x3D;$ s&#x3D; \frac{1}{1+e^{-z}}$</td></tr><tr><td>∑</td><td>求和</td><td>求和</td><td>∑x_i&#x3D;x_1+x_2+x_3</td></tr><tr><td>∏</td><td>大写派</td><td>所有数的乘积</td><td>∏x_i&#x3D;x_1∙x_2∙x_3</td></tr><tr><td>ϵ</td><td>艾普西隆</td><td>0附近的小数</td><td>lr&#x3D;1e-4</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="微积分"><a href="#微积分" class="headerlink" title="微积分"></a>微积分</h2><table><thead><tr><th>符号</th><th>名称</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>x′</td><td>一阶导数</td><td>一阶导数</td><td>(x^2)′ &#x3D;2x</td></tr><tr><td>x″</td><td>二阶导数</td><td>二阶导数</td><td>(x^2)″ &#x3D;2</td></tr><tr><td>lim</td><td>极限</td><td>x接近0时的函数值</td><td></td></tr><tr><td>∇</td><td>nabla</td><td>梯度</td><td>∇f(a,b,c)</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><table><thead><tr><th>符号</th><th>名称</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>[ ]</td><td>方括号</td><td>矩阵或向量</td><td>M&#x3D;[135]</td></tr><tr><td>⋅</td><td>点</td><td>点积</td><td>Z&#x3D;X⋅W</td></tr><tr><td>⊙</td><td>哈达马</td><td>哈达马乘积</td><td>A&#x3D;B⊙C</td></tr><tr><td>XT</td><td>转置</td><td>矩阵转置</td><td>WT⋅X</td></tr><tr><td>X</td><td>矩阵</td><td>大写字母如</td><td>X,C,A,I,Y,O,N,G,J,I</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><table><thead><tr><th>符号</th><th>名称</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>P(A)</td><td>概率</td><td>事件A发生的概率</td><td>P(x&#x3D;1) &#x3D; 0.5</td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h2 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h2><table><thead><tr><th>符号</th><th>名称</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>S</td><td>集合</td><td>不同元素的列表</td><td>S &#x3D; {1, 5, 7, 9}</td></tr></tbody></table><h2 id="统计学"><a href="#统计学" class="headerlink" title="统计学"></a>统计学</h2><table><thead><tr><th>符号</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>μ</td><td>总体均值</td><td>总体平均值</td></tr><tr><td>$\bar x $</td><td>样本平均值</td><td>总体子集的平均值</td></tr><tr><td>σ2</td><td>总体方差</td><td>总体方差</td></tr><tr><td>s2</td><td>样本方差</td><td>总体子集的方差</td></tr><tr><td>σX</td><td>标准偏差</td><td>总体标准差</td></tr><tr><td>s</td><td>样本标准差</td><td>样本标准差</td></tr><tr><td>ρX</td><td>相关性</td><td>变量X和Y的相关性</td></tr><tr><td>$ \widetilde x $</td><td>中位数</td><td>变量x的中值</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table><thead><tr><th>大写</th><th>小写</th><th>英文注音</th><th>国际音标注音</th><th><strong>中文注音</strong></th></tr></thead><tbody><tr><td>Α</td><td>α</td><td>alpha</td><td>alfa</td><td>阿耳法</td></tr><tr><td>Β</td><td>β</td><td>beta</td><td>beta</td><td>贝塔</td></tr><tr><td>Γ</td><td>γ</td><td>gamma</td><td>gamma</td><td>伽马</td></tr><tr><td>Δ</td><td>δ</td><td>deta</td><td>delta</td><td>德耳塔</td></tr><tr><td>Ε</td><td>ε</td><td>epsilon</td><td>epsilon</td><td>艾普西隆</td></tr><tr><td>Ζ</td><td>ζ</td><td>zeta</td><td>zeta</td><td>截塔</td></tr><tr><td>Η</td><td>η</td><td>eta</td><td>eta</td><td>艾塔</td></tr><tr><td>Θ</td><td>θ</td><td>theta</td><td>θita</td><td>西塔</td></tr><tr><td>Ι</td><td>ι</td><td>iota</td><td>iota</td><td>约塔</td></tr><tr><td>Κ</td><td>κ</td><td>kappa</td><td>kappa</td><td>卡帕</td></tr><tr><td>∧</td><td>λ</td><td>lambda</td><td>lambda</td><td>兰姆达</td></tr><tr><td>Μ</td><td>μ</td><td>mu</td><td>miu</td><td>缪</td></tr><tr><td>Ν</td><td>ν</td><td>nu</td><td>niu</td><td>纽</td></tr><tr><td>Ξ</td><td>ξ</td><td>xi</td><td>ksi</td><td>可塞</td></tr><tr><td>Ο</td><td>ο</td><td>omicron</td><td>omikron</td><td>奥密可戎</td></tr><tr><td>∏</td><td>π</td><td>pi</td><td>pai</td><td>派</td></tr><tr><td>Ρ</td><td>ρ</td><td>rho</td><td>rou</td><td>柔</td></tr><tr><td>∑</td><td>σ</td><td>sigma</td><td>sigma</td><td>西格马</td></tr><tr><td>Τ</td><td>τ</td><td>tau</td><td>tau</td><td>套</td></tr><tr><td>Υ</td><td>υ</td><td>upsilon</td><td>jupsilon</td><td>衣普西隆</td></tr><tr><td>Φ</td><td>φ</td><td>phi</td><td>fai</td><td>斐</td></tr><tr><td>Χ</td><td>χ</td><td>chi</td><td>khai</td><td>喜</td></tr><tr><td>Ψ</td><td>ψ</td><td>psi</td><td>psai</td><td>普西</td></tr><tr><td>Ω</td><td>ω</td><td>omega</td><td>omiga</td><td>欧米</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>备份压缩命令</title>
      <link href="/post/56eaf829.html"/>
      <url>/post/56eaf829.html</url>
      
        <content type="html"><![CDATA[<h1 id="备份压缩命令"><a href="#备份压缩命令" class="headerlink" title="备份压缩命令"></a>备份压缩命令</h1><p>!!! 如果是在jupyter下使用,每天命令开头需要加<code>!</code></p><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip [参数] [打包后的文件名] [打包的目录路径]</span><br></pre></td></tr></table></figure><h3 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h3><p><code>-a</code> 将文件转成ASCII模式</p><p><code>-F</code> 尝试修复损坏的压缩文件</p><p><code>-h</code> 显示帮助界面</p><p><code>-m</code> 将文件压缩之后，删除源文件</p><p><code>-n</code> 特定字符串 不压缩具有特定字尾字符串的文件</p><p><code>-o</code> 将压缩文件内的所有文件的最新变动时间设为压缩时候的时间</p><p><code>-q</code> 安静模式，在压缩的时候不显示指令的执行过程</p><p><code>-r</code> 将指定的目录下的所有子目录以及文件一起处理</p><p><code>-S</code> 包含系统文件和隐含文件（S是大写）</p><p>例如：</p><ul><li>将指定目录&#x2F;tmp压缩成test.zip文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r test.zip tmb/</span><br></pre></td></tr></table></figure><h2 id="unzip"><a href="#unzip" class="headerlink" title="unzip"></a>unzip</h2><p>使用:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip [参数] [待解压缩文件]</span><br></pre></td></tr></table></figure><h3 id="常用参数：-1"><a href="#常用参数：-1" class="headerlink" title="常用参数："></a>常用参数：</h3><p><code>-n</code> 解压缩时不要覆盖原有的文件；</p><p><code>-o</code> 不必先询问用户，unzip执行后覆盖原有的文件；</p><p><code>-P [密码]</code> 使用zip的密码选项；</p><p><code>-q</code> 执行时不显示任何信息；</p><p><code>-d [目录]</code> 指定文件解压缩后所要存储的目录；</p><p>例如：</p><ul><li><p>将压缩文件text.zip在当前目录下解压缩。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip test.<span class="built_in">zip</span></span><br></pre></td></tr></table></figure></li><li><p>将压缩文件test.zip在指定目录&#x2F;tmp下解压缩，如果已有相同的文件存在，要求unzip命令覆盖原先的文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -o test.<span class="built_in">zip</span> -d tmp/</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>查看压缩文件目录，但不解压。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip -v text.zip</span><br></pre></td></tr></table></figure></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -d xxx.zip xxx.txt</span><br></pre></td></tr></table></figure><p>删除压缩文件<code>xxx</code>中<code>xxx.txt</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -m xxx.zip ./xxx.txt</span><br></pre></td></tr></table></figure><p>向压缩文件xxx.zip中添加xxx.txt文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -r filename.zip file1 file2 file3 /usr/work/school</span><br></pre></td></tr></table></figure><p>可以使用 zip 命令同时处理多个文件和目录，方法是将它们逐一列出，并用空格间隔：</p><p>上面的命令把 file1、file2、 file3、以及 &#x2F;usr&#x2F;work&#x2F;school 目录的内容（假设这个目录存在）压缩起来，然后放入 filename.zip 文件中。</p><h1 id="windows下使用zip-x2F-unzip"><a href="#windows下使用zip-x2F-unzip" class="headerlink" title="windows下使用zip&#x2F;unzip"></a>windows下使用zip&#x2F;unzip</h1><p><code>&#39;unzip &#39;不是内部或外部命令，也不是可运行的程序或批处理文件。</code></p><p>因为unzip是linux系统下，windows不自带。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>去unzip官网</p><p><a href="http://gnuwin32.sourceforge.net/packages/unzip.htm">UnZip for Windows</a>下载：</p><ol><li>先选择Binaries；</li><li>再下载ZIP；</li><li>最后将下载下来的unzip.exe文件放到C:\Windows\System32即可。</li></ol><p><img src="https://picbed.wuzhentao.com/blog/zip1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sklearn.datasets.fetch_20newsgroups下载报错的问题</title>
      <link href="/post/ad8f31d7.html"/>
      <url>/post/ad8f31d7.html</url>
      
        <content type="html"><![CDATA[<h1 id="下载报错的问题"><a href="#下载报错的问题" class="headerlink" title="下载报错的问题"></a>下载报错的问题</h1><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forbidden <span class="number">403</span></span><br></pre></td></tr></table></figure><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>手动下载正确的安装包</li></ol><p><code>https://ndownloader.figshare.com/files/5975967</code></p><ol start="2"><li>在我的电脑<br>C:\Users(你的 user_name)\scikit_learn_data\20news_home 目录下，将下载好的压缩包拖进去（如果之前没有的需要自己手动创建）</li><li>python 下载的文件叫<strong>20new-sbydate.tar.gz，</strong>自己下载的叫<strong>20newsbydate.tar.gz</strong>，所以需要改文件名字；</li></ol><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/machine1.png" alt="machine1.png (632×159) (wuzhentao.com)"></p><p>改成-&gt;</p><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/machine2.png" alt="machine1.png (632×159) (wuzhentao.com)"></p><p>中间的<code>-</code>一定看清楚!!!</p><ol start="4"><li>通过 D:你的项目下<code>\venv\Lib\site-packages\sklearn\datasets</code>找到其中的 <strong>twenty_newsgroups.py</strong>，打开进行如下的修改</li></ol><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>如果用本机<code>python</code>就找 python 的安装目录</p><p>打开文件位置</p><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/machine3.png" alt="machine1.png (632×159) (wuzhentao.com)"></p><p>这里打开的只是快捷方式, 再从快捷方式找到实际文件位置</p><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/machine4.png" alt="machine1.png (632×159) (wuzhentao.com)"></p><p>再按流程来</p><h3 id="jupyter"><a href="#jupyter" class="headerlink" title="jupyter"></a>jupyter</h3><p>如果用的<code>jupyter</code></p><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/machine5.png" alt="machine1.png (632×159) (wuzhentao.com)"></p><p>之后流程和<code>python</code>一样</p><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><p>查找<strong>twenty_newsgroups.py</strong>, 文件有多个需要仔细看</p><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/machine6.png" alt="machine1.png (632×159) (wuzhentao.com)"></p><p>找到<code>download_20newsgroups</code>函数</p><p>注释掉<code>logger.info(&quot;Downloading dataset from %s (14 MB)&quot;, ARCHIVE.url)</code>到<code>#os.remove(archive_path)</code>的五句话</p><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/machine7.png" alt="machine1.png (632×159) (wuzhentao.com)"></p><p>再添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">archive_path = <span class="string">&quot;C:/Users/(你的用户名)/scikit_learn_data/20news_home/20news-bydate.tar.gz&quot;</span></span><br><span class="line">logger.debug(<span class="string">&quot;Decompressing %s&quot;</span>, archive_path)</span><br><span class="line">tarfile.<span class="built_in">open</span>(archive_path, <span class="string">&quot;r:gz&quot;</span>).extractall(path=target_dir)</span><br><span class="line">os.remove(archive_path)</span><br></pre></td></tr></table></figure><p>注意：archive_path 是刚才放那个压缩包的路径</p><p>至此，便可以再次运行程序，可以成功运行<br>压缩文件变成了</p><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/machine8.png" alt="machine1.png (632×159) (wuzhentao.com)"></p><p>发现没有报错</p><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/machine9.png" alt="machine1.png (632×159) (wuzhentao.com)"></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>真正学会用jupyter</title>
      <link href="/post/3010dfa5.html"/>
      <url>/post/3010dfa5.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>数据分析为什么常用 Jupyter 而不是直接使用 Python 脚本或 Excel?</p></blockquote><h2 id="jupyter-的优势"><a href="#jupyter-的优势" class="headerlink" title="jupyter 的优势"></a>jupyter 的优势</h2><ul><li>无需 IDE，一个浏览器搞定</li><li>互式开发和直观的数据展示</li><li>叙述性文本的特性让其直接变成展示文档</li><li>多种类型变化，可直接转换成 python，md 等类型文件</li><li>完全免费</li><li>还支持 R 语言</li></ul><p>最主要的优势就是交互式开发和实时展示功能</p><p>这基本上能保证每一步的结果都是正确可靠的</p><p>这对于数据分析尤为重要,因为中间只要写错一步,最后的结果可能跟真实结果大相径庭</p><p>同时 jupyter 还可以远程连接云服务做大数据,甚至深度学习</p><h2 id="食用建议"><a href="#食用建议" class="headerlink" title="食用建议"></a>食用建议</h2><ol><li>首先熟练适用键盘,确定自己打字没问题,键盘的效率比鼠标高得不是一星半点</li><li>最好先学习一下 Markdown 语法, 对于做笔记来说实在是太好用了! 在我的其他文章里有教程,只需要花十几二十分钟就会用了</li></ol><h1 id="jupyter-使用"><a href="#jupyter-使用" class="headerlink" title="jupyter 使用"></a>jupyter 使用</h1><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>jupyter 里有<code>命令模式</code>和<code>编辑模式</code></p><p><img src="https://picbed.wuzhentao.com/teach/teach1.png" alt="image-20230303172001687"></p><p>命令模式下 <code>代码块</code>左边显示为蓝色</p><p>编辑模式变为命令模式需要按下 键盘左上角的<code>ESC</code>键</p><p>我们可以使用很多快捷键</p><p>例如</p><ul><li><code>dd</code>:删除当前代码块</li><li><code>b</code>:在下方添加一个代码块</li><li><code>a</code>:在上方添加一个代码块</li><li><code>m</code>:将编程语言变为 Markdown 代码块</li><li><code>y</code>:将 Markdown 代码块变为编程语言代码块</li><li><code>Ctrl + Enter</code>: 执行单元格</li></ul><p>上下<code>代码块</code>的切换可以使用方向键<code>↑</code> <code>↓</code>也可以使用<code>j</code> <code>k</code>键,<code>j</code> 上移, <code>k</code> 下移</p><p>快捷键记不住没有关系</p><p>在命令模式下按<code>H</code>键,显示提示</p><p><img src="https://picbed.wuzhentao.com/teach/teach2.png" alt="image-20230303172923708"></p><h2 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h2><p>编辑模式下 <code>代码块</code>左边显示为绿色</p><p>可以自由输入代码</p><p>命令模式进入编辑模式需要按下 回车键<code>Enter</code></p><p><img src="https://picbed.wuzhentao.com/teach/teach3.png" alt="image-20230303172346658"></p><h2 id="序号说明"><a href="#序号说明" class="headerlink" title="序号说明"></a>序号说明</h2><p>单元格前面的序号表示单元格执行的次序。<strong>其中空[ ]为从来没执行过。[*]为尚未执行到。</strong></p><p><img src="https://picbed.wuzhentao.com/teach/teach8.png" alt="hongxia.webp (942×942) (wuzhentao.com)"></p><h2 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h2><p>Jupyter Notebook 支持LaTex数学公式。新建Markdown代码格式单元格。</p><p>输入下方文本将显示LaTeX公式，这对我们学习机器学习记数学公式非常有帮助。</p><p>试试执行下面的代码，看看会显示什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;equation*&#125;</span><br><span class="line">\left( \sum_&#123;k=1&#125;^n a_k b_k \right)^2 \leq \left( \sum_&#123;k=1&#125;^n a_k^2 \right) \left( \sum_&#123;k=1&#125;^n b_k^2 \right)</span><br><span class="line">\end&#123;equation*&#125;</span><br></pre></td></tr></table></figure><p><img src="https://picbed.wuzhentao.com/teach/teach9.png" alt="image-20230310195132934"></p><h2 id="魔法命令"><a href="#魔法命令" class="headerlink" title="魔法命令"></a>魔法命令</h2><p><strong>输入<code>%lsmagic</code>查看所有可用魔法命令。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%lsmagic</span><br></pre></td></tr></table></figure><p><img src="https://picbed.wuzhentao.com/teach/teach10.png" alt="image-20230310195258140"></p><p><strong><code>%quickref</code>：输出所有魔法指令的简单版帮助文档</strong></p><ul><li><strong>%history：列出历史输入的指令</strong></li><li><strong>%dhist：输出历史访问目录</strong></li><li><strong>%pip：在cell中使用pip指令</strong></li><li><strong>%pwd：输出当前路径</strong></li><li><strong>%pycat：预览文件，类似linux中cat</strong></li><li><strong>%run：执行脚本</strong></li><li><strong>%time：执行时间</strong></li></ul><h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><p>你可能会认为: 就这? 这也快不了多少呀</p><p>那我就简单的举个栗子:</p><blockquote><p>查找替换变量</p></blockquote><p><img src="https://picbed.wuzhentao.com/teach/teach4.png" alt="image-20230303173442672"></p><p>例如我想把这里面的<code>ar_y</code>变量改个名字, 正常思维肯定是一个个找</p><p>但是那样未免效率太低了吧</p><p>假如这是个大型文件, 老板要你换个东西, 这一个个找多浪费时间!</p><p>这时候可以使用我们的快捷键了</p><p>命令模式下按下<code>f</code>, 重要的事情说三遍! 是命令模式下! 命令模式下! 命令模式下!</p><p>会给我们一个功能</p><p><img src="https://picbed.wuzhentao.com/teach/teach5.png" alt="image-20230303173734590"></p><p>我想不用我解释各位童鞋都应该知道是干嘛的了吧</p><p><img src="https://picbed.wuzhentao.com/teach/teach6.png" alt="image-20230303173915985"></p><p>这样几分钟就能解决了</p><p>当然我讲的只是 jupyter 功能的冰山一角</p><p>如果想要更快的提高效率,童鞋们可以自己去查看文档</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>这里什么都没有, 单纯就是为了水个结尾! love &amp;&amp; peace !</p><p><img src="https://picbed.wuzhentao.com/teach/teach7.jpg" alt="image-20230303173915985"></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习代码全收录</title>
      <link href="/post/2d82a014.html"/>
      <url>/post/2d82a014.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文章用于收录本学期所有机器学习代码, 欢迎大家查看</p><p>如代码有误可联系我!</p><p>本人会在最快的时间内把<code>Bug</code>修复</p><h1 id="2023-x2F-2-x2F-23"><a href="#2023-x2F-2-x2F-23" class="headerlink" title="2023&#x2F;2&#x2F;23"></a>2023&#x2F;2&#x2F;23</h1><blockquote><p>归一化</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier <span class="keyword">as</span> knn</span><br><span class="line">ar_x = [[<span class="number">4032</span>, <span class="number">1680</span>, <span class="number">1450</span>, <span class="number">5.3</span>, <span class="number">5.6</span>],</span><br><span class="line">        [<span class="number">4330</span>, <span class="number">1535</span>, <span class="number">1885</span>, <span class="number">7.8</span>, <span class="number">14.5</span>],</span><br><span class="line">        [<span class="number">4053</span>, <span class="number">1740</span>, <span class="number">1449</span>, <span class="number">6.2</span>, <span class="number">10.8</span>],</span><br><span class="line">        [<span class="number">5087</span>, <span class="number">1868</span>, <span class="number">1500</span>, <span class="number">8.5</span>, <span class="number">25.6</span>],</span><br><span class="line">        [<span class="number">4560</span>, <span class="number">1822</span>, <span class="number">1645</span>, <span class="number">7.8</span>, <span class="number">15.8</span>],</span><br><span class="line">        [<span class="number">3797</span>, <span class="number">1510</span>, <span class="number">1820</span>, <span class="number">5.5</span>, <span class="number">9.6</span>]]</span><br><span class="line">ar_y = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">ar_yy = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">ar_min = np.<span class="built_in">min</span>(ar_x, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(ar_min)</span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">max</span>(ar_x, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">ar_mn = np.<span class="built_in">max</span>(ar_x, <span class="number">0</span>) - ar_min</span><br><span class="line"><span class="built_in">print</span>(ar_mn)</span><br><span class="line"></span><br><span class="line">nor_ar = np.around((ar_x - ar_min) / ar_mn, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(nor_ar)</span><br><span class="line"></span><br><span class="line">model = knn(n_neighbors = <span class="number">3</span>)</span><br><span class="line">model.fit(nor_ar[:<span class="number">4</span>], ar_y)</span><br><span class="line">pre = model.predict(nor_ar[<span class="number">4</span>:<span class="number">6</span>])</span><br><span class="line"><span class="built_in">print</span>(pre)</span><br></pre></td></tr></table></figure><h1 id="2023-x2F-2-x2F-23-1"><a href="#2023-x2F-2-x2F-23-1" class="headerlink" title="2023&#x2F;2&#x2F;23"></a>2023&#x2F;2&#x2F;23</h1><blockquote><p>红酒</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy as np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot as plt</span><br><span class="line">from matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line">from sklearn <span class="keyword">import</span> neighbors, datasets</span><br><span class="line">from sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">wine_dataset = datasets.<span class="built_in">load_wine</span>()# 可以导入datasets，也可以直接导入load_wine</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;红酒数据集中的键为:\n&quot;</span>,wine_dataset.<span class="built_in">keys</span>())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数据概况：&quot;</span>,wine_dataset[<span class="string">&#x27;data&#x27;</span>].shape)</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = <span class="built_in">train_test_split</span>(wine_dataset[<span class="string">&#x27;data&#x27;</span>],wine_dataset[<span class="string">&#x27;target&#x27;</span>], test_size=<span class="number">0.25</span>,random_state = <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;X_train shape:&#x27;</span>,X_train.shape,<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;X_test shape:&#x27;</span>, X_test.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;y_train shape:&#x27;</span>,y_train.shape,<span class="string">&#x27;\n&#x27;</span>,<span class="string">&#x27;y_test shape:&#x27;</span>, y_test.shape)</span><br><span class="line"></span><br><span class="line">knn = neighbors.<span class="built_in">KNeighborsClassifier</span>(n_neighbors=<span class="number">3</span>)</span><br><span class="line">knn.<span class="built_in">fit</span>(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型评分：&#123;:.2f&#125;&#x27;</span>.format(knn.<span class="built_in">score</span>(X_test, y_test)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型评分2：&#123;:.2f&#125;&#x27;</span>.format(knn.<span class="built_in">score</span>(X_train, y_train)))</span><br><span class="line"></span><br><span class="line">X_new = np.<span class="built_in">array</span>([[<span class="number">13.2</span>, <span class="number">2.77</span>, <span class="number">2.51</span>, <span class="number">18.5</span>, <span class="number">96.6</span>, <span class="number">1.04</span>, <span class="number">2.55</span>, <span class="number">0.57</span>, <span class="number">1.47</span>, <span class="number">6.2</span>, <span class="number">1.05</span>, <span class="number">3.88</span>, <span class="number">820</span>]])</span><br><span class="line">result = knn.<span class="built_in">predict</span>(X_new)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;预测红酒的分类为：&quot;</span>, wine_dataset[<span class="string">&#x27;target_names&#x27;</span>][result])</span><br></pre></td></tr></table></figure><blockquote><p>归一化处理后的</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#利用归一化处理数据</span></span><br><span class="line">X, y = wine_dataset[<span class="string">&#x27;data&#x27;</span>], wine_dataset[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">X_min = np.<span class="built_in">min</span>(X, <span class="number">0</span>)</span><br><span class="line">X_mn = np.<span class="built_in">max</span>(X, <span class="number">0</span>) - X_min</span><br><span class="line">nor_X = np.around((X - X_min) / X_mn, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(nor_X,wine_dataset[<span class="string">&#x27;target&#x27;</span>], test_size=<span class="number">0.25</span>,random_state = <span class="number">0</span>)</span><br><span class="line">knn = neighbors.KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型评分：&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(knn.score(X_test, y_test)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型评分2：&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(knn.score(X_train, y_train)))</span><br></pre></td></tr></table></figure><blockquote><p>鸢尾花</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#鸢尾花</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line">iris_data = load_iris()</span><br><span class="line">X, y = iris_data[<span class="string">&#x27;data&#x27;</span>], iris_data[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">X_min = np.<span class="built_in">min</span>(X, <span class="number">0</span>)</span><br><span class="line">X_mn = np.<span class="built_in">max</span>(X, <span class="number">0</span>) - X_min</span><br><span class="line">nor_X = np.around((X - X_min) / X_mn, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(nor_X,iris_data[<span class="string">&#x27;target&#x27;</span>], test_size=<span class="number">0.25</span>,random_state = <span class="number">0</span>)</span><br><span class="line">knn = neighbors.KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型评分：&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(knn.score(X_test, y_test)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型评分2：&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(knn.score(X_train, y_train)))</span><br></pre></td></tr></table></figure><blockquote><p>出行</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#出行</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelBinarizer, OneHotEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;knn-chuxing.csv&#x27;</span>,encoding = <span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line">data.head()</span><br><span class="line">X = data.iloc[:, <span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">Y = data.iloc[:, <span class="number">4</span>:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#标签化与独热编码</span></span><br><span class="line">enc = OneHotEncoder()</span><br><span class="line">enc.fit(X)</span><br><span class="line"></span><br><span class="line">X = enc.transform(X).toarray()</span><br><span class="line">y = np.array(Y)</span><br><span class="line">z = y.tolist()</span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line"></span><br><span class="line"><span class="comment">#划分训练集和数据集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, z, test_size=<span class="number">0.25</span>,random_state = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors = <span class="number">5</span>)</span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型评分：&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(knn.score(X_test, y_test)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型评分2：&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(knn.score(X_train, y_train)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">X_new = [[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line">pre = knn.predict(X_new)</span><br><span class="line">pre</span><br><span class="line"></span><br><span class="line">y_pred = knn.predict(X_test)</span><br><span class="line">y_pred</span><br></pre></td></tr></table></figure><h1 id="2023-x2F-2-x2F-28"><a href="#2023-x2F-2-x2F-28" class="headerlink" title="2023&#x2F;2&#x2F;28"></a>2023&#x2F;2&#x2F;28</h1><blockquote><p>knn-StrawBerryAnalysis.csv 文件</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection  <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取数据</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_csv(<span class="string">&quot;knn-StrawBerryAnalysis.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line">x = df.iloc[:, <span class="number">1</span> : <span class="number">7</span>]</span><br><span class="line">y = df.iloc[:, <span class="number">7</span> : <span class="number">8</span>]</span><br><span class="line">x = np.array(x)</span><br><span class="line">y = np.array(y)</span><br><span class="line">y = y.reshape(<span class="number">21793</span>, )</span><br><span class="line"></span><br><span class="line"><span class="comment">#利用归一化处理数据</span></span><br><span class="line">X, y = x, y</span><br><span class="line">X_min = np.<span class="built_in">min</span>(X, <span class="number">0</span>)</span><br><span class="line">X_mn = np.<span class="built_in">max</span>(X, <span class="number">0</span>) - X_min</span><br><span class="line">nor_X = np.around((X - X_min) / X_mn, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#画图判断k值</span></span><br><span class="line">k_range = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>)</span><br><span class="line">k_error = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> k_range:</span><br><span class="line">    knn = KNeighborsClassifier(n_neighbors=k)</span><br><span class="line"></span><br><span class="line">    scores = cross_val_score(knn, nor_X, y)</span><br><span class="line">    k_error.append(<span class="number">1</span> - scores.mean())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#画图，x轴为k值，y值为误差值</span></span><br><span class="line">plt.plot(k_range, k_error)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Value of K for KNN&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(nor_X , y, test_size=<span class="number">0.25</span>,random_state = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors = <span class="number">2</span>)</span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型评分：&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(knn.score(X_test, y_test)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型评分2：&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(knn.score(X_train, y_train)))</span><br></pre></td></tr></table></figure><blockquote><p>口红,啤酒分类</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.read_excel(<span class="string">&quot;data.xlsx&quot;</span>)</span><br><span class="line"></span><br><span class="line">train_x = df.iloc[<span class="number">1</span> : <span class="number">13</span>, <span class="number">2</span> :]</span><br><span class="line">test_x = df.iloc[<span class="number">13</span> : <span class="number">17</span>, <span class="number">2</span> :]</span><br><span class="line">train_y = df.iloc[<span class="number">1</span>: <span class="number">13</span>, <span class="number">1</span>]</span><br><span class="line">test_y = df.iloc[<span class="number">13</span> : <span class="number">17</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">gnb = GaussianNB()</span><br><span class="line">fitl = gnb.fit(train_x, train_y)</span><br><span class="line">pre = gnb.predict(test_x)</span><br><span class="line">r_n = (test_y == pre).<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;总测试条目 = %d， 正确率 = %5.2f&quot;</span>%(<span class="built_in">len</span>(test_x), <span class="built_in">float</span>(r_n / <span class="built_in">len</span>(test_x) * <span class="number">100</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">x_new = df.iloc[<span class="number">17</span> : <span class="number">19</span>, <span class="number">2</span> :]</span><br><span class="line">pre = gnb.predict(x_new)</span><br><span class="line"><span class="built_in">print</span>(pre)</span><br></pre></td></tr></table></figure><blockquote><p>学习通视频里的模型评分, 用的列表实现</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line"></span><br><span class="line">of = <span class="built_in">open</span>(<span class="string">&#x27;data.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> of:</span><br><span class="line">    li_t = line.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    y.append(<span class="built_in">int</span>(li_t[<span class="number">4</span>]))</span><br><span class="line">    x.append([ <span class="built_in">int</span>(li_t[<span class="number">0</span>]), <span class="built_in">int</span>(li_t[<span class="number">1</span>]), <span class="built_in">int</span>(li_t[<span class="number">2</span>]), <span class="built_in">int</span>(li_t[<span class="number">3</span>])])</span><br><span class="line"></span><br><span class="line">fd = <span class="built_in">int</span>(<span class="built_in">len</span>(x) * <span class="number">0.9</span>)</span><br><span class="line">train_x = x[: fd]</span><br><span class="line">test_x = x[fd: ]</span><br><span class="line">train_y = y[: fd]</span><br><span class="line">test_y = y[fd: ]</span><br><span class="line"></span><br><span class="line">gnb = GaussianNB()</span><br><span class="line">fitl = gnb.fit(train_x, train_y)</span><br><span class="line">pre = gnb.predict(test_x)</span><br><span class="line">r_n = (test_y == pre).<span class="built_in">sum</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;总测试条目 = %d， 正确率 = %5.2f&quot;</span>%(<span class="built_in">len</span>(test_x), <span class="built_in">float</span>(r_n / <span class="built_in">len</span>(test_x) * <span class="number">100</span>)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习</title>
      <link href="/post/498ab7d9.html"/>
      <url>/post/498ab7d9.html</url>
      
        <content type="html"><![CDATA[<h1 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h1><h2 id="kNN-算法概述"><a href="#kNN-算法概述" class="headerlink" title="kNN 算法概述"></a>kNN 算法概述</h2><p>KNN 可以说是最简单的分类算法之一，同时，它也是最常用的分类算法之一，注意 KNN 算法是有监督学习中的分类算法，它看起来和另一个机器学习算法 Kmeans 有点像（Kmeans 是无监督学习算法），但却是有本质区别的。那么什么是 KNN 算法呢，接下来我们就来介绍介绍吧。</p><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>KNN 的全称是 K Nearest Neighbors，意思是 K 个最近的邻居</p><p>K 个最近邻居，毫无疑问，K 的取值肯定是至关重要的。</p><p><strong>KNN 的原理就是当预测一个新的值 x 的时候，根据它距离最近的 K 个点是什么类别来判断 x 属于哪个类别</strong></p><p><img src="https://picbed.wuzhentao.com/AI/AI1.png" alt="AI1.png (740×349) (wuzhentao.com)"></p><p>图中绿色的点就是我们要预测的那个点，假设 K&#x3D;3。</p><p>那么 KNN 算法就会找到与它距离最近的三个点（这里用圆圈把它圈起来了），看看哪种类别多一些，比如这个例子中是蓝色三角形多一些，新来的绿色点就归类到蓝三角了。</p><p><img src="https://picbed.wuzhentao.com/AI/AI2.png" alt="AI1.png (740×349) (wuzhentao.com)"></p><p>但是，<strong>当 K&#x3D;5 的时候，判定就变成不一样了</strong>。这次变成红圆多一些，所以新来的绿点被归类成红圆。从这个例子中，我们就能看得出 K 的取值是很重要的。</p><p>明白了大概原理后，我们就来说一说细节的东西吧，主要有两个，<strong>K 值的选取</strong>和<strong>点距离的计算</strong>。</p><h2 id="距离计算"><a href="#距离计算" class="headerlink" title="距离计算"></a>距离计算</h2><p>要度量空间中点距离的话，有好几种度量方式，比如常见的曼哈顿距离计算，欧式距离计算等等。</p><p>不过通常 KNN 算法中使用的是欧式距离，这里只是简单说一下，拿二维平面为例，，二维空间两个点的欧式距离计算公式如下：</p><p><img src="https://picbed.wuzhentao.com/AI/AI3.png" alt="AI1.png (740×349) (wuzhentao.com)"></p><p>这个高中应该就有接触到的了，其实就是计算（x1,y1）和（x2,y2）的距离。拓展到多维空间，则公式变成这样：</p><p><img src="https://picbed.wuzhentao.com/AI/AI4.png" alt="AI1.png (740×349) (wuzhentao.com)"></p><h2 id="K-值选择"><a href="#K-值选择" class="headerlink" title="K 值选择"></a>K 值选择</h2><p>通过上面那张图我们知道 K 的取值比较重要，那么该如何确定 K 取多少值好呢？答案是通过交叉验证（将样本数据按照一定比例，拆分出训练用的数据和验证用的数据，比如 6：4 拆分出部分训练数据和验证数据），从选取一个较小的 K 值开始，不断增加 K 的值，然后计算验证集合的方差，最终找到一个比较合适的 K 值。</p><p>通过交叉验证计算方差后你大致会得到下面这样的图：</p><p><img src="https://picbed.wuzhentao.com/AI/AI5.png" alt="AI1.png (740×349) (wuzhentao.com)"></p><p>当你增大 k 的时候，一般错误率会先降低，因为有周围更多的样本可以借鉴了，分类效果会变好。但注意，和 K-means 不一样，当 K 值更大的时候，错误率会更高。这也很好理解，比如说你一共就 35 个样本，当你 K 增大到 30 的时候，KNN 基本上就没意义了。</p><p>所以选择 K 点的时候可以选择一个较大的临界 K 点，当它继续增大或减小的时候，错误率都会上升，比如图中的 K&#x3D;10。具体如何得出 K 最佳值的代码，下一节的代码实例中会介绍。</p><h2 id="KNN-特点"><a href="#KNN-特点" class="headerlink" title="KNN 特点"></a>KNN 特点</h2><p>KNN 是一种<strong>非参的</strong>，<strong>惰性</strong>的算法模型。什么是非参，什么是惰性呢？</p><p><strong>非参</strong>的意思并不是说这个算法不需要参数，而是意味着这个模型不会对数据做出任何的假设，与之相对的是线性回归（我们总会假设线性回归是一条直线）。也就是说 KNN 建立的模型结构是根据数据来决定的，这也比较符合现实的情况，毕竟在现实中的情况往往与理论上的假设是不相符的。</p><p><strong>惰性</strong>又是什么意思呢？想想看，同样是分类算法，逻辑回归需要先对数据进行大量训练（tranning），最后才会得到一个算法模型。而 KNN 算法却不需要，它没有明确的训练数据的过程，或者说这个过程很快。</p><h2 id="KNN-算法的优势和劣势"><a href="#KNN-算法的优势和劣势" class="headerlink" title="KNN 算法的优势和劣势"></a>KNN 算法的优势和劣势</h2><p>了解 KNN 算法的优势和劣势，可以帮助我们在选择学习算法的时候做出更加明智的决定。那我们就来看看 KNN 算法都有哪些优势以及其缺陷所在！</p><h4 id="KNN-算法优点"><a href="#KNN-算法优点" class="headerlink" title="KNN 算法优点"></a>KNN 算法优点</h4><ol><li>简单易用，相比其他算法，KNN 算是比较简洁明了的算法。即使没有很高的数学基础也能搞清楚它的原理。</li><li>模型训练时间快，上面说到 KNN 算法是惰性的，这里也就不再过多讲述。</li><li>预测效果好。</li><li>对异常值不敏感</li></ol><h4 id="KNN-算法缺点"><a href="#KNN-算法缺点" class="headerlink" title="KNN 算法缺点"></a>KNN 算法缺点</h4><ol><li>对内存要求较高，因为该算法存储了所有训练数据</li><li>预测阶段可能很慢</li><li>对不相关的功能和数据规模敏感</li></ol><h2 id="使用时机"><a href="#使用时机" class="headerlink" title="使用时机"></a>使用时机</h2><p>当需要使用分类算法，且数据比较大的时候就可以尝试使用 KNN 算法进行分类了。</p><h2 id="Skelarn-KNN-参数概述"><a href="#Skelarn-KNN-参数概述" class="headerlink" title="Skelarn KNN 参数概述"></a>Skelarn KNN 参数概述</h2><p>要使用 sklearnKNN 算法进行分类，我们需要先了解 sklearnKNN 算法的一些基本参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">KNeighborsClassifier</span>(<span class="params">n_neighbors = <span class="number">5</span>,</span></span><br><span class="line"><span class="params">                       weights=<span class="string">&#x27;uniform&#x27;</span>,</span></span><br><span class="line"><span class="params">                       algorithm = <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="params">                       leaf_size = <span class="string">&#x27;30&#x27;</span>,</span></span><br><span class="line"><span class="params">                       p = <span class="number">2</span>,</span></span><br><span class="line"><span class="params">                       metric = <span class="string">&#x27;minkowski&#x27;</span>,</span></span><br><span class="line"><span class="params">                       metric_params = <span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                       n_jobs = <span class="literal">None</span></span></span><br><span class="line"><span class="params">                       </span>)</span><br><span class="line"></span><br><span class="line">- n_neighbors：这个值就是指 KNN 中的 “K”了。前面说到过，通过调整 K 值，算法会有不同的效果。</span><br><span class="line">- weights（权重）：最普遍的 KNN 算法无论距离如何，权重都一样，但有时候我们想搞点特殊化，比如距离更近的点让它更加重要。这时候就需要 weight 这个参数了，这个参数有三个可选参数的值，决定了如何分配权重。参数选项如下：</span><br><span class="line">        • <span class="string">&#x27;uniform&#x27;</span>：不管远近权重都一样，就是最普通的 KNN 算法的形式。</span><br><span class="line">        • <span class="string">&#x27;distance&#x27;</span>：权重和距离成反比，距离预测目标越近具有越高的权重。</span><br><span class="line">        • 自定义函数：自定义一个函数，根据输入的坐标值返回对应的权重，达到自定义权重的目的。</span><br><span class="line">- algorithm：在 sklearn 中，要构建 KNN 模型有三种构建方式，<span class="number">1.</span> 暴力法，就是直接计算距离存储比较的那种放松。<span class="number">2.</span> 使用 kd 树构建 KNN 模型 <span class="number">3.</span> 使用球树构建。 其中暴力法适合数据较小的方式，否则效率会比较低。如果数据量比较大一般会选择用 KD 树构建 KNN 模型，而当 KD 树也比较慢的时候，则可以试试球树来构建 KNN。参数选项如下：</span><br><span class="line">        • <span class="string">&#x27;brute&#x27;</span> ：蛮力实现</span><br><span class="line">        • <span class="string">&#x27;kd_tree&#x27;</span>：KD 树实现 KNN</span><br><span class="line">        • <span class="string">&#x27;ball_tree&#x27;</span>：球树实现 KNN</span><br><span class="line">        • <span class="string">&#x27;auto&#x27;</span>： 默认参数，自动选择合适的方法构建模型</span><br><span class="line">不过当数据较小或比较稀疏时，无论选择哪个最后都会使用 <span class="string">&#x27;brute&#x27;</span></span><br><span class="line"></span><br><span class="line">- leaf_size：如果是选择蛮力实现，那么这个值是可以忽略的，当使用KD树或球树，它就是是停止建子树的叶子节点数量的阈值。默认<span class="number">30</span>，但如果数据量增多这个参数需要增大，否则速度过慢不说，还容易过拟合。</span><br><span class="line">- p：和metric结合使用的，当metric参数是<span class="string">&quot;minkowski&quot;</span>的时候，p=<span class="number">1</span>为曼哈顿距离， p=<span class="number">2</span>为欧式距离。默认为p=<span class="number">2</span>。</span><br><span class="line">- metric：指定距离度量方法，一般都是使用欧式距离。</span><br><span class="line">        • <span class="string">&#x27;euclidean&#x27;</span> ：欧式距离</span><br><span class="line">        • <span class="string">&#x27;manhattan&#x27;</span>：曼哈顿距离</span><br><span class="line">        • <span class="string">&#x27;chebyshev&#x27;</span>：切比雪夫距离</span><br><span class="line">        • <span class="string">&#x27;minkowski&#x27;</span>： 闵可夫斯基距离，默认参数</span><br><span class="line">- n_jobs：指定多少个CPU进行运算，默认是-<span class="number">1</span>，也就是全部都算。</span><br></pre></td></tr></table></figure><h2 id="KNN-代码实例"><a href="#KNN-代码实例" class="headerlink" title="KNN 代码实例"></a>KNN 代码实例</h2><p>KNN 算法算是机器学习里面最简单的算法之一了，我们来 sklearn 官方给出的例子，来看看 KNN 应该怎样使用吧：</p><p>数据集使用的是著名的鸢尾花数据集，用 KNN 来对它做分类。我们先看看鸢尾花长的啥样。</p><p><img src="https://picbed.wuzhentao.com/AI/AI6.png" alt="AI1.png (740×349) (wuzhentao.com)"></p><p>面这个就是鸢尾花了，这个鸢尾花数据集主要包含了鸢尾花的花萼长度，花萼宽度，花瓣长度，花瓣宽度 4 个属性（特征），以及鸢尾花卉属于『Setosa，Versicolour，Virginica』三个种类中的哪一类（这三种都长什么样我也不知道）。</p><p>在使用 KNN 算法之前，我们要先决定 K 的值是多少，要选出最优的 K 值，可以使用 sklearn 中的交叉验证方法，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection  <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取鸢尾花数据集</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">x = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line">k_range = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>)</span><br><span class="line">k_error = []</span><br><span class="line"><span class="comment">#循环，取k=1到k=31，查看误差效果</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> k_range:</span><br><span class="line">    knn = KNeighborsClassifier(n_neighbors=k)</span><br><span class="line">    <span class="comment">#cv参数决定数据集划分比例，这里是按照5:1划分训练集和测试集</span></span><br><span class="line">    scores = cross_val_score(knn, x, y)</span><br><span class="line">    k_error.append(<span class="number">1</span> - scores.mean())</span><br><span class="line"></span><br><span class="line"><span class="comment">#画图，x轴为k值，y值为误差值</span></span><br><span class="line">plt.plot(k_range, k_error)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Value of K for KNN&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Error&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行后，我们可以得到下面这样的图：</p><p><img src="https://picbed.wuzhentao.com/AI/AI7.png" alt="AI1.png (740×349) (wuzhentao.com)"></p><p>有了这张图，我们就能明显看出 K 值取多少的时候误差最小，这里明显是 K&#x3D;11 最好。当然在实际问题中，如果数据集比较大，那为减少训练时间，K 的取值范围可以缩小。</p><p>有了 K 值我们就能运行 KNN 算法了，具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#鸢尾花</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(x , y, test_size=<span class="number">0.25</span>,random_state = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">knn = neighbors.KNeighborsClassifier(n_neighbors=<span class="number">11</span>)</span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型评分：&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(knn.score(X_test, y_test)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型评分2：&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(knn.score(X_train, y_train)))</span><br></pre></td></tr></table></figure><h1 id="贝叶斯算法"><a href="#贝叶斯算法" class="headerlink" title="贝叶斯算法"></a>贝叶斯算法</h1><p>贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。<strong>而朴素贝叶斯分类是贝叶斯分类中最简单，也是常见的一种分类方法</strong>。</p><h2 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h2><p>贝叶斯定理告诉我们如何交换条件概率中的条件与结果,</p><p>即如果已知P( X | H ),要求P( H | X ),那么可以使用下面的计算方法:</p><p><img src="https://picbed.wuzhentao.com/AI/AI8.png"></p><p>P( H | X )给定观测数据样本X ,假设H是成立的概率</p><p> 比如X是一份具有特定特征的邮件, H是垃圾邮件。它里面包含很多的单词(特征) , 然后我们判断这封邮件属于垃圾邮件的概率是多少。</p><p>P( H | X)是后验概率。比如一份特定邮件中,是垃圾邮件的概率。<br>P(H)是H的先验概率。比如总体邮件中垃圾邮件的概率。<br>P(X )是X的先验概率。比如总体邮件中带有特定特征的邮件概率。</p><p><strong>或者换个表达方式:</strong></p><p><img src="https://picbed.wuzhentao.com/AI/AI9.png" alt="img"></p><blockquote><p>可以通过抽样来计算先验概率。抽样的数量越大,得到的结果越接近于真实的概率分布-大数定理。</p></blockquote><h2 id="举例"><a href="#举例" class="headerlink" title="举例:"></a>举例:</h2><p><img src="https://picbed.wuzhentao.com/AI/AI10.png" alt="image-20230301162706655"></p><h2 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h2><p>朴素贝叶斯是贝叶斯决策理论的一部分。之所以称之为“朴素”，是因为整个形式化过程只做最原始、最简单的假设。</p><p><strong>下面我先给出例子。</strong></p><p><strong>给定数据如下：</strong></p><p><img src="https://picbed.wuzhentao.com/AI/AI11.png" alt="image-20230301163236141"></p><p><strong>现在给我们的问题是，</strong>如果想给一个人推送消息,他的消费记录分别有维修工具,杂志,电影票,电子游戏机, 请你判断一下一个<strong>上述所有东西都买的人</strong>该给他推送啤酒还是口红</p><p>这是一个典型的分类问题，<strong>转为数学问题就是比较p(啤酒|(维修工具、杂志、电影票、电子游戏机))与p(口红|(维修工具、杂志、电影票、电子游戏机))的概率</strong>，谁的概率大，我就能给口红或者啤酒的答案！</p><p>这里我们联系到朴素贝叶斯公式：</p><p><img src="https://picbed.wuzhentao.com/AI/AI16.png" alt="image-20230301175343094"></p><p>我们需要求<strong>p(啤酒 | 维修工具、杂志、电影票、电子游戏机)</strong>,这是我们不知道的，但是通过朴素贝叶斯公式可以转化为好求的三个量，<strong>p(维修工具、杂志、电影票、电子游戏机 | 啤酒)、p(维修工具、杂志、电影票、电子游戏机)、p(啤酒)（至于为什么能求，后面会讲，那么就太好了，将待求的量转化为其它可求的值，这就相当于解决了我们的问题！）</strong></p><h2 id="朴素贝叶斯算法的朴素一词解释"><a href="#朴素贝叶斯算法的朴素一词解释" class="headerlink" title="朴素贝叶斯算法的朴素一词解释"></a>朴素贝叶斯算法的朴素一词解释</h2><p><strong>那么这三个量是如何求得？</strong></p><p>是根据已知训练数据统计得来，下面详细给出该例子的求解过程。</p><p>回忆一下我们要求的公式如下：</p><p><img src="https://picbed.wuzhentao.com/AI/AI17.png" alt="image-20230301174938203"></p><p>那么我只要求得p(买维修工具、买杂志、买电影票、买电子游戏机 | 啤酒)、p(买维修工具、买杂志、买电影票、买电子游戏机)、p(啤酒)即可, 下面我分别求出这几个概率, 最后一比,就得到最终结果</p><p>p(买维修工具、买杂志、买电影票、买电子游戏机 | 啤酒) &#x3D; p(买维修工具 | 啤酒) * p(买杂志 | 啤酒) * p(买电影票 | 啤酒) * p(买电子游戏机 | 啤酒)</p><p><strong>分别统计后面几个概率，也就得到了左边的概率！</strong></p><p>等等，为什么这个成立呢？学过概率论的同学可能有感觉了，这个等式成立的条件需要特征之间相互独立吧！</p><p><strong>对的！这也就是为什么朴素贝叶斯分类有朴素一词的来源，朴素贝叶斯算法是假设各个特征之间相互独立，那么这个等式就成立了！</strong></p><p><strong>但是为什么需要假设特征之间相互独立呢？</strong></p><p>我们这么想，假如没有这个假设，那么我们对右边这些概率的估计其实是不可做的，这么说，我们这个例子有4个特征，其中维修工具包括{扳手，榔头}，杂志包括{体育，娱乐，花边}，电影票包括{流浪地球2，满江红，中国乒乓}，电子游戏机包括{Xbox，Ps5}，<strong>那么四个特征的联合概率分布总共是4维空间，总个数为2*3*3*2&#x3D;36个。</strong></p><p><strong>24个，计算机扫描统计还可以，但是现实生活中，往往有非常多的特征，每一个特征的取值也是非常之多，那么通过统计来估计后面概率的值，变得几乎不可做，这也是为什么需要假设特征之间独立的原因。</strong></p><p>假如我们没有假设特征之间相互独立，那么我们统计的时候，就需要在整个特征空间中去找，比如统计p(买维修工具、买杂志、买电影票、买电子游戏机 | 啤酒)</p><p><strong>我们就需要在啤酒的条件下，去找四种特征全满足分别是买维修工具，买杂志，买电影票，买电子游戏机人的个数，这样的话，由于数据的稀疏性，很容易统计到0的情况。 这样是不合适的。</strong></p><p>根据上面俩个原因，朴素贝叶斯法对条件概率分布做了条件独立性的假设，由于这是一个较强的假设，朴素贝叶斯也由此得名！这一假设使得朴素贝叶斯法变得简单，但有时会牺牲一定的分类准确率。</p><p>好的，上面我解释了为什么可以拆成分开连乘形式。那么下面我们就开始求解！</p><p>我们将上面公式整理一下如下：</p><p><img src="https://picbed.wuzhentao.com/AI/AI18.png" alt="image-20230301175047454"></p><p>下面我将一个一个的进行统计计算（<strong>在数据量很大的时候，根据中心极限定理，频率是等于概率的，这里只是一个例子，所以我就进行统计即可</strong>）。</p><p>p(啤酒) &#x3D; ?</p><p>首先我们整理训练数据中，啤酒的样本数如下：</p><p><img src="https://picbed.wuzhentao.com/AI/AI12.png" alt="image-20230301165827559"></p><p>则p(啤酒) &#x3D; 6 &#x2F; 12 (总样本数) &#x3D; 1&#x2F;2</p><p>统计满足样本数</p><p>p(买维修工具 | 啤酒)  &#x3D; 4 &#x2F; 6 &#x3D; 2 &#x2F; 3</p><p>p(买杂志 | 啤酒) &#x3D; 2 &#x2F; 6 &#x3D; 1 &#x2F; 3</p><p>p(买电影票| 啤酒) &#x3D; 1 &#x2F; 6</p><p>p(买电子游戏机 | 啤酒)  &#x3D; 5 &#x2F; 6</p><p><strong>下面开始求分母，p(买维修工具)，p（买杂志），p（买电影票），p（买电子游戏机）</strong></p><p><strong>统计样本如下：</strong></p><p><img src="https://picbed.wuzhentao.com/AI/AI13.png" alt="image-20230301171212701"></p><p><strong>买维修工具统计如上红色所示，占5个，那么p(买维修工具) &#x3D; 5 &#x2F;12</strong></p><p><strong>买杂志统计如上红色所示，占5个，那么p(买杂志) &#x3D; 5 &#x2F;12</strong></p><p><strong>买电影票统计如上红色所示，占6个，那么p(买杂志) &#x3D; 6 &#x2F;12 &#x3D; 1 &#x2F; 2</strong></p><p><strong>买电子游戏机统计如上红色所示，占7个，那么p(买杂志) &#x3D; 7 &#x2F;12</strong></p><p><strong>到这里，要求p(买维修工具、买杂志、买电影票、买电子游戏机 | 啤酒)的所需项全部求出来了，下面带入进去即可，</strong></p><p>&#x3D; ((2 &#x2F; 3 * 1 &#x2F; 3 * 1 &#x2F; 6 *  5 &#x2F; 6 )* 1 &#x2F; 2) &#x2F; (5 &#x2F; 12 * 5 &#x2F; 12 * 1 &#x2F; 2 * 7 &#x2F; 12)</p><p><strong>下面我们根据同样的方法来求p(买维修工具、买杂志、买电影票、买电子游戏机 | 口红)，完全一样的做法，为了方便理解，我这里也走一遍帮助理解。首先公式如下：</strong></p><p><img src="https://picbed.wuzhentao.com/AI/AI19.png" alt="image-20230301175138324"></p><p>这里与上面公式中，分母是一样的，于是我们分母不需要重新统计计算！</p><p>下面我也一个一个来进行统计计算，这里与上面公式中，分母是一样的，于是我们分母不需要重新统计计算！</p><p>p(口红) &#x3D; 6 &#x2F; 12 &#x3D; 1 &#x2F; 2</p><p>p(买维修工具|口红) &#x3D; ？统计满足条件的样本如下（<strong>红色为满足条件</strong>）：</p><p><img src="https://picbed.wuzhentao.com/AI/AI14.png" alt="image-20230301172234678"></p><p>p(买维修工具|口红) &#x3D; 1 &#x2F; 6</p><p>p(买杂志|口红) &#x3D; 3 &#x2F; 6 &#x3D; 1 &#x2F; 2</p><p>p(买电影票|口红) &#x3D; 5 &#x2F; 6</p><p>p(电子游戏机|口红) &#x3D; 2 &#x2F; 6 &#x3D; 1 &#x2F; 3</p><p>那么根据公式：</p><p><img src="https://picbed.wuzhentao.com/AI/AI20.png" alt="image-20230301175205912"></p><p>p(买维修工具、买杂志、买电影票、买电子游戏机 | 口红) &#x3D; </p><p>((1 &#x2F; 6 * 1 &#x2F; 2 * 5 &#x2F; 6 * 1 &#x2F; 3) * 1 &#x2F; 2 ) &#x2F;  (5 &#x2F; 12 * 5 &#x2F; 12 * 1 &#x2F; 2 * 7 &#x2F; 12)</p><p>两者分母相同而且 p(口红)、p（啤酒）概率相同， 只需要比较一部分分子</p><p><strong>很显然(2 &#x2F; 3 * 1 &#x2F; 3 * 1 &#x2F; 6 *  5 &#x2F; 6) &gt; (1 &#x2F; 6 * 1 &#x2F; 2 * 5 &#x2F; 6 * 1 &#x2F; 3)</strong></p><p><strong>所以我们根据朴素贝叶斯算法可以给所有东西都买的人推送啤酒</strong></p><p>题目换一下</p><p><img src="https://picbed.wuzhentao.com/AI/AI15.png" alt="image-20230301173301281"></p><p>同理</p><p>把买维修工具概率改为不买维修工具概率</p><p>求得p(不买维修工具 | 口红) * p(买杂志 | 口红) * p(买电影票 | 口红) * p(买电子游戏机 | 口红)</p><p> p(不买维修工具 | 啤酒) * p(买杂志 | 啤酒) * p(买电影票 | 啤酒) * p(买电子游戏机 | 啤酒)</p><p><strong>比较两者概率</strong></p><h2 id="朴素贝叶斯分类的优缺点"><a href="#朴素贝叶斯分类的优缺点" class="headerlink" title="朴素贝叶斯分类的优缺点"></a>朴素贝叶斯分类的优缺点</h2><p>优点：</p><p>（1） 算法逻辑简单,易于实现</p><p>（2）分类过程中时空开销小</p><p>缺点：</p><p>理论上，<strong>朴素贝叶斯模型与其他分类方法相比具有最小的误差率。但是实际上并非总是如此，这是因为朴素贝叶斯模型假设属性之间相互独立，这个假设在实际应用中往往是不成立的，在属性个数比较多或者属性之间相关性较大时，分类效果不好。</strong></p><p>而在属性相关性较小时，朴素贝叶斯性能最为良好。对于这一点，有半朴素贝叶斯之类的算法通过考虑部分关联性适度改进。</p><h2 id="拉普拉斯平滑系数"><a href="#拉普拉斯平滑系数" class="headerlink" title="拉普拉斯平滑系数"></a>拉普拉斯平滑系数</h2><p>受训练数据集规模的限制，某个属性的取值可能在训练集中从未与某个类同时出现，这就可能导致属性条件概率为0，些时直接使用朴素贝叶斯分类就会导致错误的结论。</p><p>拉普拉斯平滑就是计算类先验概率和属性条件概率时，在分子上添加一个较小的修正量，在分母上则添加这个修正量与分类数目的乘积，避免了零概率对分类结果的影响。</p><blockquote><p>操作</p></blockquote><p>在计算时分子递增 <code>1</code>,而分母加上训练集总的分数类</p><p>这样就保证在偏差不大的情况下去除了<code>0</code>值的问题</p><h2 id="朴素贝叶斯算法的不同方法"><a href="#朴素贝叶斯算法的不同方法" class="headerlink" title="朴素贝叶斯算法的不同方法"></a>朴素贝叶斯算法的不同方法</h2><ul><li>贝努利朴素贝叶斯</li><li>高斯贝叶斯</li><li>多项式朴素贝叶斯</li></ul><h3 id="伯努利朴素贝叶斯（Bernoulli-Naive-Bayes）"><a href="#伯努利朴素贝叶斯（Bernoulli-Naive-Bayes）" class="headerlink" title="伯努利朴素贝叶斯（Bernoulli Naive Bayes）"></a>伯努利朴素贝叶斯（Bernoulli Naive Bayes）</h3><blockquote><p>这种方法适用于符合伯努利分布的数据集</p></blockquote><p>伯努利分布也被称作”二项分布”或者”0 - 1分布”</p><p>抛硬币只有两种结果,符合伯努利分布, 这种情况下适用伯努利</p><p>如果遇到更加复杂的数据集就不适用了</p><p>案例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sklearn.datasets.make_blobs () 是用于创建多类单标签数据集的函数，它为每个类分配一个或多个正态分布的点集。</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X, y = make_blobs(n_samples = <span class="number">500</span>, centers = <span class="number">5</span>, random_state = <span class="number">8</span>)<span class="comment">#生成一个5分类数据集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state = <span class="number">8</span>)</span><br><span class="line">nb = BernoulliNB()<span class="comment">#贝努利贝叶斯</span></span><br><span class="line">nb.fit(X_train, y_train)<span class="comment">#训练</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型得分:&#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(nb.score(X_test, y_test)))<span class="comment">#得分</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模型得分:0.544</span><br></pre></td></tr></table></figure><p>我们会发现伯努利朴素贝叶斯在5个分类上的分类结果就不是很好</p><h3 id="高斯朴素贝叶斯-Gaussian-naive-bayes"><a href="#高斯朴素贝叶斯-Gaussian-naive-bayes" class="headerlink" title="高斯朴素贝叶斯(Gaussian naive bayes)"></a>高斯朴素贝叶斯(Gaussian naive bayes)</h3><p>顾名思义是假设样本的特征符合高斯分布或者正态分布所用的算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line">gnb = GaussianNB()</span><br><span class="line">gnb.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型得分:&#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(gnb.score(X_test, y_test)))<span class="comment">#得分</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模型得分:0.968</span><br></pre></td></tr></table></figure><p>高斯朴素贝叶斯可以胜任大部分的分类任务</p><p>因为在自然科学和社会科学领域有大量现象都是呈现正态分布的</p><h3 id="多项式朴素贝叶斯"><a href="#多项式朴素贝叶斯" class="headerlink" title="多项式朴素贝叶斯"></a>多项式朴素贝叶斯</h3><p>用于拟合多项式分布的数据集</p><p>例如掷骰子,每次掷一次会得到 <code>1~6</code>中的一个数,如果掷n次, <code>1~6</code>每个数出现的次数分布情况,就是一个多项式分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line">scaler = MinMaxScaler()<span class="comment">#把数据变为非负值</span></span><br><span class="line">scaler.fit(X_train)</span><br><span class="line">X_train_scaled = scaler.transform(X_train)</span><br><span class="line">X_test_scaled = scaler.transform(X_test)</span><br><span class="line"></span><br><span class="line">mnb = MultinomialNB()</span><br><span class="line">mnb.fit(X_train_scaled, y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;模型得分:&#123;:.3f&#125;&#x27;</span>.<span class="built_in">format</span>(mnb.score(X_test_scaled, y_test)))<span class="comment">#得分</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">模型得分:0.320</span><br></pre></td></tr></table></figure><h3 id="MinMaxScaler"><a href="#MinMaxScaler" class="headerlink" title="MinMaxScaler"></a>MinMaxScaler</h3><p><code>MinMaxScaler</code>本质上就是归一化</p><p><img src="https://picbed.wuzhentao.com/AI/AI22.png" alt="wenjian"></p><p>用朴实的语言描述一下上面公式所做的事：</p><ol><li>第一步求每个列中元素到最小值距离占该列最大值和最小值距离的比例，这实际上已经是将数据放缩到了[0,1]区间上</li><li>第二步将标准化的数据映射到给定的<code>[min,max]</code>区间</li></ol><p>给个例子</p><ul><li><p>X: 要归一化的数据，通常是二维矩阵</p></li><li><p>[[4, 2, 3],[1, 5, 6]]</p></li><li><p>X.min(axis&#x3D;0)：每列中的最小值组成的行向量，如上面的例子中应该是<code>[1,2,3]</code></p></li><li><p>X.max(axis&#x3D;0)：每列中的最大值组成的行向量，如上面的例子中应该是[4,5,6]</p></li><li><p>max: 要映射到的区间最大值，默认是1</p></li><li><p>min：要映射到的区间最小值，默认是0</p></li><li><p>X<del>std</del> : 标准化结果</p></li><li><p>X<del>scaled</del> : 归一化结果</p></li></ul><blockquote><p>归一化实现</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">data = np.array([[<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                [<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动归一化</span></span><br><span class="line">feature_range = [<span class="number">0</span>,<span class="number">1</span>]  <span class="comment"># 要映射的区间</span></span><br><span class="line"><span class="built_in">print</span>(data.<span class="built_in">min</span>(axis=<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span>(data.<span class="built_in">max</span>(axis=<span class="number">0</span>))</span><br><span class="line">x_std = (data-data.<span class="built_in">min</span>(axis=<span class="number">0</span>))/(data.<span class="built_in">max</span>(axis=<span class="number">0</span>)-data.<span class="built_in">min</span>(axis=<span class="number">0</span>))</span><br><span class="line">x_scaled = x_std*(feature_range[<span class="number">1</span>]-feature_range[<span class="number">0</span>]) + feature_range[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;手动归一化结果：\n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(x_scaled))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动归一化</span></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;自动归一化结果:\n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(scaler.fit_transform(data)))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">手动归一化结果:</span><br><span class="line">[[1, 0, 0],</span><br><span class="line">[0, 1, 1]]</span><br><span class="line">自动归一化结果:</span><br><span class="line">[[1, 0, 0],</span><br><span class="line">[0, 1, 1]]</span><br></pre></td></tr></table></figure><p>再简要说一下<code>sklearn.preprocessing.MinMaxScaler</code>的用法</p><ol><li>初始化一个<code>MinMaxScaler</code>对象：<code>scaler = MinMaxScaler()</code></li><li>拟合并转换数据，本质上就是先求最大最小值，然后对数据按照公式计算：<code>scaler.fit_transform(data)</code></li></ol><p><code>MinMaxScaler</code>本质上是将数据点映射到了<code>[0,1]</code>区间（默认），但实际使用的的时候也不一定是到<code>[0,1]</code>，你也可以指定参数<code>feature_range</code>，映射到其他区间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scaler2 = MinMaxScaler(feature_range=[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;自动归一化结果:\n&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(scaler2.fit_transform(data)))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">自动归一化结果:</span><br><span class="line">[[2, 1, 1],</span><br><span class="line">[1, 2, 2]]</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>高斯朴素贝叶斯适用于特征呈正态分布的，</strong></li><li><strong>多项式贝叶斯适用于特征是多项式分布的，</strong></li><li><strong>伯努利贝叶斯适用于二项分布。</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA教程</title>
      <link href="/post/7b64386an.html"/>
      <url>/post/7b64386an.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="JAVA的三大版本"><a href="#JAVA的三大版本" class="headerlink" title="JAVA的三大版本"></a>JAVA的三大版本</h2><p><strong>JAVA最大的特点：</strong></p><p>Java的主要优势在于其做出的WORA：即一次编写（Write Once）、随处运行（Run Anywhere）。简 单来讲，这意味着开发团队能够利用Java编写一款应用程序，并将其编译为可执行形式，而后将其运行 在任何支持Java的平台之上。这显然能够极大提高编程工作的实际效率，这种优势来源于Java Virtual Machine(JAVA虚拟机的缩写)，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在 实际的计算机上仿真模拟各种计算机功能来实现的。JAVA语言的一个非常重要的特点就是与平台的无关 性，而使用Java虚拟机是实现这一特点的关键。</p><p><strong>JAVA的三大版本：</strong></p><ol><li>JAVA SE：它是JAVA的标准版，是整个JAVA的基础和核心，这是我们主要学习的一个部分，也是 JAVAEE和JAVAME技术的基础，主要用于开发桌面应用程序。学会后可以做一些简单的桌面应用 如：扫雷，连连看等。 </li><li>JAVA ME：它是JAVA的微缩版，主要应用于嵌入式开发，比如手机程序的开发。目前来说就业范围 不是很广，在一些城市可能相对的不好找工作。 </li><li>JAVA EE：也叫JAVA的企业版，它提供了企业级应用开发的完整解决方案，比如开发网站，还有企 业的一些应用系统，是JAVA技术应用最广泛的领域。主要还是偏向于WEB的开发，而JAVA EE的基 础就是JAVA SE，所以我们在学习JAVA SE的时候，基础一定要打好，因为这是最基本的，也是最核 心的。</li></ol><p><img src="https://picbed.wuzhentao.com/blog/java1.png" alt="p1.png (3840×2160) (wuzhentao.com)"></p><h2 id="JDK-和-KRE"><a href="#JDK-和-KRE" class="headerlink" title="JDK 和 KRE"></a>JDK 和 KRE</h2><p>**JDK: **</p><p>Java 2 SDK (Development Kit)包含：JRE的超集，包含编译器和调试器等用于程序开发的文件</p><p><strong>JRE:</strong></p><p>Java Runtime Environment (JRE) 包含：Java虚拟机、库函数、运行Java应用程序和Applet所必须文件</p><p>Java运行环境的三项主要功能：</p><ul><li>加载代码: 由class loader完成</li><li>校验代码：由bytecode verifier 完成； </li><li>执行代码：由 runtime interpreter完成。</li></ul><p><strong>区别和联系</strong></p><p>sdk（也就是jdk）是jre的超集，是在jre的基础上增加了编译器及其他一些开发工具。 </p><p>jre就是java运行时环境，包括了jvm和其它一些java核心api,任何一台电脑，只有安装了jre才可以运行 java程序. </p><p>如果只是要运行JAVA程序，之需要JRE就可以。 </p><p>JRE通常非常小，也包含了JVM. 如果要开发JAVA程序，就需要安装JDK。</p><h2 id="初时JVM-JAVA-Virtual-Machine"><a href="#初时JVM-JAVA-Virtual-Machine" class="headerlink" title="初时JVM(JAVA Virtual Machine)"></a>初时JVM(JAVA Virtual Machine)</h2><p>JVM是一种规范，可以使用软件来实现，也可以使用硬件来实现，就是一个虚拟的用于执行bytecodes 字节码的计算机。他也定义了指令集、寄存器集、结构栈、垃圾收集堆、内存区域。</p><p> JVM负责将java字节码解释运行，边解释边运行，这样，速度就会受到一定的影响。JAVA提供了另一种 解释运行的方法JIT（just in time），可以一次解释完，再运行特定平台上的机器码，高级的JIT可以只能 分析热点代码，并将这些代码转成本地机器码，并将结果缓存起来，下次直接从内存中调用，这样就大 大提高了执行JAVA代码的效率。这样就实现了跨平台、可移植的功能。</p><ol><li>. JVM是指在一台计算机上由软件或硬件模拟的计算机；它类似一个小巧而高效的CPU。</li><li>byte-code代码是与平台无关的是虚拟机的机器指令。</li><li>. java字节代码运行的两种方式:</li></ol><ul><li>方式interpreter(解释)</li><li>Just-in-time(即时编译):由代码生成器将字节代码转换成本机的机器代码,然后可以以较高速度执行。</li><li>JAVA的跨平台实现的核心是不同平台使用不同的虚拟机 不同的操作系统有不同的虚拟机。</li><li>Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，随处 运行”</li></ul><h2 id="编写-Java-程序时，应注意以下几点："><a href="#编写-Java-程序时，应注意以下几点：" class="headerlink" title="编写 Java 程序时，应注意以下几点："></a>编写 Java 程序时，应注意以下几点：</h2><ul><li><strong>大小写敏感：</strong>Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。 </li><li><strong>类名：</strong>对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首 字母应该大写，例如 MyFirstJavaClass 。 </li><li><strong>方法名：</strong>所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字 母大写。 </li><li><strong>源文件名：</strong>源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 .java。（如果文件名和类名不相同则会导致编译错 误）。 </li><li><strong>主方法入口：</strong>所有的 Java 程序由<code> public static void main(String []args)</code> 方法开始执行。</li></ul><h2 id="JAVA程序运行机制"><a href="#JAVA程序运行机制" class="headerlink" title="JAVA程序运行机制"></a>JAVA程序运行机制</h2><p>计算机的高级编程语言类型: 编译型 ，解释型. Java 语言是两种类型的结合；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从字面上看，“编译”和“解释”的确都有“翻译”的意思，它们的区别则在于翻译的时机安排不大一样。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们先看看编译型:有一个负责翻译的程序来对我们的源代码进行转换，生成相对应的可执行代码。这个过程说得专业一点，就称为编译（Compile），而负责编译的程序自然就称为编译器Compiler）。就类似于把一本中文书直接翻译成英文版进行出售。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在再看看解释型：打个比方：假如你打算阅读一本外文书，而你不知道这门外语，那么你可以找一名翻译，给他足够的时间让他从头到尾把整本书翻译好，然后把书的母语版交给你阅读（编译型）；或者，你也立刻让这名翻译辅助你阅读，让他一句一句给你翻译，如果你想往回看某个章节，他也得重新给你翻译。（解释型）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译型与解释型，两者各有利弊。前者由于程序执行速度快，同等条件下对系统要求较低，因此像开发操作系统、大型应用程序、数据库系统等时都采用它，像C/C++、Pascal/ObjectPascal（Delphi）、VB等基本都可视为编译语言，而一些网页脚本、服务器脚本及辅助开发接口这样的对速度要求不高、对不同系统平台间的兼容性有一定要求的程序则通常使用解释性语言，如Java、JavaScript、VBScript、Perl、Python等等。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//Java语言虽然比较接近解释型语言的特征，但在执行之前已经预先进行一次预编译，生成的代码是介于机器码和Java源代码之间的中介代码，运行的时候则由JVM（Java的虚拟机平台，可视为解释器）解释执行。它既保留了源代码的高抽象、可移植的特点，又已经完成了对源代码的大部分预编译工作，所以执行起来比“纯解释型”程序要快许多。</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//总之，随着设计技术与硬件的不断发展，编译型与解释型两种方式的界限正在不断变得模糊。</span></span><br></pre></td></tr></table></figure><p><strong>第一步:编译</strong></p><p>利用编译器(javac)源程序编译成字节码,字节码文件名：源文件名.class</p><p><strong>第二步:运行</strong></p><p>利用虚拟机（解释器，java）解释执行class字节码文件。</p><p><img src="https://picbed.wuzhentao.com/blog/java2.png"></p><h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释并不会被执行，是给我们写代码的人看的，书写注释是一个非常好的习惯，在很多大公司都是强制 要求各位去进行编写注释！。</p><p>我们来看一下Java中的注释怎么写，看以下代码：</p><p>java中的注释有三种:</p><p><strong>单行注释:</strong></p><p>只能注释当前行, 以<code>//</code>开始,知道行结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出HelloWorld</span></span><br></pre></td></tr></table></figure><p><strong>多行注释:</strong></p><p>注释一段文字,以<code>/*</code>开始,<code>*/</code>结束!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>文档注释:</strong></p><p>用于生产API文档, 配合javaDoc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @Description HelloWorld类</span></span><br><span class="line"><span class="comment">* @Author Diamond 吴稳健QQ:1023217219</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>平时写代码一定要注意注释的规范性，一个好的程序员，一定是有非常良好的编码习惯 的，我希望大家能够从小事开始锻炼自己的行为习惯！</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>JAVA自己定义好的<strong>关键字</strong></p><table><thead><tr><th>abstract</th><th>assert</th><th>boolean</th><th>break</th><th>byte</th></tr></thead><tbody><tr><td>case</td><td>catch</td><td>char</td><td>class</td><td>const</td></tr><tr><td>continue</td><td>default</td><td>do</td><td>double</td><td>else</td></tr><tr><td>for</td><td>goto</td><td>long</td><td>if</td><td>goto</td></tr><tr><td>native</td><td>public</td><td>void</td><td>try</td><td>switch</td></tr><tr><td>new</td><td>int</td><td>this</td><td>finally</td><td>return</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>还有很多就不一一赘述了，这些关键字也不需要刻意去记忆，只需要知道我们不能拿关键字当作变量名使用就行了</p><p>JAVA所有组成部分都需要名字，类名、变量名以及方法名都被称为<strong>标识符</strong></p><p>表示类名的标识符单词第一个字母用大写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如:Man,CoodMan</span><br></pre></td></tr></table></figure><p>表示方法和变量的表示符用驼峰命名法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如:eatFood()</span><br></pre></td></tr></table></figure><blockquote><p>关于Java标识符,有以下几点需要注意</p></blockquote><ul><li>所有标识符都应该以字母(A-Z或者a-z), 美元符($), 或者下划线( _ )开始</li><li>不能用关键字</li><li>对大小写敏感</li><li>合法标识符举例:age、$salary、_value、__1_value</li><li>非法标识符举例: 123abc、-salary、#abc</li></ul><blockquote><p>注意:</p></blockquote><p>JAVA不采用通常语言使用的ASCII字符集, 而是使用unicode这样的标准国际字符集. 因此可以使用中文命名,但是一般不建议这样去做, 也不建议使用拼音, 很Low</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">String 王者荣耀 = <span class="string">&quot;最强王者&quot;</span>;</span><br><span class="line">System.out.println(王者荣耀);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="强弱类型语言"><a href="#强弱类型语言" class="headerlink" title="强弱类型语言"></a>强弱类型语言</h3><ol><li><p>强类型语言也称为强类型定义语言。</p><ul><li>要求变量的使用要严格符合规定，所有变量都必须先定义后才能使 用。 Java、.NET、C++等都是强制类型定义的。</li><li>也就是说，一旦一个变量被指定了某个数据类型，如果 不经过转换，那么它就永远是这个数据类型了。 </li><li>安全性高，运行效率相对较慢，鱼和熊掌不可兼得！强类型定义语言在速度上可能略逊色于弱类型定义 语言，但是强类型定义语言带来的严谨性能够有效的避免许多错误。</li></ul></li><li><p>弱类型语言也称为弱类型定义语言。</p><ul><li>与强类型定义相反。像vb，php等就属于弱类型语言·</li><li>在VBScript中，可以将字符串‘12’和整数3进行连接得到字符串‘123’，也可以把它看成整数123，而不需 要显示转换。是不是十分的随便，我们Java就不是这样的。</li><li>但其实它们的类型没有改变，VB只是在判断出一个表达式含有不同类型的变量之后，自动在这些变 量前加了一个clong（）或（int）（）这样的转换函数而已。能做到这一点其实是归功于VB的编译器的 智能化而已，这并非是VB语言本身的长处或短处</li></ul></li></ol><h2 id="JAVA的数据类型"><a href="#JAVA的数据类型" class="headerlink" title="JAVA的数据类型"></a>JAVA的数据类型</h2><p>java的数据类型分为两大类: **基本类型(primitive type) **和 <strong>引用类型(reference type)</strong></p><p><img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20230317142835617.png" alt="image-20230317142835617"></p><p><img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20230317142846262.png" alt="image-20230317142846262"></p><p>如果你看到这一堆头疼的话，没关系，不用记，JDK中类型对应的包装类都帮忙写好了，我们需要时候可 以直接看到！可以把以下代码拷贝进行查看结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">// byte</span></span><br><span class="line">System.out.println(<span class="string">&quot;基本类型：byte 二进制位数：&quot;</span> + Byte.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;包装类：java.lang.Byte&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;最小值：Byte.MIN_VALUE=&quot;</span> + Byte.MIN_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;最大值：Byte.MAX_VALUE=&quot;</span> + Byte.MAX_VALUE);</span><br><span class="line">System.out.println();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// short</span></span><br><span class="line">System.out.println(<span class="string">&quot;基本类型：short 二进制位数：&quot;</span> + Short.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;包装类：java.lang.Short&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;最小值：Short.MIN_VALUE=&quot;</span> + Short.MIN_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;最大值：Short.MAX_VALUE=&quot;</span> + Short.MAX_VALUE);</span><br><span class="line">System.out.println();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// int</span></span><br><span class="line">System.out.println(<span class="string">&quot;基本类型：int 二进制位数：&quot;</span> + Integer.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;包装类：java.lang.Integer&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;最小值：Integer.MIN_VALUE=&quot;</span> + Integer.MIN_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;最大值：Integer.MAX_VALUE=&quot;</span> + Integer.MAX_VALUE);</span><br><span class="line">System.out.println();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// long</span></span><br><span class="line">System.out.println(<span class="string">&quot;基本类型：long 二进制位数：&quot;</span> + Long.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;包装类：java.lang.Long&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;最小值：Long.MIN_VALUE=&quot;</span> + Long.MIN_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;最大值：Long.MAX_VALUE=&quot;</span> + Long.MAX_VALUE);</span><br><span class="line">System.out.println();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// float</span></span><br><span class="line">System.out.println(<span class="string">&quot;基本类型：float 二进制位数：&quot;</span> + Float.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;包装类：java.lang.Float&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;最小值：Float.MIN_VALUE=&quot;</span> + Float.MIN_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;最大值：Float.MAX_VALUE=&quot;</span> + Float.MAX_VALUE);</span><br><span class="line">System.out.println();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// double</span></span><br><span class="line">System.out.println(<span class="string">&quot;基本类型：double 二进制位数：&quot;</span> + Double.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;包装类：java.lang.Double&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;最小值：Double.MIN_VALUE=&quot;</span> + Double.MIN_VALUE);</span><br><span class="line">System.out.println(<span class="string">&quot;最大值：Double.MAX_VALUE=&quot;</span> + Double.MAX_VALUE);</span><br><span class="line">System.out.println();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// char</span></span><br><span class="line">System.out.println(<span class="string">&quot;基本类型：char 二进制位数：&quot;</span> + Character.SIZE);</span><br><span class="line">System.out.println(<span class="string">&quot;包装类：java.lang.Character&quot;</span>);</span><br><span class="line"><span class="comment">// 以数值形式而不是字符形式将Character.MIN_VALUE输出到控制台</span></span><br><span class="line">System.out.println(<span class="string">&quot;最小值：Character.MIN_VALUE=&quot;</span></span><br><span class="line">+ (<span class="type">int</span>) Character.MIN_VALUE);</span><br><span class="line"><span class="comment">// 以数值形式而不是字符形式将Character.MAX_VALUE输出到控制台</span></span><br><span class="line">System.out.println(<span class="string">&quot;最大值：Character.MAX_VALUE=&quot;</span></span><br><span class="line">+ (<span class="type">int</span>) Character.MAX_VALUE);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="科普字节相关知识"><a href="#科普字节相关知识" class="headerlink" title="科普字节相关知识"></a>科普字节相关知识</h3><ol><li>位（bit）：是计算机 内部数据 储存的最小单位，11001100是一个八位二进制数。 </li><li>字节（byte）：是计算机中 数据处理 的基本单位，习惯上用大写 B 来表示, 1B（byte,字节）&#x3D; 8bit（位） 字符：是指计算机中使用的字母、数字、字和符号</li></ol><p>ASCIIS码:</p><ul><li>1个英文字母（不分大小写）&#x3D; 1个字节的空间 </li><li>1个中文汉字 &#x3D; 2个字节的空间 </li><li>1个ASCII码 &#x3D; 一个字节</li></ul><p>UTF-8编码：</p><ul><li><p>1个英文字符 &#x3D; 1个字节</p></li><li><p>英文标点 &#x3D; 1个字节 </p></li><li><p>1个中文（含繁体） &#x3D; 3个字节 </p></li><li><p>中文标点 &#x3D; 3个字节</p></li></ul><p>Unicode编码： </p><ul><li>1个英文字符 &#x3D; 2个字节 </li><li>英文标点 &#x3D; 2个字节 </li><li>1个中文（含繁体） &#x3D; 2个字节</li><li>中文标点 &#x3D; 2个字节</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1bit表示1位， </span><br><span class="line"></span><br><span class="line">1Byte表示一个字节 1B=8b。 </span><br><span class="line"></span><br><span class="line">1024B=1KB 1024KB=1M </span><br><span class="line"></span><br><span class="line">1024M=1G.</span><br><span class="line">32位操作系统只可以使用32位的cpu，而64位的CPU既可以安装32位操作系统也可以安装64位操作系统。</span><br><span class="line"></span><br><span class="line">寻址能力简单点说就是支持的内存大小能力，64位系统最多可以支达128 GB的内存，而32位系统最多只可以支持4G内存。</span><br><span class="line"></span><br><span class="line">32位操作系统只可以安装使用32位架构设计的软件，而64位的CPU既可以安装使用32位软件也可以安装使用64位软件。</span><br><span class="line"></span><br><span class="line">现在的电脑都是64位了！</span><br></pre></td></tr></table></figure><h2 id="整型拓展"><a href="#整型拓展" class="headerlink" title="整型拓展"></a>整型拓展</h2><p>在我们计算机中存在很多进制问题，十进制，八进制，十六进制等等的问题，他们怎么表示呢？</p><ol><li>十进制整数，如：99, -500, 0。</li><li>八进制整数，要求以 0 开头，如：015。</li><li>十六进制数，要求 0x 或 0X 开头，如：0x15 。</li><li>二进制整数,  0b开头</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//整型</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> i2=<span class="number">010</span>;</span><br><span class="line"><span class="type">int</span> i3=<span class="number">0x10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">0b0101</span>：</span><br><span class="line">System.out.println(i); <span class="comment">//10</span></span><br><span class="line">System.out.println(i2); <span class="comment">//8</span></span><br><span class="line">System.out.println(i3); <span class="comment">//16</span></span><br><span class="line">System.out.println(i4); <span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>在实际开发和学习中，如果遇到特别长的数字，读懂它令人头疼！JDK7为我们提供了下划线分隔符，可 以按照自己的习惯进行分割。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1_2234_5678</span>;</span><br></pre></td></tr></table></figure><p>我们很容易就知道这是1亿2234万5678啦！ 非常符合国人的习惯！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0b0101</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1_2345_7893</span>;</span><br><span class="line">System.out.println(a); <span class="comment">//5</span></span><br><span class="line">System.out.println(b); <span class="comment">//123457893</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浮点型拓展"><a href="#浮点型拓展" class="headerlink" title="浮点型拓展"></a>浮点型拓展</h2><p>提问: 银行金融业务用的什么类型表示?</p><ul><li><p>浮点类型float, double的数据不适合在不容许舍入误差的金融计算领域。</p></li><li><p>如果需要进行不产生舍入误差的精确数字计算，需要使用<code>BigDecimal</code>类。</p></li></ul><p>由于字长有限，浮点数能够精确表示的数是有限的，因而也是离散的。浮点数一般都存在舍入误差，很 多数字无法精确表示，其结果只能是接近，但不等于;</p><p><strong>大数值</strong>：<code>Java.math</code>下面的两个有用的类：<code>BigInteger</code>和<code>BigDecimal</code>，这两个类可以处理任意长度的数 值。<code>BigInteger</code>实现了任意精度的整数运算。<code>BigDecimal</code>实现了任意精度的浮点运算。</p><p>用法可以自行百度搜索</p><blockquote><p>浮点数使用总结： </p></blockquote><ol><li>默认是double</li><li>浮点数存在舍入误差，很多数字不能精确表示。如果需要进行不产生舍入误差的精确数字计算，需要使用BigDecimal类。 </li><li>避免比较中使用浮点数</li></ol><h2 id="字符型拓展"><a href="#字符型拓展" class="headerlink" title="字符型拓展"></a>字符型拓展</h2><p>单引号用来表示字符常量。例如‘A’是一个字符，它与“A”是不同的，“A”表示一个字符串。</p><p>char 类型用来表示在Unicode编码表中的字符。.</p><p> Unicode编码被设计用来处理各种语言的所有文字，它占2个字节，可允许有65536个字符； </p><p>【科普：2字节&#x3D;16位, 2的16次方&#x3D;65536，我们用的Excel原来就只有这么多行，并不是无限的】</p><p>演示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">System.out.println(c1);</span><br><span class="line">System.out.println((<span class="type">int</span>) c1); <span class="comment">//97</span></span><br><span class="line">System.out.println(c2);</span><br><span class="line">System.out.println((<span class="type">int</span>) c2); <span class="comment">//20013</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unicode具有从0到65535之间的编码，他们通常用从’u0000’到’uFFFF’之间的十六进制值来表示（前缀为 u表示Unicode）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;\u0061&#x27;</span>;</span><br><span class="line">System.out.println(c3); <span class="comment">//a</span></span><br></pre></td></tr></table></figure><p>Java 语言中还允许使用转义字符 ‘’ 来将其后的字符转变为其它的含义，有如下常用转义字符：</p><p><img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20230317144437604.png" alt="image-20230317144437604"></p><h2 id="布尔型拓展"><a href="#布尔型拓展" class="headerlink" title="布尔型拓展"></a>布尔型拓展</h2><p>boolean类型（一位，不是一个字节），就是0 | 1 ,boolean类型有两个值，true和false,不可以 0 或非 0 的整数替代 true 和 false ，这点和C语言不同。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>由于Java是强类型语言，所以要进行有些运算的时候的，需要用到类型转换。 </p><p>整型、实型（常量）、字符型数据可以混合运算。</p><p> 运算中，不同类型的数据先转化为同一类型，然后进行运算。</p><p> 转换从低级到高级（根据容量来看）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低 ------------------------------------&gt; 高</span><br><span class="line"><span class="type">byte</span>,<span class="type">short</span>,<span class="type">char</span>—&gt; <span class="type">int</span> —&gt; <span class="type">long</span>—&gt; <span class="type">float</span> —&gt; <span class="type">double</span></span><br></pre></td></tr></table></figure><p>数据类型转换必须满足如下规则：</p><ul><li>不能对boolean类型进行类型转换。 </li><li>不能把对象类型转换成不相关类的对象。 </li><li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。 转</li><li>换过程中可能导致溢出或损失精度，例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">128</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i;</span><br></pre></td></tr></table></figure><p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p><p>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">int</span>)<span class="number">23.7</span> == <span class="number">23</span>;</span><br><span class="line">(<span class="type">int</span>)-<span class="number">45.89f</span> == -<span class="number">45</span></span><br></pre></td></tr></table></figure><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>自动类型转换：容量小的数据类型可以自动转换为容量大的数据类型。</p><p>例如: short数据类型的位数为16位，就可以自动转换位数为32的int类型，同样float数据类型的位数为 32，可以自动转换为64位的double类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZiDongLeiZhuan</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">char</span> c1=<span class="string">&#x27;a&#x27;</span>;<span class="comment">//定义一个char类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> c1;<span class="comment">//char自动类型转换为int</span></span><br><span class="line">System.out.println(<span class="string">&quot;char自动类型转换为int后的值等于&quot;</span>+i1);</span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;<span class="comment">//定义一个char类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> c2+<span class="number">1</span>;<span class="comment">//char 类型和 int 类型计算</span></span><br><span class="line">System.out.println(<span class="string">&quot;char类型和int计算后的值等于&quot;</span>+i2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>强制类型转换，又被称为造型，用于显式的转换一个数值的类型. </p><p>在有可能丢失信息的情况下进行的转换是通过造型来完成的，但可能造成精度降低或溢出。 </p><p>强制类型转换的语法格式：<code>(type)var </code>，运算符“()”中的type表示将值var想要转换成的目标数据类 型。 条件是转换的数据类型必须是兼容的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> (<span class="type">int</span>)x; <span class="comment">//值为3</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> c+<span class="number">1</span>;</span><br><span class="line">System.out.println(d); <span class="comment">//98</span></span><br><span class="line">System.out.println((<span class="type">char</span>)d); <span class="comment">//b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当将一种类型强制转换成另一种类型，而又超出了目标类型的表示范围，就会被截断成为一个完全不同 的值，溢出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">bx</span> <span class="operator">=</span> (<span class="type">byte</span>)x; <span class="comment">//值为44</span></span><br><span class="line">System.out.println(bx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【Java语言的整型常数默认为int型，浮点数默认是Double】</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows批处理</title>
      <link href="/post/3c6d5df9.html"/>
      <url>/post/3c6d5df9.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>什么是批处理程序？</p></blockquote><p>Batch file programming 是微软操作系统自带原生的开发语言，不需要构建任何环境就可以执行的脚本</p><p>Batch file 批处理文件使用 cmd.exe 执行</p><blockquote><p>如何使用批处理程序?</p></blockquote><p>使用任何文本编译器</p><blockquote><p>批处理程序可以做什么?</p></blockquote><p>使用一系列内置命令进行自动化操作</p><p>例如:</p><ul><li>匹配规则删除文件</li><li>新建文件,日志等</li><li>甚至可以批量创建计算机病毒</li></ul><h1 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h1><p>输出 hello world</p><p>可以使用记事本只需要修改后缀</p><p><img src="https://picbed.wuzhentao.com/blog/w1.png" alt="w1.png (485×194) (wuzhentao.com)"></p><p>写入</p><p><img src="https://picbed.wuzhentao.com/blog/w2.png" alt="w1.png (485×194) (wuzhentao.com)"></p><p>输出</p><p><img src="https://picbed.wuzhentao.com/blog/w3.png" alt="w1.png (485×194) (wuzhentao.com)"></p><blockquote><p>语法</p></blockquote><p>echo 显示消息<br>echo on 启用命令回显<br>echo off 表示下面的指令都只执行而不显示，直到再次出现 echo on 时；<br>@echo 表示让@后面的命令不显示，@本身也不显示；</p><p>pause 暂停</p><p>bat 文件运行完后后会直接关闭,写入 pause 可以停留在屏幕</p><h1 id="批处理运算操作"><a href="#批处理运算操作" class="headerlink" title="批处理运算操作"></a>批处理运算操作</h1><h3 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h3><ul><li>加+</li><li>减-</li><li>&#x2F;除</li><li>乘*</li><li>取余%</li></ul><blockquote><p>在命令模式下执行</p></blockquote><p>就是在 cmd 黑框里执行</p><p>需要先加上 set &#x2F;a 大小写随意</p><p><img src="https://picbed.wuzhentao.com/blog/w4.png" alt="w1.png (485×194) (wuzhentao.com)"></p><blockquote><p>文本模式下执行</p></blockquote><p>命令模式下一次只能执行一次</p><p>如果需要反复执行可以编辑到文本格式中</p><p><img src="https://picbed.wuzhentao.com/blog/w5.png" alt="w1.png (485×194) (wuzhentao.com)"></p><p>将结果保存到变量 var 中， 变量名命名和 python 大体一样</p><p>输出变量需要用<code>%</code>进行分割</p><blockquote><p>分组优先级</p></blockquote><p>一句话概括</p><p><code>()</code>里的先算</p><h3 id="重定向运算"><a href="#重定向运算" class="headerlink" title="重定向运算"></a>重定向运算</h3><p>重定向代表的是某条命令执行的结果会添加或移交给下一个执行命令</p><p>简单点说就是这个程序运行的结果会保存到另一个文件中</p><p>运算符号:</p><ul><li><p><code>&gt;</code>会覆盖原有的内容</p></li><li><p><code>&gt;&gt;</code>不会覆盖之前的内容,会追加文件内容到原本文件中</p></li><li><p>&lt;右边文本文件内容覆盖左边的文本文件</p></li><li><p>&lt;&lt;</p></li><li><p>关系运算</p><ul><li>&lt;小于</li><li><code>&gt;</code>大于</li></ul></li></ul><p><img src="https://picbed.wuzhentao.com/blog/w6.png" alt="w1.png (485×194) (wuzhentao.com)"></p><p>会在目录下生成一个 a.txt 文件</p><p>里面的内容是 hello world</p><p><img src="https://picbed.wuzhentao.com/blog/w7.png" alt="w1.png (485×194) (wuzhentao.com)"></p><p>type 用来查看文本文件内容</p><h3 id="多命令运算"><a href="#多命令运算" class="headerlink" title="多命令运算"></a>多命令运算</h3><ul><li><code>&amp;&amp;</code>第一条命令错误就不会执行第二个命令</li><li><code>||</code>第一条命令执行就不会执行第二个命令</li></ul><h3 id="管道符号"><a href="#管道符号" class="headerlink" title="管道符号"></a>管道符号</h3><p><code>|</code> A | B : A 命令的输出内容将会作为 B 命令的输入进行执行</p><p>筛选出所有 txt 文件</p><p><img src="https://picbed.wuzhentao.com/blog/w8.png" alt="w1.png (485×194) (wuzhentao.com)"></p><h2 id="批处理基本命令"><a href="#批处理基本命令" class="headerlink" title="批处理基本命令"></a>批处理基本命令</h2><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><ul><li>命令 子命令 参数 操作</li><li>命令帮助信息查看 <code>/?</code> <code>/help</code>获取详细帮助信息</li></ul><h3 id="批处理文件参数传递"><a href="#批处理文件参数传递" class="headerlink" title="批处理文件参数传递"></a>批处理文件参数传递</h3><blockquote><p>.bat 文件接收参数使用 %num</p></blockquote><p>net user ….. &#x2F;add 为系统创建新用户</p><p><img src="https://picbed.wuzhentao.com/blog/w9.png" alt="w1.png (485×194) (wuzhentao.com)"></p><p>直接打开文件不输入, bat 会无法执行</p><p><img src="https://picbed.wuzhentao.com/blog/w10.png" alt="w1.png (485×194) (wuzhentao.com)"></p><p>加上参数后,用户被成功创建</p><p><img src="https://picbed.wuzhentao.com/blog/w11.png" alt="w1.png (485×194) (wuzhentao.com)"></p><h3 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h3><blockquote><p>rem</p></blockquote><p>remark 缩写</p><p>注释会显示为黑色</p><p><img src="https://picbed.wuzhentao.com/blog/w12.png" alt="w1.png (485×194) (wuzhentao.com)"></p><h3 id="炫酷命令提示符"><a href="#炫酷命令提示符" class="headerlink" title="炫酷命令提示符"></a>炫酷命令提示符</h3><ul><li><p>颜色 color</p><p>字体变为绿色</p><p><img src="https://picbed.wuzhentao.com/blog/w13.png" alt="w1.png (485×194) (wuzhentao.com)"></p></li><li><p>标题 title</p></li></ul><p><img src="https://picbed.wuzhentao.com/blog/w14.png" alt="w1.png (485×194) (wuzhentao.com)"></p><h3 id="时间相关的命令"><a href="#时间相关的命令" class="headerlink" title="时间相关的命令"></a>时间相关的命令</h3><ul><li>date</li><li>time</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>行业实例作业</title>
      <link href="/post/e066d960.html"/>
      <url>/post/e066d960.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一期"><a href="#第一期" class="headerlink" title="第一期"></a>第一期</h2><h3 id="如何调研公司组织架构图"><a href="#如何调研公司组织架构图" class="headerlink" title="如何调研公司组织架构图"></a>如何调研公司组织架构图</h3><blockquote><p>推荐几个好用的亲测有效</p></blockquote><ul><li>直接上官网</li></ul><p>例如我要查询中国石化</p><p>这里的搜索引擎推荐<code>必应</code>, 广告少</p><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E8%A1%8C%E4%B8%9A/homework1.png" alt="homework1.png (1028×764) (wuzhentao.com)"></p><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E8%A1%8C%E4%B8%9A/homework2.png" alt="homework1.png (1028×764) (wuzhentao.com)"></p><ul><li>用<a href="https://www.tianyancha.com/">天眼查</a></li></ul><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E8%A1%8C%E4%B8%9A/homework3.png" alt="homework1.png (1028×764) (wuzhentao.com)"></p><ul><li>实在搜不出来就用</li></ul><p><a href="https://bt.gsxt.gov.cn/index.html">国家企业信用信息公式系统</a><br>亲测需要注册,因为数据库太大速度很慢</p><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E8%A1%8C%E4%B8%9A/homework4.png" alt="homework1.png (1028×764) (wuzhentao.com)"></p><blockquote><p>画图</p></blockquote><p>画图这边我有两种方案</p><ul><li>Xmind</li></ul><p>专业的思维导图软件</p><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E8%A1%8C%E4%B8%9A/homework5.png" alt="homework1.png (1028×764) (wuzhentao.com)"></p><p>可以自选主题</p><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E8%A1%8C%E4%B8%9A/homework6.png" alt="homework1.png (1028×764) (wuzhentao.com)"></p><ul><li>Draw.io</li></ul><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E8%A1%8C%E4%B8%9A/homework7.png" alt="homework1.png (1028×764) (wuzhentao.com)"></p><p>也是一个绘图软件</p><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E8%A1%8C%E4%B8%9A/homework8.png" alt="homework1.png (1028×764) (wuzhentao.com)"></p><ul><li>最暴力的方法</li></ul><p>new bing 已经用不了了， 微软的更新直接把他从高中生变成了大学生</p><p>这事儿最搞笑的是，微软一拳过去把谷歌打得踉踉跄跄，谷歌还惊魂未定呢，抬头一看，发现微软已经自己滚到路边沟里去了</p><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E8%A1%8C%E4%B8%9A/emoji.jpg" alt="homework1.png (1028×764) (wuzhentao.com)"></p><blockquote><p>可以用ChatGpt直接询问</p></blockquote><p>我这里用的ChatGpt接口,国内无法访问,</p><p>能用的镜像基本也是接口但是及其慢</p><p><img src="https://picbed.wuzhentao.com/%E4%BD%9C%E4%B8%9A/%E8%A1%8C%E4%B8%9A/homework9.png" alt="homework1.png (1028×764) (wuzhentao.com)"></p><h2 id="第二期"><a href="#第二期" class="headerlink" title="第二期"></a>第二期</h2><h3 id="MySQL安装和操作练习"><a href="#MySQL安装和操作练习" class="headerlink" title="MySQL安装和操作练习"></a>MySQL安装和操作练习</h3><div class="row">    <embed src="https://picbed.wuzhentao.com/pdf/Mysql.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="hadoop安装前准备工作"><a href="#hadoop安装前准备工作" class="headerlink" title="hadoop安装前准备工作"></a>hadoop安装前准备工作</h3><div class="row">    <embed src="https://picbed.wuzhentao.com/pdf/安装hadoop前的准备工作.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>每一期的作业都会准时更新</p><p>love &amp;&amp; peace  :smile:</p>]]></content>
      
      
      <categories>
          
          <category> 作业 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Excel教程</title>
      <link href="/post/315fa0bf.html"/>
      <url>/post/315fa0bf.html</url>
      
        <content type="html"><![CDATA[<h1 id="Excel-操作"><a href="#Excel-操作" class="headerlink" title="Excel 操作"></a>Excel 操作</h1><h3 id="简单操作"><a href="#简单操作" class="headerlink" title="简单操作"></a>简单操作</h3><p>保存: ctrl + s</p><p>另存为: F12(笔记本还需要加 Fn)</p><blockquote><p>设置密码:</p></blockquote><p>工具 -&gt; 常规</p><p>设置密码可以防止对方收到数据后修改数据</p><p><img src="https://picbed.wuzhentao.com/excel/excel1.png"></p><p>如果想要将表格列宽都变成一样, 需要全选再拖拽</p><p><img src="https://picbed.wuzhentao.com/excel/excel2.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><blockquote><p>相同内容输入:</p></blockquote><p>选中区域输入, 再 CTRL + enter</p><p><img src="https://picbed.wuzhentao.com/excel/excel19.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><p>也可以分别选中输入</p><p><img src="https://picbed.wuzhentao.com/excel/excel20.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><h2 id="减少重复性输入"><a href="#减少重复性输入" class="headerlink" title="减少重复性输入"></a>减少重复性输入</h2><h3 id="智能填充"><a href="#智能填充" class="headerlink" title="智能填充"></a>智能填充</h3><p>能够快速填充数据 ( 只有 office2013 及以上版本有 )</p><blockquote><p>案例: 提取邮箱人名</p></blockquote><p><img src="https://picbed.wuzhentao.com/excel/excel3.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><ul><li>方法一: 输入两个名字,excel 会自动提取</li></ul><p><img src="https://picbed.wuzhentao.com/excel/excel4.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><ul><li>方法二: 使用快捷键</li></ul><p>CTRL + E 快速填充</p><p><img src="https://picbed.wuzhentao.com/excel/excel5.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><ul><li>方法三: 使用填充柄</li></ul><p>单元格右下角双击或者下拉</p><p><img src="https://picbed.wuzhentao.com/excel/excel6.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><blockquote><p>注意</p></blockquote><ul><li>如果你填充时, 发现你实际填充的内容跟自己想要的不一样, 只需要多填写几个案例再快速填充即可, 因为快速填充有时候也没有那么智能</li><li>使用快速填充时, 一定要注意附近一定要有数据, 不能出现下面这种情况</li></ul><p><img src="https://picbed.wuzhentao.com/excel/excel7.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><ul><li>智能填充不仅能快速填充数据, 也能合并和拆解甚至重组</li></ul><h3 id="快速分析"><a href="#快速分析" class="headerlink" title="快速分析"></a>快速分析</h3><p>快捷键: CTRL + Q</p><p>里面有许多功能</p><p><img src="https://picbed.wuzhentao.com/excel/excel8.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><blockquote><p>图标集</p></blockquote><p>会将所有数据划分成向上向下向右的箭头</p><p><img src="https://picbed.wuzhentao.com/excel/excel9.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><p>不知道什么意思可以点击条件格式查看管理规则</p><p><img src="https://picbed.wuzhentao.com/excel/excel10.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><p><img src="https://picbed.wuzhentao.com/excel/excel11.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><h4 id="图表-x2F-汇总-x2F-表格"><a href="#图表-x2F-汇总-x2F-表格" class="headerlink" title="图表&#x2F;汇总&#x2F;表格"></a>图表&#x2F;汇总&#x2F;表格</h4><p>图表有许多种, 如果没有喜欢的可以选择更多图表</p><p><img src="https://picbed.wuzhentao.com/excel/excel12.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><blockquote><p>表格区别</p></blockquote><p>当我们鼠标点击表格中的任意区域的的时候, 上方选项卡会多出一个设计表格工具</p><p><img src="https://picbed.wuzhentao.com/excel/excel13.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><h4 id="迷你图"><a href="#迷你图" class="headerlink" title="迷你图"></a>迷你图</h4><p><img src="https://picbed.wuzhentao.com/excel/excel14.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><p>当我们鼠标点击迷你图中的任意区域的的时候, 上方选项卡会多出一个设计迷你图工具</p><p><img src="https://picbed.wuzhentao.com/excel/excel15.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><h2 id="减少错误输入"><a href="#减少错误输入" class="headerlink" title="减少错误输入"></a>减少错误输入</h2><blockquote><p>录入数据</p></blockquote><ul><li>手动输入</li><li>网上爬取</li></ul><h3 id="规范录入数据"><a href="#规范录入数据" class="headerlink" title="规范录入数据"></a>规范录入数据</h3><blockquote><p>建议使用横向录入方式</p></blockquote><p>因为一横行数据才是一条完整数据</p><p>如果竖着录入就没有任何一套数据是一个完整状态</p><h4 id="快捷键录入"><a href="#快捷键录入" class="headerlink" title="快捷键录入"></a>快捷键录入</h4><blockquote><p>tab 键: 往右边移动一个单元格</p><p>enter 键: 往下移动一个单元格</p><p>shift 键: 需要搭配 tab 或 enter, 返回上一个位置</p></blockquote><h4 id="特殊格式输入"><a href="#特殊格式输入" class="headerlink" title="特殊格式输入"></a>特殊格式输入</h4><h5 id="时间输入"><a href="#时间输入" class="headerlink" title="时间输入"></a>时间输入</h5><p>默认请款下是通过 <code>-</code>短横线或<code>/</code>录入</p><p><img src="https://picbed.wuzhentao.com/excel/excel16.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><blockquote><p>为什么要用 - 或 &#x2F; 来输入呢?</p></blockquote><p>因为进行日期筛选时,如果格式是 2023.2.21 或 20230221 是不会被 excel 认为是日期时间</p><blockquote><p>快速输入今天日期</p></blockquote><p>快捷键 CTRL + ;</p><blockquote><p>快速输入当时时间</p></blockquote><p>快捷键 CTRL + shift + ;</p><p>也可以使用 now() 函数可以显示当前日期和时间</p><h5 id="其他格式输入"><a href="#其他格式输入" class="headerlink" title="其他格式输入"></a>其他格式输入</h5><p>选中单元格将常规修改为其他格式</p><p><img src="https://picbed.wuzhentao.com/excel/excel17.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><h5 id="身份证录入"><a href="#身份证录入" class="headerlink" title="身份证录入"></a>身份证录入</h5><p>excel 的数据精度最长 15 位, 超过 15 位后的数字都会变成 0</p><p><img src="https://picbed.wuzhentao.com/excel/excel18.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><p>可以将格式改为文本格式即可完整录入</p><p>或者在数字前面打个英文<code>,</code></p><blockquote><p>优点</p></blockquote><ul><li>可以完整的记录</li></ul><blockquote><p>缺点</p></blockquote><ul><li>文本不能进行计算</li></ul><blockquote><p>注意</p></blockquote><ul><li>输入分数需要先改成分数格式, 不然 excel 会认为是日期</li></ul><h3 id="从外部导入数据"><a href="#从外部导入数据" class="headerlink" title="从外部导入数据"></a>从外部导入数据</h3><h4 id="爬取网站数据"><a href="#爬取网站数据" class="headerlink" title="爬取网站数据"></a>爬取网站数据</h4><p>选项卡-&gt; 数据 -&gt; 自网站</p><p>输入网址</p><p><img src="https://picbed.wuzhentao.com/excel/excel21.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><p>加载至当前单元格</p><p><img src="https://picbed.wuzhentao.com/excel/excel22.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><blockquote><p>骚操作</p></blockquote><p>股票实时行情</p><p><img src="https://picbed.wuzhentao.com/excel/excel23.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><blockquote><p>怎么实时?</p></blockquote><p>可以自己手动点击刷新</p><p>也可以全部刷新</p><p><img src="https://picbed.wuzhentao.com/excel/excel24.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><p>或者定时刷新</p><p>全部刷新 -&gt;连接属性</p><p><img src="https://picbed.wuzhentao.com/excel/excel25.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><blockquote><p>缺点</p></blockquote><ul><li>只能爬取表格数据</li><li>不能爬取网页上的结构化数据</li></ul><h2 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h2><p>如果是使用 excel 爬取数据,web 有些无法爬取需要手动修改可以</p><p>点击查询-&gt; 编辑</p><p>手动修改</p><p><img src="https://picbed.wuzhentao.com/excel/excel26.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><h4 id="清洗过程"><a href="#清洗过程" class="headerlink" title="清洗过程"></a>清洗过程</h4><blockquote><p>需要创建一个新的数据表</p></blockquote><p>不能改动原数据源</p><blockquote><p>如果想对数据表新建一个查询</p></blockquote><ul><li>先将表转换为超级表</li></ul><p>全选 CTRL + t</p><p><img src="https://picbed.wuzhentao.com/excel/excel27.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><blockquote><p>如何再转换为表格呢?</p></blockquote><p>转为普通区域</p><p><img src="https://picbed.wuzhentao.com/excel/excel28.png" alt="excel1.png (970×434) (wuzhentao.com)"></p><blockquote><p>进行编辑</p></blockquote><p>点击 数据-&gt;来自表格&#x2F;区域 弹出表 3</p><p><img src="https://picbed.wuzhentao.com/excel/excel29.png"></p><h1 id="单元格显示问题"><a href="#单元格显示问题" class="headerlink" title="单元格显示问题"></a>单元格显示问题</h1><p>点击右键复制显示的值不一样</p><p><img src="https://picbed.wuzhentao.com/excel/excel30.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><p>如果是带单位的数值是无法进行计算的,有时又可以进行计算</p><p>这都是单元格式的问题</p><h2 id="单元格内容"><a href="#单元格内容" class="headerlink" title="单元格内容"></a>单元格内容</h2><p>在Excel中,我们一般会填充的类型只有下面三种</p><ul><li>文本</li><li>数值</li><li>逻辑值</li></ul><blockquote><p>文本</p></blockquote><ul><li><p>中文,英文标点字符或者是特殊符号</p></li><li><p>文本最大的特点是,它输入完的内容是左对齐的</p></li><li><p>不限制长度</p></li></ul><blockquote><p>数值</p></blockquote><ul><li><p>默认状态下右对齐</p></li><li><p>数值本身有精度,计算精度15位</p></li></ul><blockquote><p>逻辑值</p></blockquote><ul><li>ture或false</li><li>能够进行判断</li><li><img src="https://picbed.wuzhentao.com/excel/excel31.png" alt="excel30.png (355×241) (wuzhentao.com)"></li></ul><p><img src="https://picbed.wuzhentao.com/excel/excel32.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><ul><li><p>能够参与计算</p></li><li><p>默认居中对齐</p></li></ul><blockquote><p>扩展:</p></blockquote><p>一般删除会删除内容但是并不能删除格式</p><p>要想删除格式需要找到:</p><p>开始 -&gt;单元格 -&gt;清除</p><p><img src="https://picbed.wuzhentao.com/excel/excel33.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><h2 id="单元格格式"><a href="#单元格格式" class="headerlink" title="单元格格式"></a>单元格格式</h2><h3 id="常规格式"><a href="#常规格式" class="headerlink" title="常规格式"></a>常规格式</h3><p>就是开始选项卡下面的字体组以及的对齐方式组</p><p><img src="https://picbed.wuzhentao.com/excel/excel34.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><p>如果想要看到更多设置可以点击它们右下角的<code>启动器</code></p><p>或者使用快捷键 CTRL + 1</p><blockquote><p>技巧</p></blockquote><p>居中并不推荐合并居中</p><p>因为你将无法精确定位到另一个单元格,而且无法进行筛选和透视</p><p>如果想要规范使用Excel并不推荐合并居中</p><p>推荐使用跨列居中</p><p><strong>跨列居中</strong></p><p>先选中</p><p><img src="https://picbed.wuzhentao.com/excel/excel35.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><p>按快捷键Ctrl + 1打开面板</p><p><img src="https://picbed.wuzhentao.com/excel/excel36.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><p>水平对齐方式选择跨列居中</p><p><img src="https://picbed.wuzhentao.com/excel/excel37.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><p>如果想要颜色一样</p><p>可以自行给它增加一个颜色以及加粗</p><p><img src="https://picbed.wuzhentao.com/excel/excel38.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><p>还有很多功能就不一一赘述了</p><p>任何单元格式都可ctrl + 1调整</p><h3 id="数字格式"><a href="#数字格式" class="headerlink" title="数字格式"></a>数字格式</h3><p>如果说常规格式设置的是外在效果</p><p>数字格式设置的就是它的展示方式</p><blockquote><p>展示方式可以让显示变得更加直观</p></blockquote><p>在单元格中有货币符号</p><p><img src="https://picbed.wuzhentao.com/excel/excel39.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><p>但在编辑器中会显示它最初的样子</p><p><img src="https://picbed.wuzhentao.com/excel/excel40.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><p><strong>如果想设置数字格式快捷键和常规格式一样</strong></p><p>在图片中还有很多<code>#</code>号</p><p>这些#号并不是报错的意思,大多数情况下代表着我们目前的这个单元格的宽度并不能完整的显示里面的内容,只需要把单元格拉宽即可</p><p>或者</p><p>把鼠标放到<code>H</code>和<code>I</code>中间双击,会自动显示为合适的宽度</p><p><img src="https://picbed.wuzhentao.com/excel/excel41.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><p>如果想多选可以使用自动调整列宽</p><p><img src="https://picbed.wuzhentao.com/excel/excel42.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><blockquote><p>格式介绍</p></blockquote><p><img src="https://picbed.wuzhentao.com/excel/excel43.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><p><img src="https://picbed.wuzhentao.com/excel/excel44.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><h4 id="常用数字格式代码"><a href="#常用数字格式代码" class="headerlink" title="常用数字格式代码"></a>常用数字格式代码</h4><p><img src="https://picbed.wuzhentao.com/excel/excel45.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><p><img src="https://picbed.wuzhentao.com/excel/excel46.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><p><img src="https://picbed.wuzhentao.com/excel/excel47.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><p><img src="https://picbed.wuzhentao.com/excel/excel48.png" alt="excel30.png (355×241) (wuzhentao.com)"></p><h1 id="条件格式"><a href="#条件格式" class="headerlink" title="条件格式"></a>条件格式</h1><p>用来帮助你直观的查看和分析数据，通过标识出指定单元格可以让你快速发现问题，并且识别一些模式和趋势</p><blockquote><p>使用</p></blockquote><p>选取区域点击条件格式</p><p><img src="https://picbed.wuzhentao.com/excel/excel49.png" alt="excel49.png (579×622) (wuzhentao.com)"></p><blockquote><p>快速找出不重复值</p></blockquote><p>方法一:</p><p>选中区域, 数据-&gt;删除重复值</p><p><img src="https://picbed.wuzhentao.com/excel/excel50.png" alt="excel49.png (579×622) (wuzhentao.com)"></p><p>不推荐:</p><p>会删除原本数据无法找回</p><p>方法二:使用条件格式</p><p>条件格式 -&gt; 重复值</p><p><img src="https://picbed.wuzhentao.com/excel/excel51.png" alt="excel49.png (579×622) (wuzhentao.com)"></p><p>选择 <code>唯一</code>筛选出唯一值</p><p><img src="https://picbed.wuzhentao.com/excel/excel52.png" alt="excel49.png (579×622) (wuzhentao.com)"></p><p>如果觉得这样不爽,还可以点击</p><p>筛选 -&gt; 按颜色</p><p><img src="https://picbed.wuzhentao.com/excel/excel53.png" alt="excel49.png (579×622) (wuzhentao.com)"></p><p><img src="https://picbed.wuzhentao.com/excel/excel54.png" alt="excel49.png (579×622) (wuzhentao.com)"></p><h1 id="快速定位目标值"><a href="#快速定位目标值" class="headerlink" title="快速定位目标值"></a>快速定位目标值</h1><p>功能键在 </p><p>开始-&gt;查找 </p><p><img src="https://picbed.wuzhentao.com/excel/excel55.png" alt="excel49.png (579×622) (wuzhentao.com)"></p><p>定位快捷键: CTRL + G</p><blockquote><p>案例:快速删除图片</p></blockquote><p>图片属于对象,用框全选无法选中</p><p>可以打开定位</p><p>选择的定位条件为对象</p><p><img src="https://picbed.wuzhentao.com/excel/excel56.png" alt="excel49.png (579×622) (wuzhentao.com)"></p><p>这样就能框选中图片了</p><p><img src="https://picbed.wuzhentao.com/excel/excel57.png" alt="excel49.png (579×622) (wuzhentao.com)"></p><blockquote><p>案例:标记特殊(带公式)单元格</p></blockquote><p>定位选择公式</p><p><img src="https://picbed.wuzhentao.com/excel/excel58.png" alt="excel49.png (579×622) (wuzhentao.com)"></p><blockquote><p>案例:合并单元格</p></blockquote><p>合并单元格的情况下其实非常不方便我们后续的筛选和处理</p><p>例如选中b12-b18 右上角只会显示b12</p><p><img src="https://picbed.wuzhentao.com/excel/excel59.png" alt="excel49.png (579×622) (wuzhentao.com)"></p><p>所以我们需要先取消合并</p><p><img src="https://picbed.wuzhentao.com/excel/excel60.png" alt="excel49.png (579×622) (wuzhentao.com)"></p><p>接下来我们需要将销售日期软布填充得到各个单元格里</p><p>这个时候如果使用快速填充或复制粘贴会很慢</p><p>我们可以使用定位来提高效率</p><p>选择空值</p><p>此时b13是一个浅色的状态,其他单元格都是深色</p><p>说明它处于选中状态,可以使用tab 或者 shift + enter调整位置</p><p><img src="https://picbed.wuzhentao.com/excel/excel61.png" alt="excel49.png (579×622) (wuzhentao.com)"></p><p>输入 &#x3D;b12按下CTRL + enter原位填充</p><p>下面的单元格依次等于前一个单元格</p><p><img src="https://picbed.wuzhentao.com/excel/excel62.png" alt="excel49.png (579×622) (wuzhentao.com)"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>每日算法</title>
      <link href="/post/79723410.html"/>
      <url>/post/79723410.html</url>
      
        <content type="html"><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h4 id="判断闰年"><a href="#判断闰年" class="headerlink" title="判断闰年"></a>判断闰年</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">.判断闰年。闰年有两种情况：</span></span><br><span class="line"><span class="comment">(1) 能被100整除时，必须能被400整除；</span></span><br><span class="line"><span class="comment">(2) 不能被100整除时，被4整除即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    cin &gt;&gt; year;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (year % <span class="number">100</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (year % <span class="number">400</span> == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="明明的随机数"><a href="#明明的随机数" class="headerlink" title="明明的随机数"></a>明明的随机数</h4><p>题目链接:[P1059 <a href="https://www.luogu.com.cn/problem/P1059">NOIP2006 普及组] 明明的随机数 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>P.S.代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q[N], sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, x;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="keyword">if</span>(q[x]) <span class="keyword">continue</span>;</span><br><span class="line">        q[x]++;</span><br><span class="line">        sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">        <span class="keyword">if</span>(q[i]) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>题目链接<a href="https://www.luogu.com.cn/problem/P1177">P1177 【模板】快速排序 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>思路：核心思想是分治，数组中找一个数作为分界点<code>x</code>, 小于x的放左边, 大于x的放右边, 化成两个区域, 再递归处理左右两段, 要注意边界问题</p><p>P.S. 代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q[++i] &lt; x);</span><br><span class="line">        <span class="keyword">while</span>(q[--j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(l, j), <span class="built_in">quick_sort</span>(j + <span class="number">1</span>, r);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    <span class="built_in">quick_sort</span>(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h4><p>题目链接:<a href="https://www.luogu.com.cn/problem/P3397">P3397 地毯 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>二维差分实际上就是<code>差分 + 子矩阵和</code></p><p>子矩阵和的公式是:</p><p><img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20230405163914803.png" alt="image-20230405163914803"></p><p>差分公式:</p><p><img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20230405164033210.png" alt="image-20230405164033210"></p><p>解题思路:</p><p>先构造出二维差分矩阵</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20230405165829989.png" alt="image-20230405165829989"></p><p>再求出子矩阵和即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];<span class="comment">//二维前缀和</span></span><br><span class="line"><span class="comment">//其实这里的b[i][j]就是a[i][j]</span></span><br><span class="line"><span class="comment">//原公式二维前缀和:s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];</span></span><br></pre></td></tr></table></figure><p>详细差分内容可参考这篇博客</p><p><a href="https://blog.csdn.net/m0_74215326/article/details/129620912?spm=1001.2014.3001.5502">(9条消息) 【学习总结】一、二维前缀和 &amp;&amp; 一、二维差分_吹往北方的风的博客-CSDN博客</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            a[i][j] = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, x2, y1, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">        <span class="built_in">insert</span>(x1, y1, x2, y2, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>竞赛简略 C++语法</title>
      <link href="/post/735764c6.html"/>
      <url>/post/735764c6.html</url>
      
        <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h3 id="C-入门及简单的顺序结构"><a href="#C-入门及简单的顺序结构" class="headerlink" title="C++入门及简单的顺序结构"></a>C++入门及简单的顺序结构</h3><blockquote><p>变量的定义</p></blockquote><p>变量必须先定义，才可以使用。不能重名。<br>变量定义的方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b, c = a, d = <span class="number">10</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>常用变量类型及范围：</p></blockquote><p><img src="https://cdn.acwing.com/media/article/image/2022/01/11/1_5e05573e72-4.png" alt="变量"></p><blockquote><p>输入输出</p></blockquote><p>整数的输入输出:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>字符串的输入输出：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入输出多个不同类型的变量：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    string str;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cin &gt;&gt; b &gt;&gt; str;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; str &lt;&lt; <span class="string">&quot; !!! &quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>表达式</p></blockquote><p>整数的加减乘除四则运算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">6</span> + <span class="number">3</span> * <span class="number">4</span> / <span class="number">2</span> - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b = a * <span class="number">10</span> + <span class="number">5</span> / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="number">23</span> * <span class="number">56</span> - <span class="number">78</span> / <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.acwing.com/media/article/image/2022/01/11/1_22d9b8af72-5.png" alt="1_22d9b8af72-5.png (1048×280) (acwing.com)"></p><blockquote><p>浮点数（小数）的运算：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> x = <span class="number">1.5</span>, y = <span class="number">3.2</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; x * y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x + y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; x - y &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x / y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>整型变量的自增、自减：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = a ++ ;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = ++ a;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>变量的类型转换</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> x = <span class="number">123.12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> y = (<span class="type">int</span>)x;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="printf-语句与判断结构"><a href="#printf-语句与判断结构" class="headerlink" title="printf 语句与判断结构"></a>printf 语句与判断结构</h3><blockquote><p>printf 输出格式:</p><p>注意：使用 printf 时最好添加头文件 #include <cstdio>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Int、float、double、char 等类型的输出格式：</p></blockquote><ul><li>int：%d</li><li>float: %f, 默认保留 6 位小数</li><li>double: %lf， 默认保留 6 位小数</li><li>char: %c, 回车也是一个字符，用’\n’表示</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">3.12345678</span>;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">3.12345678</span>;</span><br><span class="line">    <span class="type">char</span> d = <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所有输出的变量均可包含在一个字符串中：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">3.12345678</span>;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">3.12345678</span>;</span><br><span class="line">    <span class="type">char</span> d = <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int a = %d, float b = %f\ndouble c = %lf, char d = %c\n&quot;</span>, a, b, c, d);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>扩展功能:</p><p>float, double 等输出保留若干位小数时用：%.4f, %.3lf</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">3.12345678</span>;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">3.12345678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.4f\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最小数字宽度:</p></blockquote><ul><li>%8.3f, 表示这个浮点数的最小宽度为 8，保留 3 位小数，当宽度不足时在前面补空格。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">3.12345678</span>;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">3.12345678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%5d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%8.4f\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%7.3lf\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>%-8.3f，表示最小宽度为 8，保留 3 位小数，当宽度不足时在后面补上空格</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">3.12345678</span>;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">3.12345678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-5d!\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-8.4f!\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%-7.3lf!\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>%08.3f, 表示最小宽度为 8，保留 3 位小数，当宽度不足时在前面补上 0</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="type">float</span> b = <span class="number">3.12345678</span>;</span><br><span class="line">    <span class="type">double</span> c = <span class="number">3.12345678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%05d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%08.4f\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%07.3lf\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><blockquote><p>基本 if-else 语句</p></blockquote><ul><li>当条件成立时，执行某些语句；否则执行另一些语句。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is big!\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d + 1 = %d\n&quot;</span>, a, a + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is small!\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d - 1 = %d\n&quot;</span>, a, a - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>else 语句可以省略：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is big!\n&quot;</span>, a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d + 1 = %d\n&quot;</span>, a, a + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当只有一条语句时，大括号可以省略：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">5</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is big!\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d is small!\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>常用比较运算符</p></blockquote><blockquote><p>条件表达式</p></blockquote><p>(1) 与 &amp;&amp;<br>(2) 或 ||<br>(3) 非 !</p>]]></content>
      
      
      <categories>
          
          <category> 竞赛 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Chatgpt注册</title>
      <link href="/post/fabb1df2.html"/>
      <url>/post/fabb1df2.html</url>
      
        <content type="html"><![CDATA[<h1 id="中国区注册OpenAI账号试用ChatGPT指南"><a href="#中国区注册OpenAI账号试用ChatGPT指南" class="headerlink" title="中国区注册OpenAI账号试用ChatGPT指南"></a>中国区注册OpenAI账号试用ChatGPT指南</h1><p>OpenAI最近推出强大的ChatGPT功能，各大程序员使用后发出感叹：程序员要失业了</p><p>不过在国内并不支持OpenAI账号注册，多数会提示：</p><blockquote><p>OpenAI’s services are not available in your country.</p></blockquote><p>经过一番搜索后，发现如下方案可以完成注册</p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="#前期准备"></a><a href="https://readdevdocs.com/blog/makemoney/%E4%B8%AD%E5%9B%BD%E5%8C%BA%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7%E8%AF%95%E7%94%A8ChatGPT%E6%8C%87%E5%8D%97.html#%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87">#</a>前期准备</h2><ul><li>科学上网，最好是美国IP</li><li>外国邮箱，如gmail、outlook、iCloud邮箱等</li><li>有一个能收到验证码的外国手机号码，如果你没有，请跳到下一步，注册一个能接验证码的手机号，注意这是收费的！</li></ul><h2 id="注册短信平台并充值"><a href="#注册短信平台并充值" class="headerlink" title="#注册短信平台并充值"></a><a href="https://readdevdocs.com/blog/makemoney/%E4%B8%AD%E5%9B%BD%E5%8C%BA%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7%E8%AF%95%E7%94%A8ChatGPT%E6%8C%87%E5%8D%97.html#%E6%B3%A8%E5%86%8C%E7%9F%AD%E4%BF%A1%E5%B9%B3%E5%8F%B0%E5%B9%B6%E5%85%85%E5%80%BC">#</a>注册短信平台并充值</h2><p>打开 <a href="https://sms-activate.org/">https://sms-activate.org/ (opens new window)</a>点击右上角注册</p><p><img src="https://readdevdocs.com/blog/assets/img/2022-12-06-22-28-09-image.ca659380.png" alt="img"></p><p>输入邮箱和密码注册，需要收激活邮件激活账号。</p><p><img src="https://readdevdocs.com/blog/assets/img/2022-12-06-22-31-29-image.c6f711f1.png" alt="img"></p><p>激活账号后，点击充值</p><p><img src="https://readdevdocs.com/blog/assets/img/2022-12-06-22-30-39-image.18641035.png" alt="img"></p><p>可以用支付宝充值1美元</p><p><img src="https://readdevdocs.com/blog/assets/img/2022-12-06-22-36-02-image.82f06c00.png" alt="img"></p><p>输入1美元，然后支付</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c507b1564d1442d8dfab0ebc8d481e1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>支付了可能要等几分钟才显示到余额账户，我在注册时就等了一会余额才显示</p><h2 id="注册-OpenAI-账号"><a href="#注册-OpenAI-账号" class="headerlink" title="#注册 OpenAI 账号"></a><a href="https://readdevdocs.com/blog/makemoney/%E4%B8%AD%E5%9B%BD%E5%8C%BA%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7%E8%AF%95%E7%94%A8ChatGPT%E6%8C%87%E5%8D%97.html#%E6%B3%A8%E5%86%8C-openai-%E8%B4%A6%E5%8F%B7">#</a>注册 OpenAI 账号</h2><p>挂上科学访问打开 <a href="https://beta.openai.com/signup">https://beta.openai.com/signup (opens new window)</a>进行注册，如果没有科学上网会提示无法注册</p><blockquote><p>OpenAI’s services are not available in your country.</p></blockquote><p>注册成功后会进入验证手机号页面，<strong>选择你下一步短信平台的接码的手机国家</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d50d22c04df0430aa0b2afca70a55beb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="在短信平台接码"><a href="#在短信平台接码" class="headerlink" title="#在短信平台接码"></a><a href="https://readdevdocs.com/blog/makemoney/%E4%B8%AD%E5%9B%BD%E5%8C%BA%E6%B3%A8%E5%86%8COpenAI%E8%B4%A6%E5%8F%B7%E8%AF%95%E7%94%A8ChatGPT%E6%8C%87%E5%8D%97.html#%E5%9C%A8%E7%9F%AD%E4%BF%A1%E5%B9%B3%E5%8F%B0%E6%8E%A5%E7%A0%81">#</a>在短信平台接码</h2><p>右侧服务，输入搜索openai，选择</p><p><img src="https://readdevdocs.com/blog/assets/img/2022-12-06-22-44-15-image.a9438d80.png" alt="img"></p><p>选择印度或者巴西</p><p><img src="https://readdevdocs.com/blog/assets/img/2022-12-06-22-45-40-image.bbd38d37.png" alt="img"></p><p>现在你有一个可以接码的号码了，图下919862209703就是号码，复制号码到OpenAI验证码界面</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2e4434858ab4cbaaa9e1d8249305547~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>输入接码号码，点击“send code”</p><p><img src="https://readdevdocs.com/blog/assets/img/2022-12-06-22-52-38-image.c21bfd00.png" alt="img"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2e4434858ab4cbaaa9e1d8249305547~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>然后等激活码，如果没有收到可以点OpenAI注册界面再发一次验证码，可以多试几次。</p><p>注册完就可以去登录 <a href="https://chat.openai.com/auth/login">https://chat.openai.com/auth/login(opens new window)</a></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e474b55d15d4b8ea3c56e7deb5ce8f9~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="/post/a444b428.html"/>
      <url>/post/a444b428.html</url>
      
        <content type="html"><![CDATA[<h1 id="排序简介"><a href="#排序简介" class="headerlink" title="排序简介"></a>排序简介</h1><p>「排序算法 Sorting Algorithm」使得列表中的所有元素按照从小到大的顺序排列。</p><ul><li>待排序的列表的 <strong>元素类型</strong> 可以是整数、浮点数、字符、或字符串；</li><li>排序算法可以根据需要设定 <strong>判断规则</strong>，例如数字大小、字符 ASCII 码顺序、自定义规则；</li></ul><blockquote><p>排序中的不同元素类型和判断规则</p></blockquote><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p1.png" alt="p1"></p><h2 id="评价维度"><a href="#评价维度" class="headerlink" title="评价维度"></a>评价维度</h2><p>排序算法主要可根据 <strong>稳定性 、就地性 、自适应性 、比较类</strong> 来分类。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><ul><li>「稳定排序」在完成排序后，<strong>不改变</strong> 相等元素在数组中的相对顺序。</li><li>「非稳定排序」在完成排序后，相等元素在数组中的相对位置 <strong>可能被改变</strong>。</li></ul><p>假设我们有一个存储学生信息的表格，第 1, 2 列分别是姓名和年龄。那么在以下示例中，「非稳定排序」会导致输入数据的有序性丢失。因此「稳定排序」是很好的特性，<strong>在多级排序中是必须的</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 输入数据是按照姓名排序好的</span><br><span class="line"># (name, age)</span><br><span class="line">  (&#x27;A&#x27;, 19)</span><br><span class="line">  (&#x27;B&#x27;, 18)</span><br><span class="line">  (&#x27;C&#x27;, 21)</span><br><span class="line">  (&#x27;D&#x27;, 19)</span><br><span class="line">  (&#x27;E&#x27;, 23)</span><br><span class="line"></span><br><span class="line"># 假设使用非稳定排序算法按年龄排序列表，</span><br><span class="line"># 结果中 (&#x27;D&#x27;, 19) 和 (&#x27;A&#x27;, 19) 的相对位置改变，</span><br><span class="line"># 输入数据按姓名排序的性质丢失</span><br><span class="line">  (&#x27;B&#x27;, 18)</span><br><span class="line">  (&#x27;D&#x27;, 19)</span><br><span class="line">  (&#x27;A&#x27;, 19)</span><br><span class="line">  (&#x27;C&#x27;, 21)</span><br><span class="line">  (&#x27;E&#x27;, 23)</span><br></pre></td></tr></table></figure><h3 id="就地性"><a href="#就地性" class="headerlink" title="就地性"></a>就地性</h3><ul><li>「原地排序」无需辅助数据，不使用额外空间；</li><li>「非原地排序」需要借助辅助数据，使用额外空间；</li></ul><p>「原地排序」不使用额外空间，可以节约内存；并且一般情况下，由于数据操作减少，原地排序的运行效率也更高。</p><h3 id="自适应性"><a href="#自适应性" class="headerlink" title="自适应性"></a>自适应性</h3><ul><li>「自适应排序」的时间复杂度受输入数据影响，即最佳 &#x2F; 最差 &#x2F; 平均时间复杂度不相等。</li><li>「非自适应排序」的时间复杂度恒定，与输入数据无关。</li></ul><p>我们希望 <strong>最差 &#x3D; 平均</strong>，即不希望排序算法的运行效率在某些输入数据下发生劣化。</p><h3 id="比较类"><a href="#比较类" class="headerlink" title="比较类"></a>比较类</h3><ul><li>「比较类排序」基于元素之间的比较算子（小于、相等、大于）来决定元素的相对顺序。</li><li>「非比较类排序」不基于元素之间的比较算子来决定元素的相对顺序。</li></ul><p>「比较类排序」的时间复杂度最优为 (O(n \log n)) ；而「非比较类排序」可以达到 (O(n)) 的时间复杂度，但通用性较差。</p><h2 id="理想排序算法"><a href="#理想排序算法" class="headerlink" title="理想排序算法"></a>理想排序算法</h2><ul><li><strong>运行快</strong>，即时间复杂度低；</li><li><strong>稳定排序</strong>，即排序后相等元素的相对位置不变化；</li><li><strong>原地排序</strong>，即运行中不使用额外的辅助空间；</li><li><strong>正向自适应性</strong>，即算法的运行效率不会在某些输入数据下发生劣化；</li></ul><p>然而，<strong>没有排序算法同时具备以上所有特性</strong>。排序算法的选型使用取决于具体的列表类型、列表长度、元素分布等因素。</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>「冒泡排序 Bubble Sort」是一种最基础的排序算法，非常适合作为第一个学习的排序算法。顾名思义，「冒泡」是该算法的核心操作。</p><blockquote><p>为什么叫”冒泡”</p></blockquote><p>在水中，越大的泡泡浮力越大，所以最大的泡泡会最先浮到水面。</p><p>「冒泡」操作则是在模拟上述过程，具体做法为：从数组最左端开始向右遍历，依次对比相邻元素大小，若 <strong>左元素 &gt; 右元素</strong> 则将它俩交换，最终可将最大元素移动至数组最右端。</p><p>完成此次冒泡操作后，<strong>数组最大元素已在正确位置，接下来只需排序剩余 (n - 1) 个元素</strong>。</p><blockquote><p>冒泡操作</p></blockquote><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p2.png" alt="p2"></p><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p3.png" alt="p3"></p><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p4.png" alt="p4"></p><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p5.png" alt="p5"></p><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p6.png" alt="p6"></p><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p7.png" alt="p7"></p><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p8.png" alt="p8"></p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ol><li>设数组长度为 (n) ，完成第一轮「冒泡」后，数组最大元素已在正确位置，接下来只需排序剩余 (n - 1) 个元素。</li><li>同理，对剩余 (n - 1) 个元素执行「冒泡」，可将第二大元素交换至正确位置，因而待排序元素只剩 (n - 2) 个。</li><li>以此类推…… <strong>循环 (n - 1) 轮「冒泡」，即可完成整个数组的排序</strong>。</li></ol><p><img src="https://picbed.wuzhentao.com/img/BubbleSort/p9.png" alt="p9"></p><blockquote><p>C++实现</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外循环：待排序元素数量为 n-1, n-2, ..., 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 内循环：冒泡操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                <span class="comment">// 这里使用了 std::swap() 函数</span></span><br><span class="line">                <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>python 实现</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 冒泡排序 &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 外循环：待排序元素数量为 n-1, n-2, ..., 1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 内循环：冒泡操作</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br></pre></td></tr></table></figure><h2 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h2><p><strong>时间复杂度 (O(n^2))</strong> ：各轮「冒泡」遍历的数组长度为 (n - 1) , (n - 2) , (\cdots) , (2) , (1) 次，求和为 (\frac{(n - 1) n}{2}) ，因此使用 (O(n^2)) 时间。</p><p><strong>空间复杂度 (O(1))</strong> ：指针 (i) , (j) 使用常数大小的额外空间。</p><p><strong>原地排序</strong>：指针变量仅使用常数大小额外空间。</p><p><strong>稳定排序</strong>：不交换相等元素。</p><p><strong>自适应排序</strong>：引入 <code>flag</code> 优化后（见下文），最佳时间复杂度为 (O(N)) 。</p><h2 id="效率优化"><a href="#效率优化" class="headerlink" title="效率优化"></a>效率优化</h2><p>我们发现，若在某轮「冒泡」中未执行任何交换操作，则说明数组已经完成排序，可直接返回结果。考虑可以增加一个标志位 <code>flag</code> 来监听该情况，若出现则直接返回。</p><p>优化后，冒泡排序的最差和平均时间复杂度仍为 (O(n^2)) ；而在输入数组 <strong>已排序</strong> 时，达到 <strong>最佳时间复杂度</strong> (O(n)) 。</p><blockquote><p>C++</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序（标志优化）*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSortWithFlag</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外循环：待排序元素数量为 n-1, n-2, ..., 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>; <span class="comment">// 初始化标志位</span></span><br><span class="line">        <span class="comment">// 内循环：冒泡操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                <span class="comment">// 这里使用了 std::swap() 函数</span></span><br><span class="line">                <span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">                flag = <span class="literal">true</span>;  <span class="comment">// 记录交换元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;     <span class="comment">// 此轮冒泡未交换任何元素，直接跳出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Python</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot; 冒泡排序（标志优化） &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort_with_flag</span>(<span class="params">nums</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 外循环：待排序元素数量为 n-1, n-2, ..., 1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        flag = <span class="literal">False</span>  <span class="comment"># 初始化标志位</span></span><br><span class="line">        <span class="comment"># 内循环：冒泡操作</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br><span class="line">                flag = <span class="literal">True</span>  <span class="comment"># 记录交换元素</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="keyword">break</span>            <span class="comment"># 此轮冒泡未交换任何元素，直接跳出</span></span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>「插入排序 Insertion Sort」是一种基于 <strong>数组插入操作</strong> 的排序算法。</p><p>「插入操作」原理：选定某个待排序元素为基准数 <code>base</code>，将 <code>base</code> 与其左侧已排序区间元素依次对比大小，并插入到正确位置。</p><p>回忆数组插入操作，我们需要将从目标索引到 <code>base</code> 之间的所有元素向右移动一位，然后再将 <code>base</code> 赋值给目标索引。</p><blockquote><p>插入操作:</p></blockquote><p><img src="https://picbed.wuzhentao.com/img/InsertionSort/p1.png" alt="p1"></p><h3 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h3><ol><li>第 1 轮先选取数组的 <strong>第 2 个元素</strong> 为 <code>base</code> ，执行「插入操作」后，<strong>数组前 2 个元素已完成排序</strong>。</li><li>第 2 轮选取 <strong>第 3 个元素</strong> 为 <code>base</code> ，执行「插入操作」后，<strong>数组前 3 个元素已完成排序</strong>。</li><li>以此类推……最后一轮选取 <strong>数组尾元素</strong> 为 <code>base</code> ，执行「插入操作」后，<strong>所有元素已完成排序</strong>。</li></ol><blockquote><p>插入排序流程</p></blockquote><p><img src="https://picbed.wuzhentao.com/img/InsertionSort/p2.png"></p><blockquote><p>C++</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 外循环：base = nums[1], nums[2], ..., nums[n-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> base = nums[i], j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 内循环：将 base 插入到左边的正确位置</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; base) &#123;</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j];  <span class="comment">// 1. 将 nums[j] 向右移动一位</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j + <span class="number">1</span>] = base;         <span class="comment">// 2. 将 base 赋值到正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法特性-1"><a href="#算法特性-1" class="headerlink" title="算法特性"></a>算法特性</h3><p><strong>时间复杂度 (O(n^2))</strong> ：最差情况下，各轮插入操作循环 (n - 1) , (n-2) , (\cdots) , (2) , (1) 次，求和为 (\frac{(n - 1) n}{2}) ，使用 (O(n^2)) 时间。</p><p><strong>空间复杂度 (O(1))</strong> ：指针 (i) , (j) 使用常数大小的额外空间。</p><p><strong>原地排序</strong>：指针变量仅使用常数大小额外空间。</p><p><strong>稳定排序</strong>：不交换相等元素。</p><p><strong>自适应排序</strong>：最佳情况下，时间复杂度为 (O(n)) 。</p><h3 id="插入排序-vs-冒泡排序"><a href="#插入排序-vs-冒泡排序" class="headerlink" title="插入排序 vs 冒泡排序"></a>插入排序 vs 冒泡排序</h3><blockquote><p>虽然「插入排序」和「冒泡排序」的时间复杂度皆为 (O(n^2)) ，但实际运行速度却有很大差别，这是为什么呢？</p></blockquote><p>回顾复杂度分析，两个方法的循环次数都是 (\frac{(n - 1) n}{2}) 。但不同的是，「冒泡操作」是在做 <strong>元素交换</strong>，需要借助一个临时变量实现，共 3 个单元操作；而「插入操作」是在做 <strong>赋值</strong>，只需 1 个单元操作；因此，可以粗略估计出冒泡排序的计算开销约为插入排序的 3 倍。</p><p>插入排序运行速度快，并且具有原地、稳定、自适应的优点，因此很受欢迎。实际上，包括 Java 在内的许多编程语言的排序库函数的实现都用到了插入排序。库函数的大致思路：</p><ul><li>对于 <strong>长数组</strong>，采用基于分治的排序算法，例如「快速排序」，时间复杂度为 (O(n \log n)) ；</li><li>对于 <strong>短数组</strong>，直接使用「插入排序」，时间复杂度为 (O(n^2)) ；</li></ul><p>在数组较短时，复杂度中的常数项（即每轮中的单元操作数量）占主导作用，此时插入排序运行地更快。这个现象与「线性查找」和「二分查找」的情况类似。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>web笔记</title>
      <link href="/post/9e43dbe9.html"/>
      <url>/post/9e43dbe9.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>学工程课涉及到的知识点比较多，方法上可以不求甚解</p><h1 id="安装配置-VSCode"><a href="#安装配置-VSCode" class="headerlink" title="安装配置 VSCode"></a>安装配置 VSCode</h1><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p><code>Live ServerAuto</code>， <code>Rename Tag</code></p><h3 id="设置自动格式化"><a href="#设置自动格式化" class="headerlink" title="设置自动格式化"></a>设置自动格式化</h3><p>点击<code>settings</code>，然后输入<code>format</code>，然后勾选上<code>Format On Save</code>。</p><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>网页首页文件一般叫：index.html</p><h3 id="用开发工具探索文档"><a href="#用开发工具探索文档" class="headerlink" title="用开发工具探索文档"></a>用开发工具探索文档</h3><p>DOM(文档对象模型)</p><p>浏览器读取了服务器返回的文档,它会创建一个文档对象模型</p><p>可以用开发者工具调整得到他们想要的样式,得到准确的值,再写入代码</p><h3 id="网站验证"><a href="#网站验证" class="headerlink" title="网站验证"></a>网站验证</h3><p>validator.w3.org 验证 html 是否规范</p><p>jigsaw.w3.org css validator 验证 css 是否规范</p><h3 id="文档结构"><a href="#文档结构" class="headerlink" title="文档结构"></a>文档结构</h3><p>html 的所有标签为树形结构,例如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web应用课<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>第一讲<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 vscode 中<code> ! + 回车</code>可以自动补全 html 结构</p><p><code>&lt;html&gt;标签</code></p><p>HTML<code>&lt;html&gt;</code>元素 表示一个 HTML 文档的根（顶级元素），所以它也被称为根元素。所有其他元素必须是此元素的后代。</p><p><code>&lt;head&gt;标签</code></p><p>HTML head 元素 规定文档相关的配置信息（元数据），包括文档的标题，引用的文档样式和脚本等。</p><p><code>&lt;body&gt;标签</code><br>HTML body 元素表示文档的内容。document.body 属性提供了可以轻松访问文档的 body 元素的脚本。</p><p><code>&lt;title&gt;标签</code><br>HTML<code> &lt;title&gt;</code> 元素 定义文档的标题，显示在浏览器的标题栏或标签页上。它只应该包含文本，若是包含有标签，则它包含的任何标签都将被忽略。</p><p><code>&lt;meta&gt;</code><br>HTML <code>&lt;meta&gt; </code>元素表示那些不能由其它 HTML 元相关（meta-related）元素（(<code>&lt;base&gt;</code>、<code>&lt;link&gt;</code>,<code> &lt;script&gt;</code>、<code>&lt;style&gt;</code> 或 <code>&lt;title&gt;</code>）之一表示的任何元数据信息。</p><p>常见属性：</p><ul><li><code>charset</code>：这个属性声明了文档的字符编码。如果使用了这个属性，其值必须是与 ASCII 大小写无关（ASCII case-insensitive）的”utf-8”。</li><li><code>name</code>：name 和 content 属性可以一起使用，以名 - 值对的方式给文档提供元数据，其中 name 作为元数据的名称，content 作为元数据的值。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;description&quot; content=&quot;算法,计算机,刷题&quot;&gt;</span><br></pre></td></tr></table></figure><p>搜索网站时,会在网站链接下显示 content 里的内容</p><p><code>icon</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;images/icon.png&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>网站 logo</p><p><code>&lt;!-- 多行注释 --&gt;</code></p><p>html 中只有多行注释</p><p><code>ctrl + /</code>将那一行注释,再次点击取消</p><p>示例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--   </span></span><br><span class="line"><span class="comment">        这里的内容均为注释</span></span><br><span class="line"><span class="comment">        &lt;h1&gt;第一讲&lt;/h1&gt;</span></span><br><span class="line"><span class="comment">        &lt;p&gt;</span></span><br><span class="line"><span class="comment">            段落。</span></span><br><span class="line"><span class="comment">        &lt;/p&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h3><p>文本标签虽然很多，但大部分可看成是预定好样式的<code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>。</p><p><code>&lt;div&gt;标签</code></p><p><code>&lt;div&gt;</code>元素 (或 HTML 文档分区元素) 是一个通用型的流内容容器，在不使用 CSS 的情况下，其对内容或布局没有任何影响。<br>其他块级标签例如：<code>&lt;h1&gt;</code>,<code> &lt;p&gt;</code>, <code>&lt;pre&gt;</code>, <code>&lt;ul&gt;</code>,<code> &lt;ol&gt;</code>, <code>&lt;table&gt;</code>。</p><p><code>&lt;span&gt;</code>标签<br><code>&lt;span&gt;</code>元素是短语内容的通用行内容器，并没有任何特殊语义。可以使用它来编组元素以达到某种样式意图（通过使用类或者 Id 属性），或者这些元素有着共同的属性，比如 lang。应该在没有其他合适的语义元素时才使用它。<code>&lt;span&gt; </code>与<code>&lt;div&gt;</code>元素很相似，但 <code>&lt;div&gt;</code> 是一个 块元素 而<code> &lt;span&gt;</code> 则是 行内元素<br>其他内联标签例如：<code>&lt;i&gt;</code>, <code>&lt;b&gt;</code>, <code>&lt;del&gt;</code>, <code>&lt;ins&gt;</code>, <code>&lt;td&gt;</code>, <code>&lt;a&gt;</code>。</p><p><code>&lt;h1&gt; - &lt;h6&gt;</code>标签<br>HTML<code>&lt;h1&gt;–&lt;h6&gt;</code>标题 (Heading) 元素呈现了六个不同的级别的标题，<code>&lt;h1&gt; </code>级别最高，而<code>&lt;h6&gt;</code>级别最低。</p><p><code>&lt;p&gt;</code>标签<br>HTML<code> &lt;p&gt;</code>元素（或者说 HTML 段落元素）表示文本的一个段落。该元素通常表现为一整块与相邻文本分离的文本，或以垂直的空白隔离或以首行缩进。另外，<code>&lt;p&gt;</code> 是块级元素。</p><blockquote><p>样式大部分是靠 CSS 实现,用标签实现的少</p></blockquote><p><code>em</code>标签</p><p>强调文本,默认是斜体</p><p><code>strong</code>标签</p><p>强调文本,默认是粗体</p><p><code>&lt;pre&gt;</code>标签<br>HTML <code>&lt;pre&gt; </code>元素表示预定义格式文本。在该元素中的文本通常按照原文件中的编排，以等宽字体的形式展现出来，文本中的空白符（比如空格和换行符）都会显示出来。(紧跟在 <code>&lt;pre&gt;</code> 开始标签后的换行符也会被省略)</p><p><code>&lt;br&gt;</code>标签<br>HTML <code>&lt;br&gt;</code> 元素在文本中生成一个换行（回车）符号。此元素在写诗和地址时很有用，这些地方的换行都非常重要。</p><p><code>&lt;hr&gt;</code>标签<br>HTML<code> &lt;hr&gt;</code> 元素表示段落级元素之间的主题转换（例如，一个故事中的场景的改变，或一个章节的主题的改变）。</p><p>在 HTML 的早期版本中，它是一个水平线。现在它仍能在可视化浏览器中表现为水平线，但目前被定义为语义上的，而不是表现层面上。所以如果想画一条横线，请使用适当的 css 样式来修饰。</p><p><code>&lt;i&gt;</code>标签<br>HTML 元素 <code>&lt;i&gt; </code>用于表现因某些原因需要区分普通文本的一系列文本。例如技术术语、外文短语或是小说中人物的思想活动等，它的内容通常以斜体显示。</p><p><code>&lt;b&gt;</code>标签<br>HTML 提醒注意（Bring Attention To）元素（<code>&lt;b&gt;</code>）用于吸引读者的注意到该元素的内容上（如果没有另加特别强调）。这个元素过去被认为是粗体（Boldface）元素，并且大多数浏览器仍然将文字显示为粗体。尽管如此，你不应将<code> &lt;b&gt;</code> 元素用于显示粗体文字；替代方案是使用 CSS font-weight 属性来创建粗体文字。</p><p><code>&lt;del&gt;</code>标签<br>HTML 的<code>&lt;del&gt;</code>标签表示一些被从文档中删除的文字内容。比如可以在需要显示修改记录或者源代码差异的情况使用这个标签。<code>&lt;ins&gt;</code>标签的作用恰恰于此相反：表示文档中添加的内容。</p><p><code>&lt;ins&gt;</code>标签<br>HTML <code>&lt;ins&gt; </code>元素定义已经被插入文档中的文本。</p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>HTML <code>&lt;img&gt;</code> 元素将一份图像嵌入文档。<br>默认为行内元素，即 display: inline。</p><p><code>src</code>属性<br>该属性是必须的，它包含了你想嵌入的图片的文件路径。</p><p><code>alt</code>属性<br>该属性包含一条对图像的文本描述，这不是强制性的，但对可访问性而言，它难以置信地有用——屏幕阅读器会将这些描述读给需要使用阅读器的使用者听，让他们知道图像的含义。如果由于某种原因无法加载图像，普通浏览器也会在页面上显示 alt 属性中的备用文本：例如，网络错误、内容被屏蔽或链接过期时。</p><p><code>height</code>属性<br>图像的高度，在 HTML5 中的单位是 CSS 像素，在 HTML 4 中既可以是像素，也可以是百分比。可以只指定 width 和 height 中的一个值，浏览器会根据原始图像进行缩放。</p><p><code>width</code>属性<br>图像的宽度，在 HTML5 中单位是 CSS 像素， 在 HTML 4 中可以是像素也可以是百分比。</p><h3 id="音频与视频"><a href="#音频与视频" class="headerlink" title="音频与视频"></a>音频与视频</h3><p><code>&lt;audio&gt;</code>标签<br>HTML<code>&lt;audio&gt; </code>元素用于在文档中嵌入音频内容。<code>&lt;audio&gt;</code>元素可以包含一个或多个音频资源， 这些音频资源可以使用 src 属性或者<code>&lt;source&gt; </code>元素来进行描述：浏览器将会选择最合适的一个来使用。也可以使用 MediaStream 将这个元素用于流式媒体。</p><ul><li>使用 src 属性播放</li></ul><p>示例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span> <span class="attr">src</span>=<span class="string">&quot;/audios/bgm.mp3&quot;</span>&gt;</span></span><br><span class="line">  Your browser does not support the</span><br><span class="line">  <span class="tag">&lt;<span class="name">code</span>&gt;</span>audio<span class="tag">&lt;/<span class="name">code</span>&gt;</span> element.</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;audio&gt;</code> 与多个 <code>&lt;source&gt; </code>元素</li></ul><p>这个例子包含了多个 <code>&lt;source&gt; </code>元素。如果能够播放的话，浏览器就会试图去加载第一个 source 元素；如果不行，那就退而求其次去加载第二个。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;/audios/sound1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;/audios/sound2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;video&gt;</code>标签<br>HTML <code>&lt;video&gt; </code>元素 用于在 HTML 或者 XHTML 文档中嵌入媒体播放器，用于支持文档内的视频播放。你也可以将 <code>&lt;video&gt; </code>标签用于音频内容，但是 <code>&lt;audio&gt;</code> 元素可能在用户体验上更合适。</p><p>示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span> <span class="attr">src</span>=<span class="string">&quot;./static/videos/program.mp4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>controls:控制开关</p><p>autoplay:自动播放</p><p>loop:循环播放</p><blockquote><p>并不是所有浏览器都支持视频播放</p></blockquote><p>给不支持视屏播放的浏览器提供一个替换文本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span> <span class="attr">src</span>=<span class="string">&quot;./static/videos/program.mp4&quot;</span>&gt;</span></span><br><span class="line">  your browser doesn&#x27;t support videos.</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>HTML <code>&lt;a&gt;</code> 元素（或称锚元素）可以通过它的 href 属性创建通向其他网页、文件、同一页面内的位置、电子邮件地址或任何其他 URL 的超链接。<code>&lt;a&gt; </code>中的内容应该指明链接的意图。如果存在 href 属性，当 <code>&lt;a&gt;</code> 元素聚焦时按下回车键就会激活它。</p><p>里面可以写其他标签,例如:img,点击图片也能跳转</p><p>常用选项</p><ul><li>点击链接打开新标签页面时加入属性：target&#x3D;”_blank”</li><li>加入属性 mailto: 邮箱, 点击链接会自动向指定邮箱发送邮件</li></ul><blockquote><p>链接和超链接的区别</p></blockquote><p>链接只是一个地址,一个 URL,定位到目标页面</p><p>超链接,是页面中完成跳转的元素</p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p><code>&lt;form&gt;</code>标签<br>HTML<code>&lt;form&gt;</code>元素表示文档中的一个区域，此区域包含交互控件，用于向 Web 服务器提交信息。</p><p><code>&lt;form action=&quot;&quot;&gt;</code>点击提交后,表单的 action 属性是在服务器上提交表单，这个属性可以被检索或者设置</p><p>如果里面填的是链接,点击提交后会跳转到链接</p><p><code>&lt;input&gt;</code>标签<br>HTML <code>&lt;input&gt;</code>用来填写内容，常见类型有：</p><ul><li><p><code>&lt;input type=&quot;text&quot;&gt;</code>：创建基础的单行文本框。</p></li><li><p><code>&lt;input type=&quot;number&quot;&gt;</code>：用于让用户输入一个数字。其包括内置验证以拒绝非数字输入。浏览器可能会选择提供步进箭头，让用户可以使用鼠标增加和减少输入的值，或者只需用指尖敲击即可。</p></li><li><p><code>&lt;input type=&quot;email&quot;&gt;</code>：带有 “email” (电子邮箱) 类型标记的输入框元素 (<code>&lt;input&gt;</code>) 能够让用户输入或编辑一个电子邮箱地址，此外，如果指定了 multiple 属性，用户还可以输入多个电子邮箱地址。在表单提交前，输入框会自动验证输入值是否是一个或多个合法的电子邮箱地址 (非空值且符合电子邮箱地址格式). CSS 伪标签 :valid 和 :invalid 能够在校验后自动应用。</p></li><li><p><code>&lt;input type=&quot;password&quot;&gt;</code>：<code>&lt;input&gt; </code>元素 里有一种叫做 “password” 的值，给我们一个方法让用户更加安全的输入密码。这个元素是作为一行纯文本编辑器控件呈现的，其中文本被遮蔽以致于无法读取，通常通过用诸如星号（“*”）或点（“•”）等符号替换每个字符来实现。这个符号会根据用户的浏览器和操作系统来具体显示哪个。</p></li><li><p><code>&lt;input type=&quot;radio&quot;&gt;</code>：<code>&lt;input&gt; </code>的 radio 类型元素默认渲染为小型圆圈图表，填充即为激活，类似于之前描述额复选框（checkbox）类型。单选按钮允许你选择单一的值来提交表单。如果,三个选项的<code>name</code>都一样那么三个里面只能选一个,如果不同则可以多选</p></li><li><p><code>&lt;input type=&quot;file&quot;&gt;</code>:选择文件</p></li></ul><p><code>&lt;labbel&gt;</code>标签一般与 input 捆绑在一块</p><p>for 里面的内容对应 id</p><p>常用属性有：</p><ul><li><code>name</code>: 名称</li><li><code>id</code>: 唯一 ID</li><li><code>maxlength</code>：最大长度</li><li><code>minlength</code>：最小长度</li><li><code>required</code>：是否必填</li><li><code>placeholder</code>：当表单控件为空时，控件中显示的内容(&#x3D;&#x3D;很有用&#x3D;&#x3D;)</li></ul><p><code>&lt;textarea&gt;</code>标签<br>HTML <code>&lt;textarea&gt;</code> 元素表示一个多行纯文本编辑控件，当你希望用户输入一段相当长的、不限格式的文本，例如评论或反馈表单中的一段意见时，这很有用。</p><p>属性:</p><ul><li>row:初始行数</li><li>col:初始列数</li></ul><p><code>&lt;select&gt;</code>与<code>&lt;option&gt;</code>标签<br>HTML<code> &lt;select&gt;</code> 元素表示一个提供选项菜单的控件。<br>示例:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">label</span> for=&quot;pet-select&quot;&gt;Choose <span class="selector-tag">a</span> pet:&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">&lt;select name=<span class="string">&quot;pets&quot;</span> id=<span class="string">&quot;pet-select&quot;</span>&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;&quot;</span>&gt;--Please choose an option--&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;dog&quot;</span>&gt;Dog&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;cat&quot;</span>&gt;Cat&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;hamster&quot;</span>&gt;Hamster&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;parrot&quot;</span>&gt;Parrot&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;spider&quot;</span>&gt;Spider&lt;/option&gt;</span><br><span class="line">    &lt;option value=<span class="string">&quot;goldfish&quot;</span>&gt;Goldfish&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;button&gt;</code>标签<br>HTML <code>&lt;button&gt;</code> 元素表示一个可点击的按钮，可以用在表单或文档其它需要使用简单标准按钮的地方。 默认情况下，HTML 按钮的显示样式接近于 user agent 所在的宿主系统平台（用户操作系统）的按钮， 但你可以使用 CSS 来改变按钮的样貌。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p><code>&lt;ul&gt;</code>与<code>&lt;li&gt;</code>标签</p><p>HTML <code>&lt;ul&gt; </code>元素（或称 HTML 无序列表元素）表示一个内可含多个元素的无序列表或项目符号列表。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;first item&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;second item&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;third item&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>常应用于表示导航栏按钮,</p><p>无序列表可以表现任何顺序无关的对象</p><p>可以列出图片,产品或者购物车</p></blockquote><p><code>&lt;ol&gt;</code>与<code>&lt;li&gt;</code>标签<br>HTML<code> &lt;ol&gt;</code>元素表示有序列表，通常渲染为一个带编号的列表。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">  &lt;li&gt;Fee&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Fi&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Fo&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Fum&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;dl&gt;</code>、<code>&lt;dt&gt;</code>与<code>&lt;dd&gt;</code>标签</p><p>HTML <code>&lt;dl&gt; </code>元素 （或 HTML 描述列表元素）是一个包含术语定义以及描述的列表，通常用于展示词汇表或者元数据 (键 - 值对列表)。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">    &lt;dt&gt;Name&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;Godzilla&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;Born&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;1952&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;Birthplace&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;Japan&lt;/dd&gt;</span><br><span class="line">    &lt;dt&gt;Color&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;Green&lt;/dd&gt;</span><br><span class="line">    &lt;dd&gt;Orange&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><code>&lt;table&gt;</code>标签<br>HTML 的 table 元素表示表格数据 — 即通过二维数据表表示的信息。</p><p><code>&lt;thead&gt;</code>标签<br>HTML 的<code>&lt;thead&gt;</code>元素定义了一组定义表格的列头的行。</p><p><code>&lt;tbody&gt;</code>标签<br>HTML 的<code>&lt;tbody&gt;</code>元素定义一组数据行。</p><p><code>&lt;tr&gt;</code>标签<br>HTML<code>&lt;tr&gt;</code>元素定义表格中的行。 同一行可同时出现<code>&lt;td&gt; </code>和<code>&lt;th&gt;</code> 元素。</p><p><code>&lt;th&gt;</code>标签<br>HTML<code> &lt;th&gt;</code>元素定义表格内的表头单元格。</p><p><code>&lt;td&gt;</code>标签<br>HTML<code>&lt;td&gt; </code>元素 定义了一个包含数据的表格单元格。</p><p><code>&lt;caption&gt;</code>标签<br>HTML<code> &lt;caption&gt;</code>元素 (or HTML 表格标题元素) 展示一个表格的标题， 它常常作为 <code>&lt;table&gt; </code>的第一个子元素出现，同时显示在表格内容的最前面，但是，它同样可以被 CSS 样式化，所以，它同样可以出现在相对于表格的任意位置。</p><p>示例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">caption</span>&gt;</span></span><br><span class="line">    My Table</span><br><span class="line">  <span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>The table header<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>The table body<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>with two columns<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="语义标签"><a href="#语义标签" class="headerlink" title="语义标签"></a>语义标签</h3><p><code>&lt;header&gt;</code><br>HTML <code>&lt;header&gt; </code>元素用于展示介绍性内容，通常包含一组介绍性的或是辅助导航的实用元素。它可能包含一些标题元素，但也可能包含其他元素，比如 Logo、搜索框、作者名称，等等。</p><p><code>&lt;nav&gt;</code><br>HTML <code>&lt;nav&gt;</code>元素表示页面的一部分，其目的是在当前文档或其他文档中提供导航链接。导航部分的常见示例是菜单，目录和索引。</p><p><code>&lt;section&gt;</code><br>HTML <code>&lt;section&gt;</code>元素表示一个包含在 HTML 文档中的独立部分，它没有更具体的语义元素来表示，一般来说会有包含一个标题。</p><p><code>main</code>表示网页的主体,每个页面只有一个 main 标签</p><p><code>&lt;figure&gt;</code><br>HTML <code>&lt;figure&gt; </code>元素代表一段独立的内容，经常与说明（caption）<code>&lt;figcaption&gt; </code>配合使用，并且作为一个独立的引用单元。当它属于主内容流（main flow）时，它的位置独立于主体。这个标签经常是在主文中引用的图片，插图，表格，代码段等等，当这部分转移到附录中或者其他页面时不会影响到主体。</p><p><code>&lt;figcaption&gt;</code><br>HTML <code>&lt;figcaption&gt; </code>元素 是与其相关联的图片的说明&#x2F;标题，用于描述其父节点<code> &lt;figure&gt;</code>元素里的其他数据。这意味着 <code>&lt;figcaption&gt; </code>在<code>&lt;figure&gt; </code>块里是第一个或最后一个。同时 HTML Figcaption 元素是可选的；如果没有该元素，这个父节点的图片只是会没有说明&#x2F;标题。</p><p><code>&lt;article&gt;</code><br>HTML <code>&lt;article&gt;</code>元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构，如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。</p><p><code>&lt;aside&gt;</code><br>HTML<code> &lt;aside&gt;</code> 元素表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者标注框（call-out boxes）。</p><p><code>&lt;footer&gt;</code><br>HTML <code>&lt;footer&gt; </code>元素表示最近一个章节内容或者根节点（sectioning root ）元素的页脚。一个页脚通常包含该章节作者、版权数据或者与文档相关的链接等信息。</p><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><table><thead><tr><th>HTML 源代码</th><th>显示结果</th><th>描述</th></tr></thead><tbody><tr><td><code>&amp;lt;</code></td><td>&lt;</td><td>小于号或显示标记</td></tr><tr><td><code>&amp;gt;</code></td><td>&gt;</td><td>大于号或显示标记</td></tr><tr><td><code>&amp;reg;</code></td><td>®</td><td>已注册</td></tr><tr><td><code>&amp;copy;</code></td><td>©</td><td>版权</td></tr><tr><td><code>&amp;trade;</code></td><td>™</td><td>商标</td></tr><tr><td><code>&amp;nbsp;</code></td><td></td><td>不断行的空白</td></tr><tr><td><code>&amp;quot;</code></td><td>“</td><td>引号</td></tr><tr><td><code>&amp;amp;</code></td><td>&amp;</td><td>可用于显示其它特殊字符</td></tr></tbody></table><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h3 id="不同的浏览器对-CSS-的渲染不同"><a href="#不同的浏览器对-CSS-的渲染不同" class="headerlink" title="不同的浏览器对 CSS 的渲染不同"></a>不同的浏览器对 CSS 的渲染不同</h3><p>为了避免这个问题,我们需要用到一个工具</p><p>normalize.css</p><p>下载,并且把文件放到项目 CSS 文件夹下</p><p>nomalize.css 只是把不同浏览器的设置统一了</p><blockquote><p>使用方法</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;normalize<span class="selector-class">.css</span>&quot;&gt;</span><br></pre></td></tr></table></figure><blockquote><p>CSS 一致化是前端开发中非常重要的一点</p></blockquote><h3 id="对象适应"><a href="#对象适应" class="headerlink" title="对象适应"></a>对象适应</h3><p>可以将对象适应设为某个值,大部分时间我们使用覆盖</p><p>这样图片就会覆盖它的容器盒子,</p><p>我们的图片尺寸会重新设置,以实现覆盖整个盒子的目的</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">object-fit</span>: cover;</span><br></pre></td></tr></table></figure><p>容器盒子:</p><p>概念上任何 HTML 元素都被包裹在一个盒子里,我们看不到盒子,</p><p>但是浏览器能根据盒子来决定如何显示页面</p><blockquote><p>绝对单位:</p><p>px</p><p>pt,打印时才有意义的单位</p><p>相对单位:</p><p>%,百分比就是于容器的大小相关的</p><p>vw 和 vh 是和显示器视域相关的</p><p>em 和 rem 是和字体相关的</p><p>fr 可用空间百分比</p></blockquote><blockquote><p>使用相对单位可以创建响应式的页面</p></blockquote><h3 id="样式定义方式"><a href="#样式定义方式" class="headerlink" title="样式定义方式"></a>样式定义方式</h3><h4 id="行内样式表（inline-style-sheet）"><a href="#行内样式表（inline-style-sheet）" class="headerlink" title="行内样式表（inline style sheet）"></a>行内样式表（inline style sheet）</h4><p>直接定义在标签的&#x3D;&#x3D;style&#x3D;&#x3D;属性中。</p><ul><li>作用范围：仅对当前标签产生影响。</li></ul><p>例如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">img</span> <span class="attribute">src</span>=&quot;/images/mountain<span class="selector-class">.jpg</span>&quot; alt=&quot;&quot; style=&quot;<span class="attribute">width</span>: <span class="number">300px</span>; <span class="attribute">height</span>: <span class="number">200px</span>;&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="内部样式表（internal-style-sheet）"><a href="#内部样式表（internal-style-sheet）" class="headerlink" title="内部样式表（internal style sheet）"></a>内部样式表（internal style sheet）</h4><p>定义在 style 标签中，通过选择器影响对应的标签。</p><p>理论在 head 标签下写,其实在 body 写也可以</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        <span class="selector-tag">img</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">            <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure><p>也可以自定义</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line"> &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">        <span class="selector-class">.big</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">70px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">70px</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">p</span> class=&quot;big&quot;&gt;<span class="number">2</span>&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">p</span> class=&quot;big&quot;&gt;<span class="number">4</span>&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">body</span>&gt;</span><br></pre></td></tr></table></figure><p>批量变化可以选择设置 class</p><ul><li>作用范围：可以对同一个页面中的多个元素产生影响。</li></ul><p>border-radius 属性:设置圆弧状,50%时就是圆形</p><p>内部样式表只能对一个网页生效,如果要批量改一个网站几百个网页,那么工作量会很高,而外部样式表可以解决</p><h4 id="外部样式表（external-style-sheet）"><a href="#外部样式表（external-style-sheet）" class="headerlink" title="外部样式表（external style sheet）"></a>外部样式表（external style sheet）</h4><p>定义在&#x3D;&#x3D;css 样式文件&#x3D;&#x3D;中，通过选择器影响对应的标签。可以用 link 标签引入某些页面。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/CSS/style<span class="selector-class">.css</span>&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>作用范围：可以对多个页面产生影响。</li></ul><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>注意不能使用&#x2F;&#x2F;。<br>只有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* 注释 */</span><br></pre></td></tr></table></figure><p>快捷键:<code>ctrl + /</code></p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h4><p>选择所有<code>div</code>标签：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a>ID 选择器</h4><p>选择 ID 为<code>rect-1</code>的标签：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#rect-1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ID 选择器与类选择器的区别:</p><p>不能有多个元素拥有同一 ID</p><p>但是多个元素可以共用一个类</p></blockquote><h4 id="类选择器-最常用"><a href="#类选择器-最常用" class="headerlink" title="类选择器(最常用)"></a>类选择器(最常用)</h4><p>选择所有<code>rectangle</code>类的标签：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.rectangle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个标签里可以填多个 class,但只能有一个 id</p><h4 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h4><p>伪类用于定义元素的特殊状态。</p><p>链接伪类选择器：</p><ul><li><code>:link</code>：链接访问前的样式</li><li><code>:visited</code>：链接访问后的样式</li><li><code>:hover</code>：鼠标悬停时的样式</li><li><code>:active</code>：鼠标点击后长按时的样式</li><li><code>:focus</code>：聚焦后的样式</li></ul><p>位置伪类选择器：</p><ul><li><code>:nth-child(n)</code>：选择是其父标签第 n 个子元素的所有元素。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child</span>(odd)&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*选中所有奇数的,even选中所有偶数的,3n每跨3个选择</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">140%</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*article标签下第一个*/</span></span><br></pre></td></tr></table></figure><blockquote><p>这种选择虽然常用但是也很脆弱</p></blockquote><p>为我们可以用另一个伪类选择器</p><ul><li><code>first-of-type</code>:会应用到不同类型标签第一次出现的地方</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">140%</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: italic;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*选择第一个p</span></span><br><span class="line"><span class="comment">如果不加p会选择article下所有第一次出现的标签*/</span></span><br></pre></td></tr></table></figure><p>目标伪类选择器：</p><ul><li><code>:target</code>：当 url 指向该元素时生效。</li></ul><p>用链接跳转到 id 为 1 的地方</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">a</span> href=&quot;<span class="selector-id">#1</span>&quot;&gt;&lt;/<span class="selector-tag">a</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h4><p>由两个及以上基础选择器组合而成的选择器。</p><ul><li><code>element1, element2</code>：同时选择元素 element1 和元素 element2。</li><li><code>element.class</code>：选则包含某类的 element 元素。</li></ul><p>element 可以是标签也可以是 id</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#id</span><span class="selector-class">.class</span> <span class="selector-tag">div</span><span class="selector-class">.class</span>;</span><br></pre></td></tr></table></figure><ul><li><code>element1 + element2</code>：选择紧跟 element1 的 element2 元素</li><li><code>element1 element2</code>：选择 element1 内的所有 element2 元素。</li><li><code>element1 &gt; element2</code>：选择父标签是 element1 的所有 element2 元素。</li><li><code>element1 ~ element2</code>:选中所有和 element1 同级的 element2 标签</li></ul><blockquote><p>缺点</p></blockquote><ul><li>代码很脆弱,稍微一点变动就不管用了</li><li>效率不如基本选择器</li></ul><h4 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器"></a>通配符选择器</h4><ul><li><code>*</code>：选择所有标签</li><li><code>[attribute]</code>：选择具有某个属性的所有标签</li><li><code>[attribute=value]</code>：选择 attribute 值为 value 的所有标签</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-attr">[lang^=<span class="string">&quot;en&quot;</span>]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line">*<span class="selector-class">.warning</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">*<span class="selector-id">#maincontent</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h4><p>将特定内容当做一个元素，选择这些元素的选择器被称为伪元素选择器。</p><ul><li><p><code>::first-letter</code>：选择第一个字母</p></li><li><p><code>::first-line</code>：选择第一行</p></li><li><p><code>::selection</code>：选择已被选中的内容</p></li><li><p><code>::after</code>：可以在元素后插入内容</p></li><li><p><code>::before</code>：可以在元素前插入内容</p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>::::first-letter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="样式渲染优先级"><a href="#样式渲染优先级" class="headerlink" title="样式渲染优先级"></a>样式渲染优先级</h4><ul><li><p>权重大小，越具体的选择器权重越大：<code>!important </code>&gt; 行内样式 &gt; ID 选择器 &gt; 类与伪类选择器 &gt; 标签选择器 &gt; 通用选择器</p></li><li><p>权重相同时，后面的样式会覆盖前面的样式</p></li><li><p>继承自父元素的权重最低</p></li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>一些 CSS 规则可以从它们的父级元素继承下来</p></blockquote><p>例如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum dolor <span class="tag">&lt;<span class="name">strong</span>&gt;</span>dolor<span class="tag">&lt;/<span class="name">strong</span>&gt;</span>&gt;sit amet consectetur<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要重复设置 strong, stong 内的元素 也会继承父元素,变红</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stong&#123;</span><br><span class="line">    <span class="attribute">color</span>: initial;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果不想继承将值设为默认值</span></span><br></pre></td></tr></table></figure><h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><h4 id="预定义的颜色值"><a href="#预定义的颜色值" class="headerlink" title="预定义的颜色值"></a>预定义的颜色值</h4><p>black、white、red、green、blue、lightblue 等。</p><h4 id="16-进制表示法"><a href="#16-进制表示法" class="headerlink" title="16 进制表示法"></a>16 进制表示法</h4><p>使用 6 位 16 进制数表示颜色，例如：<code>#ADD8E6</code>。<br>其中第 1-2 位表示红色，第 3-4 位表示绿色，第 5-6 位表示蓝色</p><p>简写方式：<code>#ABC</code>，等价于<code>#AABBCC</code>。</p><h4 id="RGB-表示法"><a href="#RGB-表示法" class="headerlink" title="RGB 表示法"></a>RGB 表示法</h4><p><code>rgb(173, 216, 230)</code>。</p><p>其中第一个数表示红色，第二个数表示绿色，第三个数表示蓝色。</p><h4 id="RGBA-表示法"><a href="#RGBA-表示法" class="headerlink" title="RGBA 表示法"></a>RGBA 表示法</h4><p><code>rgba(173, 216, 230, 0.5)</code>。</p><p>a 是透明度</p><h4 id="取色方式"><a href="#取色方式" class="headerlink" title="取色方式"></a>取色方式</h4><ul><li>网页里的颜色，可以在 chrome 的调试模式下获取</li><li>其他颜色可以使用 QQ 的截图软件：<ul><li>直接按<code>c</code>键，可以复制 rgb 颜色值</li><li>按住<code>shift</code>再按 c 键，可以复制 16 进制颜色值</li></ul></li></ul><h4 id="渐变色"><a href="#渐变色" class="headerlink" title="渐变色"></a>渐变色</h4><ul><li>渐变函数<code>linear-gradient()</code></li><li>径向渐变函数<code>radial-gradient()</code></li></ul><blockquote><p>生成渐变色的网站 cssgradient.io</p></blockquote><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><ul><li><code>box-shadow</code> 阴影到元素的水平距离</li></ul><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p><code>text-align</code><br><code>text-align</code> CSS 属性定义行内内容（例如文字）如何相对它的块父元素对齐。text-align 并不控制块元素自己的对齐，只控制它的行内内容的对齐。</p><p><code>line-height</code><br><code>line-height</code> CSS 属性用于设置多行元素的空间量，如多行文本的间距。对于块级元素，它指定元素行盒（line boxes）的最小高度。对于非替代的 inline 元素，它用于计算行盒（line box）的高度</p><ul><li>补充知识点:长度单位</li></ul><table><thead><tr><th>单位</th><th>描述</th></tr></thead><tbody><tr><td>px</td><td>设备上的像素点</td></tr><tr><td>%</td><td>相对于父元素的百分比</td></tr><tr><td>em</td><td>相对于当前元素的字体大小</td></tr><tr><td>rem</td><td>相对于根元素的字体大小</td></tr><tr><td>vw</td><td>相对于视窗宽度的百分比</td></tr><tr><td>vh</td><td>相对于视窗高度的百分比</td></tr></tbody></table><p><code>letter-spacing</code><br>CSS 的 <code>letter-spacing </code>属性用于设置文本字符的间距。</p><p><code>text-indent</code><br><code>text-indent</code>属性能定义一个块元素首行文本内容之前的缩进量。</p><p><code>text-decoration</code><br><code>text-decoration</code> 这个 CSS 属性是用于设置文本的修饰线外观的（下划线、上划线、贯穿线&#x2F;删除线 或 闪烁）它是 text-decoration-line, text-decoration-color, text-decoration-style, 和新出现的 text-decoration-thickness 属性的缩写。</p><p><code>text-shadow</code><br><code>text-shadow</code>为文字添加阴影。可以为文字与 text-decorations 添加多个阴影，阴影值之间用逗号隔开。每个阴影值由元素在 X 和 Y 方向的偏移量、模糊半径和颜色值组成。</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p><code>font-size</code><br><code>font-size</code> CSS 属性指定字体的大小。因为该属性的值会被用于计算 em 和 ex 长度单位，定义该值可能改变其他元素的大小。</p><blockquote><p>单位一般用 rem,因为能完美响应设备</p></blockquote><p><code>font-style</code><br><code>font-style</code> CSS 属性允许你选择<code> font-family</code> 字体下的 italic 或 oblique 样式。</p><p><code>font-weight</code><br><code>font-weight</code> CSS 属性指定了字体的粗细程度。 一些字体只提供 normal 和 bold 两种值。</p><p><code>font-family</code><br>CSS 属性<code> font-family</code> 允许您通过给定一个有先后顺序的，由字体名或者字体族名组成的列表来为选定的元素设置字体。<br>属性值用逗号隔开。浏览器会选择列表中第一个该计算机上有安装的字体，或者是通过 @font-face 指定的可以直接下载的字体。</p><blockquote><p>字体分类</p></blockquote><ul><li><p>衬线字体</p><ul><li>常被大量用于书籍,报纸和杂志, Georgia 和 Times 新罗马体是最常见的</li></ul></li><li><p>无衬线字体</p><ul><li>更加活泼和时尚,有 Avenir, Arial,Futura, Helvetica,Roboto</li></ul></li><li><p>等宽字体:</p><ul><li>每个字符所占的宽度是一样的</li><li>所以这是显示代码的最佳字体</li></ul></li></ul><blockquote><p>字体颜色不要设置纯黑的,可以设为灰色,对眼睛友好</p></blockquote><blockquote><p>免费字体网站</p></blockquote><p>fontsquirrel.com</p><p>在这个网站下载 TTF 格式并转换为 WOFF 后</p><p>解压会得到一个 style.css 文件,里面是使用规则</p><p>把里面的内容复制粘贴到自己 css 文件顶部</p><blockquote><p>因为要先注册字体才能使用</p><p>之后还需要自己手动修改</p></blockquote><p>字体文件分为很多格式,比如 TTF, OTF, EOT, WOFF,</p><blockquote><p>对于网站来说,最好使用 WOFF 或者 WOFF2</p><p>因为这些字体压缩比更高,在网络传输中效率更高</p></blockquote><blockquote><p>无样式字体闪现问题</p></blockquote><p>当浏览器下载自定义字体时,它会先使用一个替代字体来显示</p><blockquote><p>我们可以使用字体显示属性来告诉浏览器如何处理此类问题</p></blockquote><p>font-display: optional; (用户体验最好的选项)</p><blockquote><p>排版垂直空间</p></blockquote><p>文章与文章之间要有间隙</p><p>行之间也要也间隙</p><p>字体大小为 1rem, 行高一般设置为 1.5rem</p><p>line-height 行高</p><blockquote><p>水平排版</p></blockquote><ul><li><p>letter-spacing 字符间距</p></li><li><p>word-spacing 词间距</p></li><li><p>width 宽度</p></li></ul><p>最佳行款 50-70 个字符</p><p>width: 50ch; 意思是 50 个 0 的宽度</p><blockquote><p>文字排版</p></blockquote><ul><li>text-align 文字对齐</li><li>text-indent 文字缩进</li><li>text-decoration 文字装饰, 就是加下划线</li><li>text-transform 文字转换, 就是字符转为大写或小写</li><li>white-space 空白, 来管理换行</li><li>column-* 可以设置多列文本</li><li>direction 方向, 设置从右向左阅读的文字</li></ul><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><code>background-color</code><br>CSS 属性中的<code>background-color</code>会设置元素的背景色, 属性的值为颜色值或关键字”transparent”二者选其一。</p><p><code>background-image</code><br>CSS <code>background-image</code> 属性用于为一个元素设置一个或者多个背景图像。</p><ul><li>渐变色：<code>linear-gradient(rgba(0, 0, 255, 0.5), rgba(255, 255, 0, 0.5))</code></li></ul><p><code>background-size</code><br><code>background-size</code> 设置背景图片大小。图片可以保有其原有的尺寸，或者拉伸到新的尺寸，或者在保持其原有比例的同时缩放到元素的可用空间的尺寸。</p><p><code>background-repeat</code><br><code>background-repeat</code> CSS 属性定义背景图像的重复方式。背景图像可以沿着水平轴，垂直轴，两个轴重复，或者根本不重复。</p><p><code>background-position</code><br><code>background-position</code> 为背景图片设置初始位置。</p><p><code>background-attachment</code><br><code>background-attachment </code>CSS 属性决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动。</p><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p><code>border-style</code><br><code>border-style</code> 是一个 CSS 简写属性，用来设定元素所有边框的样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-style</span>: solid dotted inset none;</span><br></pre></td></tr></table></figure><p>顺序是上右下左</p><p>可以只写一个或任意</p><p><code>border-width</code><br><code>border-width</code>属性可以设置盒子模型的边框宽度。</p><p><code>border-color</code><br>CSS 属性<code>border-color</code> 是一个用于设置元素四个边框颜色的快捷属性： <code>border-top-color</code>, <code>border-right-color</code>, <code>border-bottom-color</code>, <code>border-left-color</code></p><p><code>border-radius</code><br>CSS 属性<code>border-radius</code>允许你设置元素的外边框圆角。当使用一个半径时确定一个圆形，当使用两个半径时确定一个椭圆。这个(椭)圆与边框的交集形成圆角效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br></pre></td></tr></table></figure><p><code>border-collapse</code><br><code>border-collapse</code> CSS 属性是用来决定表格的边框是分开的还是合并的。在分隔模式下，相邻的单元格都拥有独立的边框。在合并模式下，相邻单元格共享边框。</p><h3 id="元素展示格式"><a href="#元素展示格式" class="headerlink" title="元素展示格式"></a>元素展示格式</h3><p><code>display</code></p><ul><li><code>block</code>：<ul><li>独占一行</li><li>width、height、margin(外边距)、padding(内边距)均可控制</li><li>width 默认 100%。</li></ul></li><li><code>inline</code>：<ul><li>可以共占一行</li><li>width 与 height 无效，水平方向的 margin 与 padding 有效，竖直方向的 margin 与 padding 无效</li><li>width 默认为本身内容宽度</li></ul></li><li><code>inline-block</code><ul><li>可以共占一行</li><li>width、height、margin、padding 均可控制</li><li>width 默认为本身内容宽度</li></ul></li></ul><p><code>white-space</code><br><code>white-space</code> CSS 属性是用来设置如何处理元素中的 空白 (en-US)。</p><p><code>text-overflow</code><br><code>text-overflow</code> CSS 属性确定如何向用户发出未显示的溢出内容信号。它可以被剪切，显示一个省略号或显示一个自定义字符串。</p><blockquote><p>当你的元素是固定大小时,应该注意有可能溢出就会发生</p></blockquote><p>当你的容器元素是固定大小的,但是里面的内容却太多了,内容就不完全适配容器了</p><p><code>overflow</code><br>CSS 属性 <code>overflow</code> 定义当一个元素的内容太大而无法适应 块级格式化上下文 时候该做什么。它是<code>overflow-x</code>和<code>overflow-y</code>的 简写属性 。</p><h3 id="内边距与外边距"><a href="#内边距与外边距" class="headerlink" title="内边距与外边距"></a>内边距与外边距</h3><p><code>margin</code><br><code>margin</code>属性为给定元素设置所有四个（上下左右）方向的外边距属性。</p><ul><li><p>可以接受 1~4 个值（上、右、下、左的顺序）</p></li><li><p>可以分别指明四个方向：margin-top、margin-right、margin-bottom、margin-left</p></li><li><p>可取值</p><ul><li><p><code>length</code>：固定值</p></li><li><p><code>percentage</code>：相对于包含块的宽度，以百分比值为外边距。</p></li><li><p><code>auto</code>：让浏览器自己选择一个合适的外边距。有时，在一些特殊情况下，该值可以使元素居中。</p></li></ul></li><li><p>外边距重叠</p><ul><li>块的上外边距(margin-top)和下外边距(margin-bottom)有时合并(折叠)为单个边距，其大小为单个边距的最大值(或如果它们相等，则仅为其中一个)，这种行为称为边距折叠。</li><li>父元素与后代元素：父元素没有上边框和 padding 时，后代元素的<code>margin-top</code>会溢出，溢出后父元素的 margin-top 会与后代元素取最大值。</li></ul></li></ul><p><code>padding</code><br><code>padding</code> CSS 简写属性控制元素所有四条边的内边距区域。</p><ul><li>可以接受 1~4 个值（上、右、下、左的顺序）</li><li>可以分别指明四个方向：<code>padding-top</code>、<code>padding-right</code>、<code>padding-bottom</code>、<code>padding-left</code></li><li>可取值<ul><li><code>length</code>：固定值</li><li><code>percentage</code>：相对于包含块的宽度，以百分比值为内边距。</li></ul></li></ul><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>当浏览器渲染元素的时候，就会将它装进一个不可见的盒子</p><p>在盒子当中是内容部分，这是内容显示的地方，</p><p>如果段落中有些文字，文字就显示在这里，在内容的外面是内边距区域，是为了给内容一些外部空间，然后还有边框区域，最后是外边距区域，这是元素之间的空间</p><p><code>box-sizing</code><br>CSS 中的 <code>box-sizing</code> 属性定义了 user agent 应该如何计算一个元素的总宽度和总高度。</p><ul><li><code>content-box</code>：是默认值，设置<code>border</code>和<code>padding</code>均会增加元素的宽高。</li><li><code>border-box</code>：设置<code>border</code>和<code>padding</code>不会改变元素的宽高，而是挤占内容区域。</li></ul><blockquote><p>默认情况下,宽和高属性是给内容区域设定的,任何内边距和边框都会增加盒子的实际大小</p><p>外边距对盒子大小没有影响,它只是将盒子从别的元素旁移开</p></blockquote><p>全局设置例子</p><blockquote><p>*{}对有伪元素的不起作用</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">&#125;<span class="comment">/*不起作用</span></span><br><span class="line"><span class="comment">/*需要加上所有元素的为元素的before和after</span></span><br><span class="line"><span class="comment">*, *::before, *::after&#123;&#125; /*现在这个属性应用于所有元素以及所有元素的before和after的为元素</span></span><br></pre></td></tr></table></figure><blockquote><p>宽和高属性支队块级元素有效,块级元素占据一整行,会占满整行所有可用空间,再添加一个盒子会另起一行</p></blockquote><blockquote><p>行内元素是无法设置宽和高的,为了给它设置宽高,我们需要将它的显示模式设置为行内块级元素 display: inline-block;</p></blockquote><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p><code>position</code><br><code>CSS position</code>属性用于指定一个元素在文档中的定位方式。</p><p>定位类型：</p><ul><li>定位元素（positioned element）是其计算后位置属性为 relative, absolute, fixed 或 sticky 的一个元素（换句话说，除 static 以外的任何东西）。</li><li>相对定位元素（relatively positioned element）是计算后位置属性为 relative 的元素。</li><li>绝对定位元素（absolutely positioned element）是计算后位置属性为 absolute 或 fixed 的元素。</li><li>粘性定位元素（stickily positioned element）是计算后位置属性为 sticky 的元素。<br>取值：</li><li><code>static</code>：该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。</li><li><code>relative</code>：该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。top, right, bottom, left 等调整元素相对于初始位置的偏移量。</li><li><code>absolute</code>：元素会被移出正常文档流，并不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。</li><li><code>fixed</code>：元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。</li><li><code>sticky</code>：元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block (最近块级祖先 nearest block-level ancestor)，包括 table-related 元素，基于 top, right, bottom, 和 left 的值进行偏移。偏移值不会影响任何其他元素的位置。</li></ul><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><p><code>float</code></p><p><code>float</code> CSS 属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。该元素从网页的正常流动(文档流)中移除，尽管仍然保持部分的流动性（与绝对定位相反）。</p><p>由于 float 意味着使用块布局，它在某些情况下修改 display 值的计算值：</p><ul><li>display 为 inline 或 inline-block 时，使用 float 后会统一变成 block。</li></ul><p>取值：</p><ul><li><p>left：表明元素必须浮动在其所在的块容器左侧的关键字。</p></li><li><p>right：表明元素必须浮动在其所在的块容器右侧的关键字。</p></li></ul><p><code>clear</code><br>有时，你可能想要强制元素移至任何浮动元素下方。比如说，你可能希望某个段落与浮动元素保持相邻的位置，但又希望这个段落从头开始强制独占一行。此时可以使用<code>clear</code>。</p><p>取值：</p><ul><li><code>left</code>：清除左侧浮动。</li><li><code>right</code>：清除右侧浮动。</li><li><code>both</code>：清除左右两侧浮动</li></ul><h3 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h3><p><code>flex</code> CSS 简写属性设置了弹性项目如何增大或缩小以适应其弹性容器中可用的空间。</p><p><code>flex-direction</code><br>CSS <code>flex-direction </code>属性指定了内部元素是如何在 flex 容器中布局的，定义了主轴的方向(正方向或反方向)。</p><p>取值：</p><ul><li><code>row</code>：flex 容器的主轴被定义为与文本方向相同。 主轴起点和主轴终点与内容方向相同。</li><li><code>row-reverse</code>：表现和 row 相同，但是置换了主轴起点和主轴终点。</li><li><code>column</code>：flex 容器的主轴和块轴相同。主轴起点与主轴终点和书写模式的前后点相同</li><li><code>column-reverse</code>：表现和 column 相同，但是置换了主轴起点和主轴终点</li></ul><p><code>flex-wrap</code></p><p>CSS 的 <code>flex-wrap</code> 属性指定 flex 元素单行显示还是多行显示。如果允许换行，这个属性允许你控制行的堆叠方向。</p><p>取值：</p><ul><li><code>nowrap</code>：默认值。不换行。</li><li><code>wrap</code>：换行，第一行在上方。</li><li><code>wrap-reverse</code>：换行，第一行在下方。</li></ul><p><code>flex-flow</code><br>CSS <code>flex-flow</code> 属性是<code> flex-direction</code> 和 <code>flex-wrap</code> 的简写。默认值为：<code>row nowrap</code>。</p><p><code>justify-content</code><br>CSS<code>justify-content</code>属性定义了浏览器之间，如何分配顺着弹性容器主轴(或者网格行轴) 的元素之间及其周围的空间。</p><p>取值：</p><ul><li><code>flex-start</code>：默认值。左对齐。</li><li><code>flex-end</code>：右对齐。</li><li><code>space-between</code>：左右两段对齐。</li><li><code>space-around</code>：在每行上均匀分配弹性元素。相邻元素间距离相同。每行第一个元素到行首的距离和每行最后一个元素到行尾的距离将会是相邻元素之间距离的一半。</li><li><code>space-evenly</code>：flex 项都沿着主轴均匀分布在指定的对齐容器中。相邻 flex 项之间的间距，主轴起始位置到第一个 flex 项的间距，主轴结束位置到最后一个 flex 项的间距，都完全一样。</li></ul><p><code>align-items</code><br>CSS <code>align-items</code>属性将所有直接子节点上的 align-self 值设置为一个组。 <code>align-self</code>属性设置项目在其包含块中在交叉轴方向上的对齐方式。</p><p>取值：</p><ul><li><code>flex-start</code>：元素向主轴起点对齐。</li><li><code>flex-end</code>：元素向主轴终点对齐。</li><li><code>center</code>：元素在侧轴居中。</li><li><code>stretch</code>：弹性元素被在侧轴方向被拉伸到与容器相同的高度或宽度。</li></ul><p><code>order</code><br>定义 flex 项目的顺序，值越小越靠前。</p><p><code>flex-grow</code><br>CSS 属性 <code>flex-grow</code> CSS 设置 flex 项主尺寸 的 flex 增长系数。</p><p>负值无效，默认为 0。</p><p><code>flex-shrink</code><br>CSS flex-shrink 属性指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。</p><p>负值无效，默认为 1。</p><p><code>flex-basis</code><br>CSS 属性 flex-basis 指定了 flex 元素在主轴方向上的初始大小。</p><p>取值：<br>width 值可以是 <code>&lt;length&gt;</code>; 该值也可以是一个相对于其父弹性盒容器主轴尺寸的百分数 。负值是不被允许的。默认为 auto。</p><p><code>flex</code><br><code>flex-grow</code>、<code>flex-shrink</code>、<code>flex-basis</code>的缩写。</p><p>常用取值：</p><ul><li><code>auto</code>：<code>flex: 1 1 auto</code></li><li><code>none</code>：<code>flex: 0 0 auto</code></li></ul><h3 id="网格"><a href="#网格" class="headerlink" title="网格"></a>网格</h3><p>常用于设置照片墙布局</p><blockquote><p>再网格中,我们需要一个容器,将容器的显示模式设为网格</p></blockquote><blockquote><p>display:grid</p><p>grid-template-rows</p><p>grid-template-columns</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid lightgrey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想修改列的大小就需要修改两个地方,</p><p>更好的方法是使用 repeat 函数</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">100px</span>);</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100px</span>);</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">3px</span> solid lightgrey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>grid-template(这是设置模板行和列的缩写)</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">grid-template</span>: <span class="built_in">repeat</span>(<span class="number">3</span>, <span class="number">100px</span>) / <span class="built_in">repeat</span>(<span class="number">2</span>, <span class="number">100px</span>);</span><br></pre></td></tr></table></figure><p>元素:</p><blockquote><p>justify-items(横轴对齐)</p><p>align-items(纵轴对齐)</p></blockquote><p>网格整体:</p><blockquote><p>justify-content(横轴对齐)</p><p>align-content(纵轴对齐)</p></blockquote><p>间隔:</p><blockquote><p>row-gap</p><p>column-gap</p><p>gap(行间隔和列间隔的缩写)</p></blockquote><p>合并单元格:</p><blockquote><p>grid-row</p><p>grid-column</p><p>grid-area(合并区域)</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">grid-column</span>: <span class="number">1</span> / span <span class="number">3</span>;<span class="comment">/*占据1到3列*/</span></span><br><span class="line"><span class="attribute">grid-row</span>: <span class="number">2</span> / span <span class="number">4</span>; <span class="comment">/*占据2到4行*/</span></span><br><span class="line"><span class="attribute">grid-area</span>: <span class="number">1</span> / <span class="number">1</span> / <span class="number">1</span>/ <span class="number">3</span>; <span class="comment">/*头两个数字代表起始位置,后两个数字代表结束位置</span></span><br></pre></td></tr></table></figure><blockquote><p>另一个合并方式:先指定一个特殊范围,再用元素来填充</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">grid-template-areas</span>:</span><br><span class="line">  <span class="string">&quot;header header&quot;</span></span><br><span class="line">  <span class="string">&quot;sidebar main&quot;</span></span><br><span class="line">  <span class="string">&quot;footer footer&quot;</span>;</span><br><span class="line"><span class="comment">/*给单元格起名*/</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box-one</span>&#123;</span><br><span class="line">    <span class="attribute">grid-area</span>: header;</span><br><span class="line">&#125;<span class="comment">/*直接写名字,不用引号,否则不会识别</span></span><br></pre></td></tr></table></figure><h3 id="隐藏元素"><a href="#隐藏元素" class="headerlink" title="隐藏元素"></a>隐藏元素</h3><blockquote><p>第一种方法设置 display: none;</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.first</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第二种方法设置属性不可见 visibility: visible</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.first</span> &#123;</span><br><span class="line">  <span class="attribute">visibility</span>: visible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>区别</p></blockquote><p>第一种,后面的元素会占据隐藏元素的位置</p><p>第二种,后面的元素不会占据隐藏元素的位置</p><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><blockquote><p>使用媒体查询,可以在不同设备上提供不同样式,取决于它们的分辨率</p></blockquote><p>有了它,就可以创建在手机,平板或者 PC 上都完美的网页</p><p>我们称这种网页叫响应式网页,因为它可以针对不同介质做出调整</p><p>创建响应式网页是需要有针对性的,</p><p>我们可以优先设计桌面网页,而针对平板和手机进行调整</p><p>不同的网页设计思路不同</p><p>但是大部分人都是以手机页面为主的,</p><p>因为创建手机页面要简单的多</p><blockquote><p>媒体查询</p><p>需要设置中止点</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">600px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">900px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果条件满足最小宽度 600px,最大宽度 900px</p><p>大括号中的样式就会执行,否则就不会执行</p><p>当屏幕小于 600px 或大于 900px 就变成纵向排列,否则就是横向</p><blockquote><p>案例:</p><p>将媒体类型设置为打印机</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> print &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12pt</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: white;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结</p></blockquote><ul><li>使用媒体查询,可以检查当前设备的类型以及大小</li><li>然后提供只在某些场合下使用的样式</li></ul><p>或者</p><p>使用 Bootstrap</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建</title>
      <link href="/post/afcbc60d.html"/>
      <url>/post/afcbc60d.html</url>
      
        <content type="html"><![CDATA[<h1 id="环境与工具准备"><a href="#环境与工具准备" class="headerlink" title="环境与工具准备"></a>环境与工具准备</h1><p><strong>本教程主要面对的是 Windows 用户</strong></p><ul><li>操作系统：Windows10</li><li>Node</li><li>Git</li><li>Hexo</li><li>文本编辑器(强烈推荐 VSCODE)</li><li>GitHub 帐号</li><li>一个域名（强烈推荐买个域名）</li><li>云服务器（可选）</li></ul><h1 id="Node-的安装"><a href="#Node-的安装" class="headerlink" title="Node 的安装"></a>Node 的安装</h1><ol><li><p>打开 Node 官网，下载和自己系统相配的 Node 的安装程序，否则会出现安装问题。下载地址：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><br>我个人的版本是 12.19.0，目前版本已经更新到 19.0.0，按照个人经验，可以选个低一些的版本，可以和我的一样，否则后面会出现各种不兼容的问题！我之前就是安装 16 的，系统无法识别，如果大家遇到问题建议选个低版本的！历史版本下载页面：<a href="https://nodejs.org/en/download/releases/">https://nodejs.org/en/download/releases/</a><br><a href="https://s1.vika.cn/space/2022/10/27/876780920daf4f8fb319d49ff68f17a3"><img src="https://s1.vika.cn/space/2022/10/27/876780920daf4f8fb319d49ff68f17a3" alt="image-20221027173738226"></a></p></li><li><p>下载后安装，安装的目录可以使用默认目录【C:&#x2F;Program Files&#x2F;nodejs&#x2F;】，也可以自定义路径。<br>这个环境路径切换坑也很多，如果大家 C 盘空间足够可以直接装 C 盘，如果想切换其他盘或者把环境遍历切换到自定义路径也可以，具体教程百度(不过坑比较多就是了)!</p></li><li><p>安装完成后，检查是否安装成功。在键盘按下 win + R 键，输入 CMD，然后回车，打开 CMD 窗口，执行 node -v 命令，看到版本信息，则说明安装成功。</p></li><li><p>修改 npm 源。npm 下载各种模块，默认是从国处服务器下载，速度较慢，建议配置成淘宝镜像。打开 CMD 窗口，运行如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li></ol><h1 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h1><ol><li><p>在<code>Git BASH</code>输入如下命令安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li><li><p>安装完后输入 hexo -v 验证是否安装成功。</p></li></ol><p><a href="https://s1.vika.cn/space/2022/10/27/f05830f48da44ea98d2a55c3a6663004"><img src="https://s1.vika.cn/space/2022/10/27/f05830f48da44ea98d2a55c3a6663004" alt="image-20221027173525181"></a></p><h1 id="Github-注册与创建仓库"><a href="#Github-注册与创建仓库" class="headerlink" title="Github 注册与创建仓库"></a>Github 注册与创建仓库</h1><ol><li>进入官网 <a href="https://github.com/">https://github.com/</a><br><a href="https://bu.dusays.com/2022/05/12/627d2c0449341.webp"><img src="https://bu.dusays.com/2022/05/12/627d2c0449341.webp" alt="Github注册"></a></li><li>点击右上角的 Sign up(注册)<br><a href="https://bu.dusays.com/2022/05/12/627d2c05ee628.png"><img src="https://bu.dusays.com/2022/05/12/627d2c05ee628.png" alt="Github注册"></a></li><li>填写自己的邮箱、密码、用户名等信息，然后用邮箱验证即可完成。</li><li>注册完成后，点击右上角的<code>+</code>按钮，选择<code>New repository</code>，创建一个<code>&lt;用户名&gt;.github.io</code>的仓库。</li></ol><p><a href="https://s1.vika.cn/space/2022/10/27/7a06143d180d47088833a486732dccf5"><img src="https://s1.vika.cn/space/2022/10/27/7a06143d180d47088833a486732dccf5" alt="image-20221027110619071"></a></p><ul><li>仓库的格式必须为：<code>&lt;用户名&gt;.github.io</code> (注意：前缀必须为用户名，不要等后面 404 了再来为什么！！！)</li><li>Description：为描述仓库（选填）</li><li>勾选 Initialize this repository with a README 初始化一个 <a href="http://readme.md/">README.md</a> 文件</li><li>点击 Creat repository 进行创建</li></ul><p><a href="https://s1.vika.cn/space/2022/10/27/0a4dbb10ca69422ca9ccb7493d0f177a"><img src="https://s1.vika.cn/space/2022/10/27/0a4dbb10ca69422ca9ccb7493d0f177a" alt="image-20221027111641909"></a></p><h1 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h1><ol><li><p>进入官网：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> ，由于官网下载太慢可以通过淘宝的开源镜像下载 网址：<a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/v2.36.1.windows.1/">https://registry.npmmirror.com/binary.html?path=git-for-windows/v2.36.1.windows.1/</a> ，下载版本更具自己的需求选择即可。</p><p><a href="https://s1.vika.cn/space/2022/10/27/28a7d7e6ef3f4df080da8d7e8337431b"><img src="https://s1.vika.cn/space/2022/10/27/28a7d7e6ef3f4df080da8d7e8337431b" alt="image-20221027111755697"></a></p></li><li><p>下载后傻瓜式安装 Git 即可，安装的目录可以使用默认目录【C:&#x2F;Program Files&#x2F;Git】，也可以自定义路径。</p></li><li><p>点击电脑左下角开始即可看见<code>Git Bash</code>。</p></li></ol><p><a href="https://bu.dusays.com/2022/05/13/627d410ddc940.webp"><img src="https://bu.dusays.com/2022/05/13/627d410ddc940.webp" alt="Git Bash"></a></p><ul><li><code>Git CMD</code> 是 windows 命令行的指令风格</li><li><code>Git Bash</code> 是 linux 系统的指令风格（建议使用）</li><li><code>Git GUI</code>是图形化界面（新手学习不建议使用）</li></ul><ol><li><p>常用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">git config -l  //查看所有配置</span><br><span class="line">git config --system --list //查看系统配置</span><br><span class="line">git config --global --list //查看用户（全局）配置</span><br></pre></td></tr></table></figure></li><li><p>配置用户名和邮箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>git config -l</code> 检查是否配置成功，至此 git 安装及配置全部完成。</p><p><a href="https://s1.vika.cn/space/2022/10/27/9115d60b377a47f3a8b79779a287ee65"><img src="https://s1.vika.cn/space/2022/10/27/9115d60b377a47f3a8b79779a287ee65" alt="image-20221027112049822"></a></p></li></ol><h1 id="连接至-Github"><a href="#连接至-Github" class="headerlink" title="连接至 Github"></a>连接至 Github</h1><ol><li><p>执行以下命令生成 ssh 公钥，此公钥用于你的计算机连接 Github</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p>之后打开 C 盘下用户文件夹下的.ssh 的文件夹，会看到 id_rsa.pub</p><p><a href="https://bu.dusays.com/2022/05/14/627e87126fc59.png"><img src="https://bu.dusays.com/2022/05/14/627e87126fc59.png" alt="公钥"></a></p><p>用记事本打开上述图片中的公钥（id_rsa.pub），复制里面的内容，然后开始在 github 中配置 ssh 密钥。</p><p><a href="https://bu.dusays.com/2022/05/14/627e87156038a.png"><img src="https://bu.dusays.com/2022/05/14/627e87156038a.png" alt="记事本打开公钥"></a></p></li><li><p>将 SSH KEY 配置到 GitHub<br>进入 github，点击右上角头像 选择<code>settings</code>，进入设置页后选择 <code>SSH and GPG keys</code>，名字随便起，公钥填到<code>Key</code>那一栏。</p><p><img src="https://s1.vika.cn/space/2022/10/27/4a69d999fed54ff78a5b84805d3c6a12" alt="image-20221027112347632"></p><p><a href="https://s1.vika.cn/space/2022/10/27/aa20ae7d8db34e2596638f5f031f0814"><img src="https://s1.vika.cn/space/2022/10/27/aa20ae7d8db34e2596638f5f031f0814" alt="image-20221027112416710"></a></p><p><a href="https://s1.vika.cn/space/2022/10/27/eaccde8a10eb4cde945a1ed221bb6ace"><img src="https://s1.vika.cn/space/2022/10/27/eaccde8a10eb4cde945a1ed221bb6ace" alt="image-20221027112657256"></a></p></li><li><p>测试连接，输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><a href="https://s1.vika.cn/space/2022/10/27/122bb1ef33074bee84030a525ce1ec56"><img src="https://s1.vika.cn/space/2022/10/27/122bb1ef33074bee84030a525ce1ec56" alt="image-20221027112918539"></a></p><p>出现连接到账户的信息，说明已经大功告成，至此完成了环境准备工作。</p></li></ol><h1 id="初始化-Hexo-项目"><a href="#初始化-Hexo-项目" class="headerlink" title="初始化 Hexo 项目"></a>初始化 Hexo 项目</h1><ol><li><p>在目标路径（我这里选的路径为【C:&#x2F;Hexo-Blog】）打开 cmd 命令窗口，执行<code>hexo init</code>初始化项目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">hexo init blog-demo(项目名)</span><br></pre></td></tr></table></figure><p><a href="https://s1.vika.cn/space/2022/10/27/1fbeb52671cf4b1daeca3660d1a31a2f"><img src="https://s1.vika.cn/space/2022/10/27/1fbeb52671cf4b1daeca3660d1a31a2f" alt="image-20221027113206776"></a></p></li><li><p>进入<code>blog-demo</code> ，输入<code>npm i</code>安装相关依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">cd blog-demo  //进入blog-demo文件夹</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p><a href="https://s1.vika.cn/space/2022/10/27/150eeb3e61c94b89a1cad2a3079b1f94"><img src="https://s1.vika.cn/space/2022/10/27/150eeb3e61c94b89a1cad2a3079b1f94" alt="image-20221027113331624"></a></p></li><li><p>初始化项目后，<code>blog-demo</code>有如下结构：</p></li></ol><p><a href="https://s1.vika.cn/space/2022/10/27/70cf503f27c54d30a31c6b13735023b7"><img src="https://s1.vika.cn/space/2022/10/27/70cf503f27c54d30a31c6b13735023b7" alt="image-20221027113438707"></a></p><p>【node_modules】：依赖包<br>【scaffolds】：生成文章的一些模板<br>【source】：用来存放你的文章<br>【themes】：主题<br>【.npmignore】：发布时忽略的文件（可忽略）<br>【_config.landscape.yml】：主题的配置文件<br>【config.yml】：博客的配置文件<br>【package.json】：项目名称、描述、版本、运行和开发等信息</p><ol><li><p>输入 hexo server 或者 hexo s 启动项目</p><p><a href="https://s1.vika.cn/space/2022/10/27/688592f6db1448d29a2f722fc7a0bb0a"><img src="https://s1.vika.cn/space/2022/10/27/688592f6db1448d29a2f722fc7a0bb0a" alt="image-20221027113534970"></a></p></li><li><p>打开浏览器，输入地址：<a href="http://localhost:4000/">http://localhost:4000/</a> ，看到下面的效果，说明你的博客已经构建成功了。</p><p><a href="https://bu.dusays.com/2022/05/26/628e5423df640.webp"><img src="https://bu.dusays.com/2022/05/26/628e5423df640.webp" alt="博客首页"></a></p></li></ol><h1 id="将静态博客挂载到-GitHub-Pages"><a href="#将静态博客挂载到-GitHub-Pages" class="headerlink" title="将静态博客挂载到 GitHub Pages"></a>将静态博客挂载到 GitHub Pages</h1><ol><li><p>安装 hexo-deployer-git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>修改 _config.yml 文件<br>在 blog-demo 目录下的_config.yml，就是整个 Hexo 框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的<a href="https://hexo.io/zh-cn/docs/configuration">配置描述</a>。<br>修改最后一行的配置，将 repository 修改为你自己的 github 项目地址即可，还有分支要改为<code>main</code>代表主分支（注意缩进）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:Fomalhaut-Blog/Fomalhaut-Blog.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure></li><li><p>修改好配置后，运行如下命令，将代码部署到 GitHub（Hexo 三连）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy  // Git BASH终端</span><br><span class="line">hexo clean; hexo generate; hexo deploy  // VSCODE终端</span><br></pre></td></tr></table></figure><ul><li><p>hexo clean：删除之前生成的文件，若未生成过静态文件，可忽略此命令。</p></li><li><p>hexo generate：生成静态文章，可以用<code>hexo g</code>缩写</p></li><li><p>hexo deploy：部署文章，可以用<code>hexo d</code>缩写</p><p><a href="https://s1.vika.cn/space/2022/10/27/7ed7b8256d75408aa86e90cd37d0ea53"><img src="https://s1.vika.cn/space/2022/10/27/7ed7b8256d75408aa86e90cd37d0ea53" alt="image-20221027113704801"></a></p><p>注意：deploy 时可能要你输入 username 和 password。</p><p>如果出现<code>Deploy done</code>，则说明部署成功了。</p><p><a href="https://s1.vika.cn/space/2022/10/27/85b61e7242214d368539d744b4778a5d"><img src="https://s1.vika.cn/space/2022/10/27/85b61e7242214d368539d744b4778a5d" alt="image-20221027113756069"></a></p><p>稍等两分钟，打开浏览器访问：<a href="https://fomalhaut-blog.github.io/">https://Fomalhaut-Blog.github.io</a> ，这时候我们就可以看到博客内容了。</p><p><a href="https://s1.vika.cn/space/2022/10/27/6de50dfe03604b07aa26fb7dd5fe1f99"><img src="https://s1.vika.cn/space/2022/10/27/6de50dfe03604b07aa26fb7dd5fe1f99" alt="image-20221027113923949"></a></p></li></ul></li></ol><h2 id="10-无法连接至-Github-的解决方案"><a href="#10-无法连接至-Github-的解决方案" class="headerlink" title="10. 无法连接至 Github 的解决方案"></a>10. 无法连接至 Github 的解决方案</h2><p>注意：当你在与 Github 进行 ssh 通信时候出现超时或者是连接被关闭的情况，可以尝试以下解决方案。</p><ol><li><p>挂代理和换网络（这个就不用多说了）</p></li><li><p><a href="https://blog.csdn.net/weixin_41287260/article/details/124368189">Git 问题：解决“ssh:connect to host github.com port 22: Connection timed out”</a></p><p>这是评论区的朋友提供的，可以解决 SSH 连接超时等问题</p></li><li><p>开源项目<a href="https://github.com/521xueweihan/GitHub520">Github520</a></p><p>通过修改 Host 文件的方法解决访问速度慢的问题</p></li></ol><p>连接有效性检验：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 任选其一即可</span><br><span class="line">ping github.com</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/post/5751eea2.html"/>
      <url>/post/5751eea2.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><strong>问题 1</strong>：c++头文件为什么没有.h？</p><p>​ 在 c 语言中头文件使用扩展名.h,将其作为一种通过名称标识文件类型的简单方式。但是 c++得用法改变了，c++头文件没有扩展名。但是有些 c 语言的头文件被转换为 c++的头文件，这些文件被重新命名，丢掉了扩展名.h(使之成为 c++风格头文件)，并在文件名称前面加上前缀 c(表明来自 c 语言)。例如 c++版本的 math.h 为 cmath.</p><p>​ 由于 C 使用不同的扩展名来表示不同文件类型，因此用一些特殊的扩展名(如 hpp 或 hxx)表示 c++的头文件也是可以的，ANSI&#x2F;IOS 标准委员会也认为是可以的，但是关键问题是用哪个比较好，最后一致同意不适用任何扩展名。</p><table><thead><tr><th>头文件类型</th><th>约定</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>c++旧式风格</td><td>以.h 结尾</td><td>iostream.h</td><td>c++程序可用</td></tr><tr><td>c 旧式风格</td><td>以.h 结尾</td><td>math.h</td><td>c&#x2F;c++程序可用</td></tr><tr><td>c++新式风格</td><td>无扩展名</td><td>iostream</td><td>c++程序可用，使用 namespace std</td></tr><tr><td>转换后的 c</td><td>加上前缀 c,无扩展名</td><td>cmath</td><td>c++程序可用，可使用非 c 特性，如 namespace std</td></tr></tbody></table><p><strong>问题 2</strong>：using namespace std 是什么?</p><p>​ namespace 是指标识符的各种可见范围。命名空间用关键字 namespace 来定义。命名空间是 C++的一种机制，用来把单个标识符下的大量有逻辑联系的程序实体组合到一起。此标识符作为此组群的名字。</p><p><strong>问题 3</strong>：cout 、endl 是什么？</p><p>​ cout 是 c++中的标准输出流，endl 是输出换行并刷新缓冲区。</p><h1 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h1><blockquote><p>封装</p></blockquote><ul><li><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p></li><li><p>类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态。</p></li></ul><blockquote><p>继承</p></blockquote><ul><li><p>继承所表达的是类之间相关的关系，这种关系使得对象可以继承另外一类对象的特征和能力。</p></li><li><p>继承的作用：避免公用代码的重复开发，减少代码和数据冗余。</p></li></ul><blockquote><p>多态</p></blockquote><ul><li>多态性可以简单地概括为“一个接口，多种方法”，字面意思为多种形态。程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。</li></ul><h1 id="C-对-C-的扩展"><a href="#C-对-C-的扩展" class="headerlink" title="C++对 C 的扩展"></a>C++对 C 的扩展</h1><h3 id="作用域运算符"><a href="#作用域运算符" class="headerlink" title="::作用域运算符"></a>::作用域运算符</h3><blockquote><p>通常情况下，如果有两个同名变量，一个是全局变量，</p><p>另一个是局部变量，那么局部变量在其作用域内具有较高的优先权，</p><p>它将屏蔽全局变量。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//1. 局部变量和全局变量同名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//打印局部变量a</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="comment">//打印全局变量a</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量a:&quot;</span> &lt;&lt; ::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>作用域运算符可以用来解决局部变量与全局变量的重名问题，</p></blockquote><p>即在局部变量的作用域内，可用::对被屏蔽的同名的全局变量进行访问。</p><h3 id="C-命名空间-namespace"><a href="#C-命名空间-namespace" class="headerlink" title="C++命名空间(namespace)"></a>C++命名空间(namespace)</h3><blockquote><p>命名空间的用途:解决名称冲突</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::a : &quot;</span> &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间可以嵌套</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::B::a : &quot;</span> &lt;&lt; A::B::a &lt;&lt; endl;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间下可以存储 变量, 函数,结构体,类…..</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数的声明和实现可分离</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MySpace&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> param)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySpace::func2</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MySpace::func2 : &quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间必须声明在全局作用域下</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//namespace B  //不能定义在局部中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间是开放的,可以随时向空间中添加新成员</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间可以是匿名的,只能在本文件内访问</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line">cout &lt;&lt; ::b;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间可以起别名</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> veryLongName&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> shortName = veryLongName;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;veryLongName::a : &quot;</span> &lt;&lt; shortName::a &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><blockquote><p>using 声明</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LOL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sunWuKongId = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int sunWuKongId = 2; 会报错</span></span><br><span class="line">    <span class="comment">//using声明和就近原则不要同时出现,尽量避免这种情况</span></span><br><span class="line">    <span class="keyword">using</span> LOL::sunWuKongId;</span><br><span class="line">    cout &lt;&lt; sunWuKongId &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>using 编译指令</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int sunWuKongId = 2; 会输出2, 就近原则</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> LOL;</span><br><span class="line">cout &lt;&lt; sunWuKongId &lt;&lt;endl;</span><br><span class="line"><span class="comment">//using编译指令和就近原则同时出现,优先使用就近原则</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LOL和KingGlory里都有sunWuKongId</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> LOL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> KingGlory;</span><br><span class="line">cout &lt;&lt; LOL::sunWuKongId &lt;&lt;endl;</span><br><span class="line"><span class="comment">//当出现多个编译指令,并且出现同名情况,使用数据依然加zon</span></span><br></pre></td></tr></table></figure><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><h3 id="内联函数引出"><a href="#内联函数引出" class="headerlink" title="内联函数引出"></a>内联函数引出</h3><blockquote><p>在 c 中我们经常把一些短并且执行频繁的计算写成宏，而不是函数，这样做的理由是为了执行效率，宏可以避免函数调用的开销，这些都由预处理来完成。</p></blockquote><p>但是在 c++出现之后，使用预处理宏会出现两个问题：</p><ul><li><p>第一个在 c 中也会出现，宏看起来像一个函数调用，但是会有隐藏一些难以发现的错误。</p></li><li><p>第二个问题是 c++特有的，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类类的成员函数。</p></li></ul><p>为了保持预处理宏的效率又增加安全性，而且还能像一般成员函数那样可以在类里访问自如，c++引入了内联函数(inline function).</p><p>内联函数为了继承宏函数的效率，没有函数调用时开销，然后又可以像普通函数那样，可以进行参数，返回值类型的安全检查，又可以作为成员函数。</p><h3 id="预处理宏的缺陷"><a href="#预处理宏的缺陷" class="headerlink" title="预处理宏的缺陷"></a>预处理宏的缺陷</h3><blockquote><p>问题一:需要加括号保证运算的完整</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(x,y) x+y</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ret1 = <span class="built_in">ADD</span>(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span>; <span class="comment">//希望的结果是300</span></span><br><span class="line">    <span class="comment">//展开变成了 10 + 20 * 10</span></span><br><span class="line"><span class="type">int</span> ret2 = <span class="built_in">Add</span>(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span>; <span class="comment">//希望结果也是300</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret1:&quot;</span> &lt;&lt; ret1 &lt;&lt; endl; <span class="comment">//210</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret2:&quot;</span> &lt;&lt; ret2 &lt;&lt; endl; <span class="comment">//300</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解决方案, 需要加括号保证运算的完整</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(x,y) ((x) + (y))</span></span><br></pre></td></tr></table></figure><blockquote><p>问题二:即使加了括号,有些情况依然与预期效果不符</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COMPARE(x,y) ((x) &lt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Compare</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;COMPARE(++a, b):&quot; &lt;&lt; COMPARE(++a, b) &lt;&lt; endl; // 3</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Compare(int x,int y):&quot;</span> &lt;&lt; <span class="built_in">Compare</span>(++a, b) &lt;&lt; endl; <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为宏展开后是((++a) &lt; (b) ? (++a) : (b))</span></span><br></pre></td></tr></table></figure><h3 id="内联函数基本概念"><a href="#内联函数基本概念" class="headerlink" title="内联函数基本概念"></a>内联函数基本概念</h3><p>在 c++中，预定义宏的概念是用内联函数来实现的，而<strong>内联函数本身也是一个真正的函数</strong>。内联函数具有普通函数的所有行为。唯一不同之处在于内联函数会在适当的地方像预定义宏一样展开，所以不需要函数调用的开销。因此应该不使用宏，使用内联函数。</p><ul><li>在普通函数(非成员函数)函数前面加上 inline 关键字使之成为内联函数。</li><li>但是必须注意必须函数体和声明结合在一起，否则编译器将它作为普通函数来对待。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure><p>以上写法没有任何效果，仅仅是声明函数，应该如下方式来做:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="keyword">return</span> ++;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意: 编译器将会检查函数参数列表使用是否正确，并返回值(进行必要的转换)。这些事预处理器无法完成的。</p></li><li><p>内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用时候的压栈，跳转，返回的开销。我们可以理解为内联函数是以<strong>空间换时间</strong>。</p></li></ul><p>总结:</p><blockquote><p>内联函数优点</p></blockquote><p>解决了宏的缺陷,因为是普通函数,又带来了宏的优点,以空间换时间</p><blockquote><p>关键字 inline</p></blockquote><blockquote><p>函数的声明和函数的实现同时拥有 inline 才算内联</p></blockquote><h3 id="类内部的内联函数"><a href="#类内部的内联函数" class="headerlink" title="类内部的内联函数"></a>类内部的内联函数</h3><blockquote><p>类内部的成员函数,都隐藏的加了 inline 关键字</p><p>任何在类内部定义的函数自动成为内联函数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()&#123; cout &lt;&lt; <span class="string">&quot;构造函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;输出Person!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内联函数和编译器"><a href="#内联函数和编译器" class="headerlink" title="内联函数和编译器"></a>内联函数和编译器</h3><blockquote><p>c++内联编译会有一些限制，以下情况编译器可能考虑不会将函数进行内联编译：</p></blockquote><ul><li>不能存在任何形式的循环语句</li><li>不能存在过多的条件判断语句</li><li>函数体不能过于庞大</li><li>不能对函数进行取址操作</li></ul><p><strong>内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。</strong></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 5;</span><br><span class="line">int&amp; ref = a;</span><br></pre></td></tr></table></figure><p>ref 并不是一个变量,只是 a 的别名,并不占用内存空间</p><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><h3 id="把引用作为参数"><a href="#把引用作为参数" class="headerlink" title="把引用作为参数"></a>把引用作为参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> temp;</span><br><span class="line">   temp = x; <span class="comment">/* 保存地址 x 的值 */</span></span><br><span class="line">   x = y;    <span class="comment">/* 把 y 赋值给 x */</span></span><br><span class="line">   y = temp; <span class="comment">/* 把 x 赋值给 y  */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h3 id="stringstream-用法"><a href="#stringstream-用法" class="headerlink" title="stringstream 用法"></a>stringstream 用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b, c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getline</span>(cin, a);</span><br><span class="line">    cin &gt;&gt; b &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function">stringstream <span class="title">ssin</span><span class="params">(a)</span></span>;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span> (ssin &gt;&gt; str)</span><br><span class="line">        <span class="keyword">if</span> (str == b) cout &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; str &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>stringstream ssin(a); 将字符串初始化成字符串流</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swapping ostringstream objects</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>       <span class="comment">// std::string</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>      <span class="comment">// std::stringstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::stringstream ss;</span><br><span class="line"></span><br><span class="line">  ss &lt;&lt; <span class="number">100</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> foo,bar;</span><br><span class="line">  ss &gt;&gt; foo &gt;&gt; bar;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;foo: &quot;</span> &lt;&lt; foo &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;bar: &quot;</span> &lt;&lt; bar &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><blockquote><p>foo: 100<br>bar: 200</p></blockquote><h4 id="从-string-对象-str-中读取字符。遇空格结束"><a href="#从-string-对象-str-中读取字符。遇空格结束" class="headerlink" title="从 string 对象 str 中读取字符。遇空格结束"></a>从 string 对象 str 中读取字符。遇空格结束</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>; <span class="comment">//将str复制到ss</span></span><br><span class="line">string abc;</span><br><span class="line"><span class="keyword">while</span>(ss &gt;&gt; abc) <span class="comment">//相当于输入一个个的单词</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; abc &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>OUTPUT:</p><blockquote><p>hello world</p><p>hello</p><p>world</p></blockquote><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><blockquote><p>若使用普通的变量来存储的话，数据是分散的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br></pre></td></tr></table></figure><blockquote><p>但是，使用 struct 关键词，可以聚合这几种数据类型成为一个新的数据类型。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面这一串结构类型虽然很长，但是，就相当于 int 类型一样。 如同在 int 后填变量名可以声明一个整型变量。 在结构类型后面填写变量名可以声明一个结构变量。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;timmy;</span><br></pre></td></tr></table></figure><p>timmy 是由该结构声明的变量，它由 4 个成员组成。</p><p><strong>使用成员运算符 . 加上 字段名 可以访问到结构的各个成员。</strong></p><blockquote><p>timmy.name;</p><p>timmy.gender;</p><p>timmy.height;</p><p>timmy.weight;</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;timmy;</span><br><span class="line"><span class="comment">// 将Timmy的数据装入结构变量</span></span><br><span class="line"><span class="built_in">strcpy</span>(timmy.name, <span class="string">&quot;Timmy&quot;</span>);</span><br><span class="line">timmy.gender = <span class="number">1</span>;</span><br><span class="line">timmy.height = <span class="number">170.00</span>;</span><br><span class="line">timmy.weight = <span class="number">60</span>;</span><br><span class="line"><span class="comment">// 从结构变量中显示Timmy的数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, timmy.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.weight);</span><br></pre></td></tr></table></figure><h3 id="结构别名"><a href="#结构别名" class="headerlink" title="结构别名"></a>结构别名</h3><p>现在，我们想定义多个人员信息结构变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;timmy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;david;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;jane;</span><br></pre></td></tr></table></figure><blockquote><p>由于这几个结构变量的内部成员都是一致的，能不能只声明一次结构类型，后续继续使用呢？ 我们可以给结构类型声明取一个别名。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;timmy;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> david;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> jane;</span><br></pre></td></tr></table></figure><p>在第一次声明结构变量时，在 <code>struct</code> 与<code>&#123;</code>之间可以填写一个<strong>结构别名</strong>。</p><p>若以后再次需要使用这种结 构，仅需要使用 struct 加 别名 即可声明这种结构的变量。</p><p>事实上，我们可以将结构类型声明提取到最开头。让所有的结构变量均由别名来声明。相当于我们先造 了一个模板，然后，用这个模板生成各个变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> david;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> jane;</span><br></pre></td></tr></table></figure><blockquote><p>请注意，如果结构类型声明在一个函数中，那么别名只能在函数内部使用。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 别名person无法在func2中使用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> david;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 func1 声明了一个结构类型，它的别名为 person 。并且使用别名声明了一个结构变量 timmy 。</p><p>函数 func2 中，使用别名 person ，声明另一个结构变量，但是别名 person 无法在函数 func2 中使用， 因此将编译报错。</p><p>如果需要在多个函数中使用结构别名，那么可以把它放到函数外面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> david;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化结构"><a href="#初始化结构" class="headerlink" title="初始化结构"></a>初始化结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, timmy.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.weight);</span><br></pre></td></tr></table></figure><blockquote><p>结构的初始化列表的写法需要注意如下 4 点：</p></blockquote><ul><li>初始化列表由花括号包括。</li><li>花括号内为结构成员需要被初始化的值。</li><li>**初始化值按照结构成员声明时的顺序依次排列 **</li><li>每个初始化值之间由逗号分隔。</li></ul><p>对于第三点， person 结构成员声明的顺序依次为 name 、 gender 、 height 、 weight 。 对应的初始化列表中的初始化值顺序为”timmy”、 1、170.00、 60.00。 需要严格地对应顺序。</p><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> people[<span class="number">3</span>] = &#123;</span><br><span class="line">&#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;david&quot;</span>, <span class="number">1</span>, <span class="number">175.00</span>, <span class="number">65.00</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;jane&quot;</span>, <span class="number">2</span>, <span class="number">165.00</span>, <span class="number">55.00</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> per = people[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, per.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, per.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>, per.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, per.weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套结构"><a href="#嵌套结构" class="headerlink" title="嵌套结构"></a>嵌套结构</h3><blockquote><p>一个结构可以作为另一个结构的成员。</p></blockquote><p>例如，我们声明一个结构，用于存储通讯方式。通讯方式由电话号码，邮箱组成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">contact</span> &#123;</span><br><span class="line"><span class="type">char</span> phone[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> email[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>现在，我们需要记录每个人员的通讯方式。可以把这个结构作为人员结构的成员。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">contact</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;</span><br><span class="line"><span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>, &#123;<span class="string">&quot;130123456678&quot;</span>, <span class="string">&quot;timmy@xxx.com&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 . 加 字段名 可以访问到通讯方式结构。但是，你肯定还想访问其内部的成员，再次使 用 . 加 字段名 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">contact</span> &#123;</span><br><span class="line"><span class="type">char</span> phone[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> email[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">contact</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;</span><br><span class="line"><span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>, &#123;<span class="string">&quot;130123456678&quot;</span>, <span class="string">&quot;timmy@xxx.com&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, timmy.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, timmy.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>, timmy.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.weight);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.c.phone);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.c.email);</span><br></pre></td></tr></table></figure><h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> *pTimmy = &amp;timmy;</span><br></pre></td></tr></table></figure><blockquote><p>由于取地址 &amp; 与取值 * 它们具有可逆关系，我们可以把指针先转为结构再使用。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (*pTimmy).name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*pTimmy).gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, (*pTimmy).height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, (*pTimmy).weight);</span><br></pre></td></tr></table></figure><blockquote><p>由于成员运算符 . 的优先级高于取值 _ 。为了让取值 _ 先运算符，必须使用括号 *pTimmy 包括。</p><p>另外，C 语言中提供了更加方便的写法，成员间接运算符<code> -&gt;</code> 。</p></blockquote><p><code>(*pTimmy).name</code> 等价于<code> pTimmy-&gt;name</code> 。</p><h3 id="结构在函数中传递"><a href="#结构在函数中传递" class="headerlink" title="结构在函数中传递"></a>结构在函数中传递</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="keyword">struct</span> person per)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(per.name, <span class="string">&quot;david&quot;</span>);</span><br><span class="line">per.gender = <span class="number">1</span>;</span><br><span class="line">per.height = <span class="number">175.00</span>;</span><br><span class="line">per.weight = <span class="number">65.00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;;</span><br><span class="line"><span class="built_in">change</span>(timmy);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, timmy.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.weight);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>现在，我们将结构当作参数传入函数。在函数内部修改传入的参数。 很显然，由于实参 timmy 与实参 per 是相互独立的。修改函数 change 内的 per 无法改动实参 timmy 。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="keyword">struct</span> person *per)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(per-&gt;name, <span class="string">&quot;david&quot;</span>);</span><br><span class="line">per-&gt;gender = <span class="number">1</span>;</span><br><span class="line">per-&gt;height = <span class="number">175.00</span>;</span><br><span class="line">per-&gt;weight = <span class="number">65.00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;;</span><br><span class="line"><span class="built_in">change</span>(&amp;timmy);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, timmy.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.weight);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是，如果将 change 函数的参数改为指向结构的指针，情况就大不相同了。在函数 change 内部可以通 过指针，找到结构变量 timmy 。并且，对其进行修改</p></blockquote><blockquote><p>最后，将一个结构从函数返回也是可以的。从函数返回了 david 的数据，并且在将其赋值给了 timmy。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> <span class="built_in">change</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> per;</span><br><span class="line"><span class="built_in">strcpy</span>(per.name, <span class="string">&quot;david&quot;</span>);</span><br><span class="line">per.gender = <span class="number">1</span>;</span><br><span class="line">per.height = <span class="number">175.00</span>;</span><br><span class="line">per.weight = <span class="number">65.00</span>;</span><br><span class="line"><span class="keyword">return</span> per;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;;</span><br><span class="line">timmy = <span class="built_in">change</span>();</span><br></pre></td></tr></table></figure><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类中的变量和函数被统一称为类的成员变量。</p><p><code>private</code>后面的内容是私有成员变量，在类的外部不能访问；<code>public</code>后面的内容是公有成员变量，在类的外部可以访问。</p><p>类的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> age, height;</span><br><span class="line">        <span class="type">double</span> money;</span><br><span class="line">        string books[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;I&#x27;m &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">add_money</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            money += x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; person_a, person_b, persons[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person c;</span><br><span class="line"></span><br><span class="line">    c.name = <span class="string">&quot;yxc&quot;</span>;      <span class="comment">// 正确！访问公有变量</span></span><br><span class="line">    c.age = <span class="number">18</span>;          <span class="comment">// 错误！访问私有变量</span></span><br><span class="line">    c.<span class="built_in">set_age</span>(<span class="number">18</span>);       <span class="comment">// 正确！set_age()是共有成员变量</span></span><br><span class="line">    c.<span class="built_in">add_money</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    c.<span class="built_in">say</span>();</span><br><span class="line">    cout &lt;&lt; c.<span class="built_in">get_age</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成变量特殊方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">player</span> &#123;</span><br><span class="line"> <span class="type">int</span> x, y;</span><br><span class="line"> <span class="type">int</span> speed;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">     x += a * speed;</span><br><span class="line">     y += b * speed;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;c, player[<span class="number">1000</span>]; <span class="comment">//生成变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    player players[<span class="number">1000</span>]; <span class="comment">//生成变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类默认私有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class player &#123;</span><br><span class="line"> int x, y;</span><br><span class="line"> int speed;</span><br><span class="line"> void move(int a, int b)&#123;</span><br><span class="line">     x += a * speed;</span><br><span class="line">     y += b * speed;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>访问控制（private、public）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class player &#123;</span><br><span class="line">public:</span><br><span class="line"> int x, y;</span><br><span class="line"> int speed;</span><br><span class="line">private:</span><br><span class="line"> void move(int a, int b)&#123;</span><br><span class="line">     x += a * speed;</span><br><span class="line">     y += b * speed;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="C-类与结构体对比"><a href="#C-类与结构体对比" class="headerlink" title="C++类与结构体对比"></a>C++类与结构体对比</h1><p>区别：</p><blockquote><p>作用上：class 默认 private，struct 默认 public。<br>使用上：引入 struct 是为了让 C++向后兼容 C。</p></blockquote><p>推荐选用：</p><blockquote><p>若只包含一些变量结构或 POD(plain old data)时，选用 struct。例</p><p>如数学中的向量类。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec2</span>&#123;</span><br><span class="line"> <span class="type">float</span> x, y;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Vec2&amp; other)</span></span>&#123;</span><br><span class="line">     x += other.x;</span><br><span class="line">     y += other.y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>若要实现很多功能的类，则选用 class</p><p>若是只有数据,函数较少的,用 struct</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么数组的下标从0开始</title>
      <link href="/post/4d963d9c.html"/>
      <url>/post/4d963d9c.html</url>
      
        <content type="html"><![CDATA[<p>很多小伙伴初学编程的时候一定都被元素下标折磨过，<strong>为什么很多编程语言要把 0 作为第一个下标索引，而不是直观的 1 呢？</strong></p><p>这个问题 Dijkstra 已经解答过了，没错，就是你知道的 Dijkstra，Dijkstra 最短路径算法，荷兰语全名是 Edsger Wybe Dijkstra，于 1972 年获得了图灵奖，除了上面说的最短路径算法，还有众所周知的信号量和 PV 原语、银行家算法等也是这位巨佬提出的。</p><p>原文在这里：<a href="https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html">https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html</a></p><p>感兴趣的小伙伴可以去看下全文，下面我总结几段核心的观点：</p><p>首先来看个案例，如何用一个不等式（或者说表达式）来表示 <code>[2,3,4,5,6,7,8,9,10,11,12]</code> 这个连续的整数序列（一共 11 个数）？</p><p>假设 <code>i</code> 是一个整数，那么我们能够迅速的写出如下四个符合上述连续序列的不等式：</p><p>1）<code>2 &lt;= i &lt; 13</code></p><p>2）<code>1 &lt; i &lt;= 12</code></p><p>3）<code>2 &lt;= i &lt;= 12</code></p><p>4）<code>1 &lt; i &lt; 13</code></p><p>以上四个不等式均满足要求，那是否有理由选择其中的一种而不是另一种？</p><p>Dijkstra 说有的，选 1 和 2，因为这俩不等式有个很突出的有点，就是不等式边界的差（不等式右边 - 不等式左边）正好等于连续序列的长度</p><p>这里可以排除掉 3 和 4，那么 1 和 2 该如何选出最优的表示？</p><p>1 和 2 不等式的区别就在于：</p><ul><li>1 不等式左边（下界）等于序列中的最小值，不等式右边（上界）大于序列中的最大值</li><li>2 不等式左边（下界）小于序列中的最小值，不等式右边（上界）等于序列中的最大值</li></ul><p>对于第 2 个不等式来说，下界小于序列中的最小值，这会出现一个问题，比如我们的连续序列是 <code>[0,1,2,3,4]</code></p><p>那么按照第 2 个不等式的写法，不等式的左边就是 -1，-1 是非自然数，而我们需要表示的连续序列是自然数序列，所以第 2 个不等式很不优雅：我们需要用一个 非自然数 来作为 全是自然数的序列 的下界</p><p>因此，综上所述，不等式 1 是最优雅的选择。</p><p>那么，选出一个看着非常顺眼的不等式来表达长度为 N 的连续序列之后，下一个令人烦恼的问题是该为起始元素分配什么下标值？</p><p>遵循不等式 1 的规则：</p><ul><li>当从下标 1 开始时，下标范围 <code>1 ≤ i &lt; N+1</code></li><li>当从下标 0 开始时，下标范围 <code>0 ≤ i &lt; N</code></li></ul><p>哪个更优雅？</p><p>Dijkstra 是这样解释的：从下标 0 开始能够给出更好的不等式，因为元素的下标就等于序列中它前面的元素数（或者说 “偏移量”）。</p><p>问题解决！</p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/post/3c50d03d.html"/>
      <url>/post/3c50d03d.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Markdown-Typora-x2F-VSCode-超全教程"><a href="#Markdown-Typora-x2F-VSCode-超全教程" class="headerlink" title="[Markdown+Typora&#x2F;VSCode 超全教程]"></a>[Markdown+Typora&#x2F;VSCode 超全教程]</h1><p>Sakiyary 2022&#x2F;7&#x2F;16</p><h2 id="😂-简要介绍"><a href="#😂-简要介绍" class="headerlink" title="😂 简要介绍"></a>😂 简要介绍</h2><p><strong>Markdown</strong> 是一种轻量型标记语言, 是一种语法. 以 <code>.md</code> 结尾的文本文件就是 Markdown 文件. 相较于 <strong>Word</strong>, 它更加像是 <strong>HTML</strong> 语言或是 $\LaTeX$, 并不是最淳朴的那种”所见即所得”. 它处处透露着一种极简主义. 高效简洁清晰的同时, 又很简单. 看起来舒服, 语法简单, 尤其在处理纯文本上有很大的优势.</p><p>它相较于 <strong>Word</strong>, 兼容性非常高, 可以跨平台使用, 不用担心奇奇怪怪的版本兼容问题. 同时, 有许多网站都支持或正在使用 <strong>Markdown</strong> 语法. 如 <strong>Github</strong> (等一系列代码托管平台), StackOverflow(等答疑平台), 简书, 语雀 (等一系列笔记平台).</p><h2 id="📐-实际应用"><a href="#📐-实际应用" class="headerlink" title="📐 实际应用"></a>📐 实际应用</h2><p>所有要写文本的时候都可以用上 <strong>Markdown</strong>!</p><p>它可以让你不再纠结什么字体, 什么样式, 什么排版. 而且逻辑清晰, 层次分明.</p><p>像我大一的时候就用 Markdown 来写各种笔记, 演讲稿, 课程论文, 实验报告, 代码的 <code>README.md</code> … 包括本教程文档.</p><h2 id="🍴-工具"><a href="#🍴-工具" class="headerlink" title="🍴 工具"></a>🍴 工具</h2><p>Markdown 只是一种语法. 那么用来写 Markdown 的文本编辑器呢? 我推荐的是 <strong>Typora</strong> 或者 <strong>VS Code</strong></p><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p>Typora 应该是被广泛用于写 Markdown 的文本软件, 就和 Markdown 语法一样高效. 而且它还有很实用的扩展语法与自定义样式的功能. 其能将 <code>.md</code> 导出成多种文件, 如 <code>.pdf</code>, <code>.html</code>, <code>.docx</code> (没想到吧, 能导出到 Word)</p><p>但是现在 Typora 已经发布正式版并且变为收费软件. 中文官网在此 <a href="https://typoraio.cn/">Typora 官方中文站 </a>.</p><p>我当然是推荐大家都用正版啦. 不过价格是永久版￥ 89, 好在可以用在 3 台设备上. 如果和你的两位同学&#x2F;舍友均摊一下, 每人就只要￥ 30, 和一张游戏月卡差不多.</p><p>至于盗版以及破解方法<a href="https://www.only4.work/blog/?id=379">在此随便找一种改注册表时间方法的</a><del>不介绍(还挺多的其实)</del>.</p><p><del>还有一种免费白嫖的方法就是安装测试版&#x2F;Beta 版. 官网有历史版本的下载链接 <a href="https://typoraio.cn/windows/dev_release.html">Typora 历史版本下载页</a></del></p><p>白嫖 Beta 版已经寄了, 要么支持正版要么去学习一下破解方法吧 (还是忍不住啦, 看上面的链接 👆)</p><h3 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h3><p>这是微软家的开源文本编辑器, 理论上来说所有代码, 语言, 都可以用 VS Code 来写, 同样是非常的简洁好用. 在下载插件 <strong>Markdown All in One</strong> 后对 Markdown 的基础支持也是非常的好. 若在 VS Code 下载 Markdown 各种附加扩展, 就能获得比 Typora 更加丰富的扩展语法与操作.</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>大部分 IDE, 像 Jetbrain 的全家桶里应该每一款, 都支持 Markdown 语法, 在此不多赘述.</p><p>本文档主要使用 Typora 进行演示, 同时会介绍许多 Typora 所包含的扩展语法.</p><h2 id="🍭-基础教程"><a href="#🍭-基础教程" class="headerlink" title="🍭 基础教程"></a>🍭 基础教程</h2><p>当有多种标记方法时我会倾向其中一种.</p><p>标题有 <code>*</code> 表示该为扩展语法, 仅在 Typora 或 添加了扩展的 VS Code <strong>本地生效</strong>, 在大多数平台上<strong>并不认可</strong>.</p><h3 id="0-写-Markdown-的第零步"><a href="#0-写-Markdown-的第零步" class="headerlink" title="0. 写 Markdown 的第零步"></a>0. 写 Markdown 的第零步</h3><p>我们写文本的时候大多写的是中文, 可是输入法在输中文时使用的标点为全角标点, 如 <code>，。？！（）【】：；“”</code>. 这些标点是不被 Markdown 所认可的, 也是无法转义的.</p><p>我建议大家写 Markdown 的时候都用半角标点, 即英文标点, 如 <code>,.?!()[]:;&quot;&quot;</code>. 且每个半角标点在文本使用时加上后置空格, 符合英文标点的书写规范, 也更加美观.</p><p>以微软自带输入法举例, 在使用中文输入法时按下 <code>Ctrl</code> + <code>.(这是个句号)</code>, 切换标点的全角与半角. 这样即可中文输入+半角标点.</p><h3 id="1-标题-数个-“-”-空格-前置"><a href="#1-标题-数个-“-”-空格-前置" class="headerlink" title="1. 标题 [数个 “#” + 空格 前置]"></a>1. 标题 [数个 “#” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>标题会在目录与大纲分级显示, 可以跳转.</p><p>在 Typora 中建议开启 <code>严格模式</code>, 即不应为 <code>#标题</code>, 应为 <code># 标题</code>.</p><p>应该要手动补上空格, 使得 Markdown 语法在其他文本编辑器上兼容.</p><h3 id="2-强调-用-“-”-或-“-”-包围"><a href="#2-强调-用-“-”-或-“-”-包围" class="headerlink" title="2. 强调 [用 “**” 或 “__” 包围]"></a>2. 强调 [用 “**” 或 “__” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**欢迎报考南京大学!** (我喜欢用这种)</span><br><span class="line">__欢迎报考南京大学!__</span><br></pre></td></tr></table></figure><p>或者选中想要强调的文字按下 <code>Ctrl</code> + <code>B</code>.</p><p>E.G.</p><p><strong>欢迎报考南京大学!</strong></p><h3 id="3-斜体-用-“-”-或-“-”-包围"><a href="#3-斜体-用-“-”-或-“-”-包围" class="headerlink" title="3. 斜体 [用 “*” 或 “_” 包围]"></a>3. 斜体 [用 “*” 或 “_” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*欢迎大佬来浇浇我各种知识* (我喜欢用这种)</span><br><span class="line">_欢迎大佬来浇浇我各种知识_</span><br></pre></td></tr></table></figure><p>或者选中想要强调的文字按下 <code>Ctrl</code> + <code>I</code>.</p><p>E.G.</p><p><em>欢迎大佬来浇浇我各种知识</em></p><p>(P.S. <strong><em>斜体并强调</em></strong> [用 “***” 或 “___” 包围])</p><h3 id="4-删除线-用-“-”-包围"><a href="#4-删除线-用-“-”-包围" class="headerlink" title="4. 删除线 [用 “~~” 包围]"></a>4. 删除线 [用 “~~” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~我宣布个事儿, 我是Sabiyary!~~</span><br></pre></td></tr></table></figure><p>E.G.</p><p><del>我宣布个事儿, 我是 Sabiyary!</del></p><h3 id="5-高亮-用-“-x3D-x3D-”-包围"><a href="#5-高亮-用-“-x3D-x3D-”-包围" class="headerlink" title="5. *高亮 [用 “&#x3D;&#x3D;” 包围]"></a>5. *高亮 [用 “&#x3D;&#x3D;” 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==我喜欢黄色, 也喜欢绿色==</span><br></pre></td></tr></table></figure><p>E.G.</p><p>&#x3D;&#x3D;我喜欢黄色, 也喜欢绿色&#x3D;&#x3D;</p><h3 id="6-代码-用-“-96-”-包围"><a href="#6-代码-用-“-96-”-包围" class="headerlink" title="6. 代码 [用 “&#96;” 包围]"></a>6. 代码 [用 “&#96;” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`sudo rm -rf /*`</span><br></pre></td></tr></table></figure><p>E.G.</p><p><code>sudo rm -rf /*</code> (没事别乱敲这个! )</p><p><del>“请输入管理员密码: (闪烁的光标)”</del></p><h3 id="7-代码块-按三个-“-96-”-并敲回车"><a href="#7-代码块-按三个-“-96-”-并敲回车" class="headerlink" title="7. 代码块 [按三个 “&#96;” 并敲回车]"></a>7. 代码块 [按三个 “&#96;” 并敲回车]</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="comment">// 这里就可以开始输入你要的代码了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mian</span><span class="params">()</span> &#123;</span><br><span class="line">    print（“Hello, world!\n<span class="string">&quot;）;</span></span><br><span class="line"><span class="string">    retrun O;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">``` // (这三个&quot;</span>`<span class="string">&quot;文本编辑器会帮你自动补全 一般不用手动输)</span></span><br></pre></td></tr></table></figure><p>(我之前都是用这个来展示各种语法的, 应该不用举例了吧)</p><p>要想显示行数的话, 一般要在 Typora 的设置里勾上这个显示行数的选项.</p><p>代码块里可以选择语言, 其会根据语言来自动高亮各个语句. 在选择语言后, <code>```</code> 会变为 <code>````</code> + <code>对应语言</code>.</p><h3 id="8-引用-“-gt-”-空格-前置"><a href="#8-引用-“-gt-”-空格-前置" class="headerlink" title="8. 引用 [“&gt;” + 空格 前置]"></a>8. 引用 [“&gt;” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 24岁, 是学生.</span><br><span class="line">&gt; &gt; 学生特有的无处不在(恼)</span><br></pre></td></tr></table></figure><p>引用是可以嵌套的!</p><p>E.G.</p><blockquote><p>24 岁, 是学生.</p><blockquote><p>学生特有的无处不在(恼)</p></blockquote></blockquote><h3 id="9-无序列表-“-“-或-“-”-空格-前置"><a href="#9-无序列表-“-“-或-“-”-空格-前置" class="headerlink" title="9. 无序列表 [“-“ 或 “+” + 空格 前置]"></a>9. 无序列表 [“-“ 或 “+” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 一颗是枣树 (我喜欢用这种)</span><br><span class="line">+ 另一颗还是枣树</span><br><span class="line">* (其实这种也可以, 不过由于在 Typora 中很难单个输入, 故不常用)</span><br></pre></td></tr></table></figure><p>三种前置符都可以, 敲回车会自动补全, 可在 Typora 设置中调整补全的符号, 敲回车后按下 <code>Tab</code> 会缩进一级.</p><p>E.G.</p><ul><li>一颗是枣树</li><li>另一颗还是枣树</li></ul><h3 id="10-有序列表-数字-“-”-空格-前置"><a href="#10-有序列表-数字-“-”-空格-前置" class="headerlink" title="10. 有序列表 [数字 + “.” + 空格 前置]"></a>10. 有序列表 [数字 + “.” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我来这里就为了三件事:</span><br><span class="line">1. 公平</span><br><span class="line">2. 公平</span><br><span class="line">3. 还是tm的公平!</span><br></pre></td></tr></table></figure><p>敲回车会自动补全, 敲回车后按下 <code>Tab</code> 会缩进一级.</p><p>E.G.</p><p>我来这里就为了三件事:</p><ol><li><p>公平</p></li><li><p>公平</p></li><li><p>还是 tm 的公平!</p></li></ol><h3 id="11-上标-用-“-”-包围"><a href="#11-上标-用-“-”-包围" class="headerlink" title="11. *上标 [用 “^” 包围]"></a>11. *上标 [用 “^” 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中int的上限是 2^31^ - 1 = 2147483647</span><br></pre></td></tr></table></figure><p>E.G.</p><p>C 语言中 <code>int</code> 的上限是 2^31^ - 1 &#x3D; 2147483647</p><h3 id="12-下标-用-“-”-包围"><a href="#12-下标-用-“-”-包围" class="headerlink" title="12. *下标 [用 “~” 包围]"></a>12. *下标 [用 “~” 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H~2~O 是剧毒的!</span><br></pre></td></tr></table></figure><p>E.G.</p><p>H<del>2</del>O 是剧毒的!</p><h3 id="13-注释-“-”-后置"><a href="#13-注释-“-”-后置" class="headerlink" title="13. *注释 [“[^]” 后置]"></a>13. *注释 [“[^]” 后置]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励![^1]</span><br><span class="line"></span><br><span class="line">[^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.</span><br></pre></td></tr></table></figure><p>需要在文末写上注释对应的内容</p><p>E.G.</p><blockquote><p>今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励![^1]</p></blockquote><p>[^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.</p><h3 id="14-链接-常用-“-”-“-”-分别包围文本与链接"><a href="#14-链接-常用-“-”-“-”-分别包围文本与链接" class="headerlink" title="14. 链接 [常用 “[ ]” + “( )” 分别包围文本与链接]"></a>14. 链接 [常用 “[ ]” + “( )” 分别包围文本与链接]</h3><p><strong>(注意: 文内跳转为扩展用法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[来看看我贫瘠的仓库罢](https://github.com/Sakiyary)</span><br><span class="line">[基础教程: 12. 下标](#12. 下标 [用 &quot;~&quot; 包围])</span><br></pre></td></tr></table></figure><p>支持网页链接与文内跳转, 按住 <code>Ctrl</code> 并 <code>单击鼠标左键</code> 即可跳转.</p><p>E.G.</p><p><a href="https://github.com/Sakiyary">来看看我贫瘠的仓库罢</a></p><p>[基础教程: 12. 下标](#12. 下标 [用 “~” 包围])</p><h3 id="15-任务列表-“-”-空格-前置"><a href="#15-任务列表-“-”-空格-前置" class="headerlink" title="15. 任务列表 [“- [ ]” + 空格 前置]"></a>15. 任务列表 [“- [ ]” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TodoList:</span><br><span class="line">- [ ] 刷B站</span><br><span class="line">- [ ] 写代码</span><br><span class="line">- [x] 起床</span><br></pre></td></tr></table></figure><p>用 <code>x</code> 代替 <code>[ ]</code> 中的空格来勾选任务列表. 在 Typora 中可以直接用鼠标左键单击勾选框.</p><p>E.G. TodoList:</p><ul><li><input disabled="" type="checkbox"> 刷 B 站</li><li><input disabled="" type="checkbox"> 写代码</li><li><input checked="" disabled="" type="checkbox"> 起床</li></ul><h3 id="16-表格-用-“-”-绘制表格边框"><a href="#16-表格-用-“-”-绘制表格边框" class="headerlink" title="16. 表格 [用 “|” 绘制表格边框]"></a>16. 表格 [用 “|” 绘制表格边框]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 学号 | 姓名  | 年龄 |</span><br><span class="line">| :--- | :---: | ---: | (引号的位置代表着 左对齐, 居中, 右对齐)</span><br><span class="line">|114514|田所|24|</span><br><span class="line">|1919810|浩三|25|</span><br></pre></td></tr></table></figure><p>第一行为表头, 并由第二行分割线决定对齐方式与长度, 第三行及之后即表格数据</p><p>E.G.</p><table><thead><tr><th align="left">学号</th><th align="center">姓名</th><th align="right">年龄</th></tr></thead><tbody><tr><td align="left">114514</td><td align="center">田所</td><td align="right">24</td></tr><tr><td align="left">1919810</td><td align="center">浩三</td><td align="right">25</td></tr></tbody></table><h3 id="17-图片-直接拖进来或者复制粘贴"><a href="#17-图片-直接拖进来或者复制粘贴" class="headerlink" title="17. 图片 [直接拖进来或者复制粘贴]"></a>17. 图片 [直接拖进来或者复制粘贴]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片](图片的位置)</span><br></pre></td></tr></table></figure><p>我还是会选择拖进来或者复制粘贴啦~ 在 Typora 的设置里也可以改图片的储存方式.</p><h3 id="18-分割线-按三个-“-”-或-“-“-或-“-”-并敲回车"><a href="#18-分割线-按三个-“-”-或-“-“-或-“-”-并敲回车" class="headerlink" title="18. 分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]"></a>18. 分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">--- (我喜欢用这种)</span><br><span class="line">___</span><br><span class="line">// (其实按三个及以上都可以)</span><br></pre></td></tr></table></figure><p>由于 <code>*</code> 与 <code>_</code> 均会自动补全, 所以我觉得 <code>-</code> 最为方便.</p><p>E.G.</p><hr><hr><hr><h3 id="19-Emoji-表情-“-”-前置"><a href="#19-Emoji-表情-“-”-前置" class="headerlink" title="19. Emoji 表情 [“:” 前置]"></a>19. Emoji 表情 [“:” 前置]</h3><p><strong>(注意: 英文输入为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:sweat_smile:</span><br><span class="line">:drooling_face:</span><br><span class="line">:clown_face:</span><br><span class="line">// (敲回车或者鼠标点击, 后置的&quot;:&quot;一般不需要手动输)</span><br></pre></td></tr></table></figure><p>这个功能唯一的要求就是英语水平要高, 或者大概记得各个 Emoji 的英文名.</p><p>E.G.</p><p>:sweat_smile:<br>:drooling_face:<br>:clown_face:</p><p>对于其余普通的 Markdown 文本编辑器, 可以直接将 Emoji 表情复制进来, 这是直接<strong>硬编码</strong>的 (<del>刻进 DNA 里</del>)</p><p>E.G.</p><p>😅🤤🤡</p><p>用好这个功能可以让你的文本非常的可爱! <del>太抽象了</del></p><p>这里分享一个可以复制<a href="https://emojipedia.org/apple/">全 Emoji 的网站</a>, 非常好用! 我之前的 C 语言大作业也是从这里下载的资源!</p><h2 id="🔥-进阶教程"><a href="#🔥-进阶教程" class="headerlink" title="🔥 进阶教程"></a>🔥 进阶教程</h2><h3 id="1-目录-自动生成"><a href="#1-目录-自动生成" class="headerlink" title="1. 目录 [自动生成]"></a>1. 目录 [自动生成]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TOC] (此为 Typora 特有的, 如本文档开头)</span><br></pre></td></tr></table></figure><p>若使用 VS Code 搭配 Markdown All in One 扩展, 可在 VS Code 的<code>命令面板</code> (即 <a href="https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette">VS Code Command Palette</a>) 输入 <code>Create Table of Contents</code> 自动生成目录, 且可在扩展设置中细调目录参数.</p><h3 id="2-内联-HTML-代码-用-“-lt-gt-lt-x2F-gt-”-包围"><a href="#2-内联-HTML-代码-用-“-lt-gt-lt-x2F-gt-”-包围" class="headerlink" title="2. 内联 HTML 代码 [用 “&lt;&gt; &lt;&#x2F;&gt;” 包围]"></a>2. 内联 HTML 代码 [用 “&lt;&gt; &lt;&#x2F;&gt;” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align:center&quot;&gt;</span><br><span class="line">  &lt;font style=&quot;color:red&quot;&gt;我不会 HTML 呜呜呜... 浇浇我&lt;/font&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;center&gt;简单的文字居中也可以这样&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">&lt;u&gt;我差点忘了还有下划线这东西...&lt;/u&gt;</span><br></pre></td></tr></table></figure><p>只要你会写, 你完全可以把 Markdown 当作 <strong>HTML</strong> 来写.</p><p>同时, <code>.md</code> 文件可以直接导出成一个网页.</p><p>下划线可以选中想要下划的文字按下 <code>Ctrl</code> + <code>U</code>.</p><p>E.G.</p><div style="text-align:center">  <font style="color:red">我不会 HTML 呜呜呜... 浇浇我</font></div><center>简单的文字居中也可以这样</center><p><u>我差点忘了还有下划线这东西…</u></p><h3 id="3-内联-LaTeX-公式-用-“-”-包围"><a href="#3-内联-LaTeX-公式-用-“-”-包围" class="headerlink" title="3. 内联 $\LaTeX$ 公式 [用 “$” 包围]"></a>3. 内联 $\LaTeX$ 公式 [用 “$” 包围]</h3><p><strong>(注意: 部分编译器会不识别部分符号)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$\LaTeX$ 是最好用的论文排版语言! 不信你看!</span><br><span class="line"></span><br><span class="line">$a^n+b^n=c^n$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">%\usepackage&#123;unicode-math&#125;</span><br><span class="line">\displaystyle \ointctrclockwise\mathcal&#123;D&#125;[x(t)]</span><br><span class="line">\sqrt&#123;\frac&#123;\displaystyle3\uppi^2-\sum_&#123;q=0&#125;^&#123;\infty&#125;(z+\hat L)^&#123;q&#125;</span><br><span class="line">\exp(\symrm&#123;i&#125;q^2 \hbar x)&#125;&#123;\displaystyle (\symsfup&#123;Tr&#125;\symbfcal&#123;A&#125;)</span><br><span class="line">\left(\symbf\Lambda_&#123;j_1j_2&#125;^&#123;i_1i_2&#125;\Gamma_&#123;i_1i_2&#125;^&#123;j_1j_2&#125;</span><br><span class="line">\hookrightarrow\vec D\cdot \symbf P \right)&#125;&#125;</span><br><span class="line">=\underbrace&#123;\widetilde&#123;\left\langle \frac&#123;\notin \emptyset&#125;</span><br><span class="line">&#123;\varpi\alpha_&#123;k\uparrow&#125;&#125;\middle\vert</span><br><span class="line">\frac&#123;\partial_\mu T_&#123;\mu\nu&#125;&#125;&#123;2&#125;\right\rangle&#125;&#125;_&#123;\mathrm&#123;K&#125;_3</span><br><span class="line">\mathrm&#123;Fe&#125;(\mathrm&#123;CN&#125;)_6&#125; ,\forall z \in \mathbb&#123;R&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>用 <code>$</code> 包围为单条公式, 按下两个 <code>$</code> 并敲回车即生成公式块.</p><p>E.G.</p><p>$\LaTeX$ 是最好用的论文排版语言! 不信你看!</p><p>$a^n+b^n&#x3D;c^n$</p><p>$$<br>%\usepackage{unicode-math}<br>\displaystyle \ointctrclockwise\mathcal{D}[x(t)]<br>\sqrt{\frac{\displaystyle3\uppi^2-\sum_{q&#x3D;0}^{\infty}(z+\hat L)^{q}<br>\exp(\symrm{i}q^2 \hbar x)}{\displaystyle (\symsfup{Tr}\symbfcal{A})<br>\left(\symbf\Lambda_{j_1j_2}^{i_1i_2}\Gamma_{i_1i_2}^{j_1j_2}<br>\hookrightarrow\vec D\cdot \symbf P \right)}}<br>&#x3D;\underbrace{\widetilde{\left\langle \frac{\notin \emptyset}<br>{\varpi\alpha_{k\uparrow}}\middle\vert<br>\frac{\partial_\mu T_{\mu\nu}}{2}\right\rangle}}_{\mathrm{K}_3<br>\mathrm{Fe}(\mathrm{CN})_6} ,\forall z \in \mathbb{R}<br>$$</p><h3 id="4-网络图床"><a href="#4-网络图床" class="headerlink" title="4. *网络图床"></a>4. *网络图床</h3><p>(这是学长给我的网络图床教程, 我并未实践过…)</p><p>分享一个 Typora 搭配腾讯云 COS&#x2F;阿里云 OSS 图床的<a href="https://blog.csdn.net/guo_ridgepole/article/details/108257277">例子</a>. 新用户免费试用 6 个月, 另外还可选择七牛云或者路过图床.</p><h3 id="5-Typora-的常用快捷键"><a href="#5-Typora-的常用快捷键" class="headerlink" title="5. *Typora 的常用快捷键"></a>5. *Typora 的常用快捷键</h3><table><thead><tr><th align="center">按键</th><th align="center">效果</th><th align="center">按键</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center"><code>Ctrl</code> + <code>D</code></td><td align="center">选中当前词</td><td align="center"><code>Ctrl</code> + <code>L</code></td><td align="center">选中当前句&#x2F;行</td></tr><tr><td align="center"><code>Ctrl</code> + <code>E</code></td><td align="center">选中当前区块</td><td align="center"><code>Ctrl</code> + <code>F</code></td><td align="center">搜索当前选中</td></tr><tr><td align="center"><code>Ctrl</code> + <code>B</code></td><td align="center">加粗当前选中</td><td align="center"><code>Ctrl</code> + <code>H</code></td><td align="center">替换当前选中</td></tr><tr><td align="center"><code>Ctrl</code> + <code>I</code></td><td align="center">倾斜当前选中</td><td align="center"><code>Ctrl</code> + <code>U</code></td><td align="center">下划当前选中</td></tr><tr><td align="center"><code>Ctrl</code> + <code>K</code></td><td align="center">将当前选中生成链接</td><td align="center"><code>Ctrl</code> + <code>J</code></td><td align="center">滚动屏幕将选中滚至顶部</td></tr><tr><td align="center"><code>Ctrl</code> + <code>W</code></td><td align="center">关闭当前窗口</td><td align="center"><code>Ctrl</code> + <code>N</code></td><td align="center">打开新窗口</td></tr><tr><td align="center"><code>Ctrl</code> + <code>O</code></td><td align="center">打开文件</td><td align="center"><code>Ctrl</code> + <code>P</code></td><td align="center">搜索文件并打开</td></tr><tr><td align="center"><code>Ctrl</code> + <code>回车</code></td><td align="center">表格下方插入行</td><td align="center"><code>Ctrl</code> + <code>,</code></td><td align="center">打开偏好设置</td></tr><tr><td align="center"><code>Ctrl</code> + <code>.</code></td><td align="center">切换全角&#x2F;半角标点</td><td align="center"><code>Ctrl</code> + <code>/</code></td><td align="center">切换正常&#x2F;源代码视图</td></tr><tr><td align="center"><code>Ctrl</code> + <code>Shift</code> + <code>-</code></td><td align="center">缩小视图缩放</td><td align="center"><code>Ctrl</code> + <code>Shift</code> + <code>+</code></td><td align="center">放大视图缩放</td></tr></tbody></table><p>还有一些不常用的&#x2F;三键的快捷键不在此列出.</p><h3 id="6-Typora-的主题样式与检查元素"><a href="#6-Typora-的主题样式与检查元素" class="headerlink" title="6. *Typora 的主题样式与检查元素"></a>6. *Typora 的主题样式与检查元素</h3><p>Markdown 在编译后约等于 HTML. 而 Typora 的正常视图就是编译后的 Markdown, 故 Typora 的主题样式本质就是 CSS 文件.</p><p>可以下载各种好看的主题给 Typora 换上, 同时也可以自己调整对应的 CSS 文件, 或者自己手搓.</p><p>在 Typora 设置中开启 <code>调试模式</code> 后即可在正常视图右击打开 <code>检查元素</code>, 在其中就可以完全将 Markdown 文件当成 HTML 来编辑.</p><h2 id="💯-总结"><a href="#💯-总结" class="headerlink" title="💯 总结"></a>💯 总结</h2><p>至此, <strong>Markdown + Typora &#x2F; VSCode</strong> 的手册教程也告一段落.</p><p>不知你看完这么长的教程&#x2F;手册, 是否能体会到 Markdown 的精妙简洁之处呢?</p><p>其实 Markdown 只是标记语言的最开始, 我的感受是会了 Markdown 之后对于理解 HTML 也有帮助, 对于用 $\LaTeX$ 来写论文也有帮助. 标记语言正是为了摆脱 Word 那种虽然”所见即所得”, 但又过于花哨浮华, 很差的兼容性与闭源的编码的缺陷. 当你能掌握这样的”所写即所得”时, 你肯定会感受到用 Markdown 这类语言来处理文本的妙处!</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
