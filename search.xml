<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Markdown语法</title>
      <link href="/post/9e43dbe9.html"/>
      <url>/post/9e43dbe9.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Markdown-Typora-x2F-VSCode-超全教程"><a href="#Markdown-Typora-x2F-VSCode-超全教程" class="headerlink" title="[Markdown+Typora&#x2F;VSCode 超全教程]"></a>[Markdown+Typora&#x2F;VSCode 超全教程]</h1><p>Sakiyary 2022&#x2F;7&#x2F;16</p><h2 id="😂-简要介绍"><a href="#😂-简要介绍" class="headerlink" title="😂 简要介绍"></a>😂 简要介绍</h2><p><strong>Markdown</strong> 是一种轻量型标记语言, 是一种语法. 以 <code>.md</code> 结尾的文本文件就是 Markdown 文件. 相较于 <strong>Word</strong>, 它更加像是 <strong>HTML</strong> 语言或是 $\LaTeX$, 并不是最淳朴的那种”所见即所得”. 它处处透露着一种极简主义. 高效简洁清晰的同时, 又很简单. 看起来舒服, 语法简单, 尤其在处理纯文本上有很大的优势.</p><p>它相较于 <strong>Word</strong>, 兼容性非常高, 可以跨平台使用, 不用担心奇奇怪怪的版本兼容问题. 同时, 有许多网站都支持或正在使用 <strong>Markdown</strong> 语法. 如 <strong>Github</strong> (等一系列代码托管平台), StackOverflow(等答疑平台), 简书, 语雀 (等一系列笔记平台).</p><h2 id="📐-实际应用"><a href="#📐-实际应用" class="headerlink" title="📐 实际应用"></a>📐 实际应用</h2><p>所有要写文本的时候都可以用上 <strong>Markdown</strong>!</p><p>它可以让你不再纠结什么字体, 什么样式, 什么排版. 而且逻辑清晰, 层次分明.</p><p>像我大一的时候就用 Markdown 来写各种笔记, 演讲稿, 课程论文, 实验报告, 代码的 <code>README.md</code> … 包括本教程文档.</p><h2 id="🍴-工具"><a href="#🍴-工具" class="headerlink" title="🍴 工具"></a>🍴 工具</h2><p>Markdown 只是一种语法. 那么用来写 Markdown 的文本编辑器呢? 我推荐的是 <strong>Typora</strong> 或者 <strong>VS Code</strong></p><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><p>Typora 应该是被广泛用于写 Markdown 的文本软件, 就和 Markdown 语法一样高效. 而且它还有很实用的扩展语法与自定义样式的功能. 其能将 <code>.md</code> 导出成多种文件, 如 <code>.pdf</code>, <code>.html</code>, <code>.docx</code> (没想到吧, 能导出到 Word)</p><p>但是现在 Typora 已经发布正式版并且变为收费软件. 中文官网在此 <a href="https://typoraio.cn/">Typora 官方中文站 </a>.</p><p>我当然是推荐大家都用正版啦. 不过价格是永久版￥ 89, 好在可以用在 3 台设备上. 如果和你的两位同学&#x2F;舍友均摊一下, 每人就只要￥ 30, 和一张游戏月卡差不多.</p><p>至于盗版以及破解方法<a href="https://www.only4.work/blog/?id=379">在此随便找一种改注册表时间方法的</a><del>不介绍(还挺多的其实)</del>.</p><p><del>还有一种免费白嫖的方法就是安装测试版&#x2F;Beta 版. 官网有历史版本的下载链接 <a href="https://typoraio.cn/windows/dev_release.html">Typora 历史版本下载页</a></del></p><p>白嫖 Beta 版已经寄了, 要么支持正版要么去学习一下破解方法吧 (还是忍不住啦, 看上面的链接 👆)</p><h3 id="VS-Code"><a href="#VS-Code" class="headerlink" title="VS Code"></a>VS Code</h3><p>这是微软家的开源文本编辑器, 理论上来说所有代码, 语言, 都可以用 VS Code 来写, 同样是非常的简洁好用. 在下载插件 <strong>Markdown All in One</strong> 后对 Markdown 的基础支持也是非常的好. 若在 VS Code 下载 Markdown 各种附加扩展, 就能获得比 Typora 更加丰富的扩展语法与操作.</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>大部分 IDE, 像 Jetbrain 的全家桶里应该每一款, 都支持 Markdown 语法, 在此不多赘述.</p><p>本文档主要使用 Typora 进行演示, 同时会介绍许多 Typora 所包含的扩展语法.</p><h2 id="🍭-基础教程"><a href="#🍭-基础教程" class="headerlink" title="🍭 基础教程"></a>🍭 基础教程</h2><p>当有多种标记方法时我会倾向其中一种.</p><p>标题有 <code>*</code> 表示该为扩展语法, 仅在 Typora 或 添加了扩展的 VS Code <strong>本地生效</strong>, 在大多数平台上<strong>并不认可</strong>.</p><h3 id="0-写-Markdown-的第零步"><a href="#0-写-Markdown-的第零步" class="headerlink" title="0. 写 Markdown 的第零步"></a>0. 写 Markdown 的第零步</h3><p>我们写文本的时候大多写的是中文, 可是输入法在输中文时使用的标点为全角标点, 如 <code>，。？！（）【】：；“”</code>. 这些标点是不被 Markdown 所认可的, 也是无法转义的.</p><p>我建议大家写 Markdown 的时候都用半角标点, 即英文标点, 如 <code>,.?!()[]:;&quot;&quot;</code>. 且每个半角标点在文本使用时加上后置空格, 符合英文标点的书写规范, 也更加美观.</p><p>以微软自带输入法举例, 在使用中文输入法时按下 <code>Ctrl</code> + <code>.(这是个句号)</code>, 切换标点的全角与半角. 这样即可中文输入+半角标点.</p><h3 id="1-标题-数个-“-”-空格-前置"><a href="#1-标题-数个-“-”-空格-前置" class="headerlink" title="1. 标题 [数个 “#” + 空格 前置]"></a>1. 标题 [数个 “#” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>标题会在目录与大纲分级显示, 可以跳转.</p><p>在 Typora 中建议开启 <code>严格模式</code>, 即不应为 <code>#标题</code>, 应为 <code># 标题</code>.</p><p>应该要手动补上空格, 使得 Markdown 语法在其他文本编辑器上兼容.</p><h3 id="2-强调-用-“-”-或-“-”-包围"><a href="#2-强调-用-“-”-或-“-”-包围" class="headerlink" title="2. 强调 [用 “**” 或 “__” 包围]"></a>2. 强调 [用 “**” 或 “__” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**欢迎报考南京大学!** (我喜欢用这种)</span><br><span class="line">__欢迎报考南京大学!__</span><br></pre></td></tr></table></figure><p>或者选中想要强调的文字按下 <code>Ctrl</code> + <code>B</code>.</p><p>E.G.</p><p><strong>欢迎报考南京大学!</strong></p><h3 id="3-斜体-用-“-”-或-“-”-包围"><a href="#3-斜体-用-“-”-或-“-”-包围" class="headerlink" title="3. 斜体 [用 “*” 或 “_” 包围]"></a>3. 斜体 [用 “*” 或 “_” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*欢迎大佬来浇浇我各种知识* (我喜欢用这种)</span><br><span class="line">_欢迎大佬来浇浇我各种知识_</span><br></pre></td></tr></table></figure><p>或者选中想要强调的文字按下 <code>Ctrl</code> + <code>I</code>.</p><p>E.G.</p><p><em>欢迎大佬来浇浇我各种知识</em></p><p>(P.S. <strong><em>斜体并强调</em></strong> [用 “***” 或 “___” 包围])</p><h3 id="4-删除线-用-“-”-包围"><a href="#4-删除线-用-“-”-包围" class="headerlink" title="4. 删除线 [用 “~~” 包围]"></a>4. 删除线 [用 “~~” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~我宣布个事儿, 我是Sabiyary!~~</span><br></pre></td></tr></table></figure><p>E.G.</p><p><del>我宣布个事儿, 我是 Sabiyary!</del></p><h3 id="5-高亮-用-“-x3D-x3D-”-包围"><a href="#5-高亮-用-“-x3D-x3D-”-包围" class="headerlink" title="5. *高亮 [用 “&#x3D;&#x3D;” 包围]"></a>5. *高亮 [用 “&#x3D;&#x3D;” 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">==我喜欢黄色, 也喜欢绿色==</span><br></pre></td></tr></table></figure><p>E.G.</p><p>&#x3D;&#x3D;我喜欢黄色, 也喜欢绿色&#x3D;&#x3D;</p><h3 id="6-代码-用-“-96-”-包围"><a href="#6-代码-用-“-96-”-包围" class="headerlink" title="6. 代码 [用 “&#96;” 包围]"></a>6. 代码 [用 “&#96;” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`sudo rm -rf /*`</span><br></pre></td></tr></table></figure><p>E.G.</p><p><code>sudo rm -rf /*</code> (没事别乱敲这个! )</p><p><del>“请输入管理员密码: (闪烁的光标)”</del></p><h3 id="7-代码块-按三个-“-96-”-并敲回车"><a href="#7-代码块-按三个-“-96-”-并敲回车" class="headerlink" title="7. 代码块 [按三个 “&#96;” 并敲回车]"></a>7. 代码块 [按三个 “&#96;” 并敲回车]</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="comment">// 这里就可以开始输入你要的代码了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mian</span><span class="params">()</span> &#123;</span><br><span class="line">    print（“Hello, world!\n<span class="string">&quot;）;</span></span><br><span class="line"><span class="string">    retrun O;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">``` // (这三个&quot;</span>`<span class="string">&quot;文本编辑器会帮你自动补全 一般不用手动输)</span></span><br></pre></td></tr></table></figure><p>(我之前都是用这个来展示各种语法的, 应该不用举例了吧)</p><p>要想显示行数的话, 一般要在 Typora 的设置里勾上这个显示行数的选项.</p><p>代码块里可以选择语言, 其会根据语言来自动高亮各个语句. 在选择语言后, <code>```</code> 会变为 <code>````</code> + <code>对应语言</code>.</p><h3 id="8-引用-“-gt-”-空格-前置"><a href="#8-引用-“-gt-”-空格-前置" class="headerlink" title="8. 引用 [“&gt;” + 空格 前置]"></a>8. 引用 [“&gt;” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 24岁, 是学生.</span><br><span class="line">&gt; &gt; 学生特有的无处不在(恼)</span><br></pre></td></tr></table></figure><p>引用是可以嵌套的!</p><p>E.G.</p><blockquote><p>24 岁, 是学生.</p><blockquote><p>学生特有的无处不在(恼)</p></blockquote></blockquote><h3 id="9-无序列表-“-“-或-“-”-空格-前置"><a href="#9-无序列表-“-“-或-“-”-空格-前置" class="headerlink" title="9. 无序列表 [“-“ 或 “+” + 空格 前置]"></a>9. 无序列表 [“-“ 或 “+” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 一颗是枣树 (我喜欢用这种)</span><br><span class="line">+ 另一颗还是枣树</span><br><span class="line">* (其实这种也可以, 不过由于在 Typora 中很难单个输入, 故不常用)</span><br></pre></td></tr></table></figure><p>三种前置符都可以, 敲回车会自动补全, 可在 Typora 设置中调整补全的符号, 敲回车后按下 <code>Tab</code> 会缩进一级.</p><p>E.G.</p><ul><li>一颗是枣树</li><li>另一颗还是枣树</li></ul><h3 id="10-有序列表-数字-“-”-空格-前置"><a href="#10-有序列表-数字-“-”-空格-前置" class="headerlink" title="10. 有序列表 [数字 + “.” + 空格 前置]"></a>10. 有序列表 [数字 + “.” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我来这里就为了三件事:</span><br><span class="line">1. 公平</span><br><span class="line">2. 公平</span><br><span class="line">3. 还是tm的公平!</span><br></pre></td></tr></table></figure><p>敲回车会自动补全, 敲回车后按下 <code>Tab</code> 会缩进一级.</p><p>E.G.</p><p>我来这里就为了三件事:</p><ol><li><p>公平</p></li><li><p>公平</p></li><li><p>还是 tm 的公平!</p></li></ol><h3 id="11-上标-用-“-”-包围"><a href="#11-上标-用-“-”-包围" class="headerlink" title="11. *上标 [用 “^” 包围]"></a>11. *上标 [用 “^” 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C语言中int的上限是 2^31^ - 1 = 2147483647</span><br></pre></td></tr></table></figure><p>E.G.</p><p>C 语言中 <code>int</code> 的上限是 2^31^ - 1 &#x3D; 2147483647</p><h3 id="12-下标-用-“-”-包围"><a href="#12-下标-用-“-”-包围" class="headerlink" title="12. *下标 [用 “~” 包围]"></a>12. *下标 [用 “~” 包围]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H~2~O 是剧毒的!</span><br></pre></td></tr></table></figure><p>E.G.</p><p>H<del>2</del>O 是剧毒的!</p><h3 id="13-注释-“-”-后置"><a href="#13-注释-“-”-后置" class="headerlink" title="13. *注释 [“[^]” 后置]"></a>13. *注释 [“[^]” 后置]</h3><p><strong>(注意: 此为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励![^1]</span><br><span class="line"></span><br><span class="line">[^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.</span><br></pre></td></tr></table></figure><p>需要在文末写上注释对应的内容</p><p>E.G.</p><blockquote><p>今日我们相聚于此, 是为了学习 Markdown 的使用, 它的教程对于全体「观众」而言, 值得足足两个硬币的支持鼓励![^1]</p></blockquote><p>[^1]: 沃兹·基·硕德 改编自「公鸡」普契涅拉.</p><h3 id="14-链接-常用-“-”-“-”-分别包围文本与链接"><a href="#14-链接-常用-“-”-“-”-分别包围文本与链接" class="headerlink" title="14. 链接 [常用 “[ ]” + “( )” 分别包围文本与链接]"></a>14. 链接 [常用 “[ ]” + “( )” 分别包围文本与链接]</h3><p><strong>(注意: 文内跳转为扩展用法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[来看看我贫瘠的仓库罢](https://github.com/Sakiyary)</span><br><span class="line">[基础教程: 12. 下标](#12. 下标 [用 &quot;~&quot; 包围])</span><br></pre></td></tr></table></figure><p>支持网页链接与文内跳转, 按住 <code>Ctrl</code> 并 <code>单击鼠标左键</code> 即可跳转.</p><p>E.G.</p><p><a href="https://github.com/Sakiyary">来看看我贫瘠的仓库罢</a></p><p>[基础教程: 12. 下标](#12. 下标 [用 “~” 包围])</p><h3 id="15-任务列表-“-”-空格-前置"><a href="#15-任务列表-“-”-空格-前置" class="headerlink" title="15. 任务列表 [“- [ ]” + 空格 前置]"></a>15. 任务列表 [“- [ ]” + 空格 前置]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TodoList:</span><br><span class="line">- [ ] 刷B站</span><br><span class="line">- [ ] 写代码</span><br><span class="line">- [x] 起床</span><br></pre></td></tr></table></figure><p>用 <code>x</code> 代替 <code>[ ]</code> 中的空格来勾选任务列表. 在 Typora 中可以直接用鼠标左键单击勾选框.</p><p>E.G. TodoList:</p><ul><li><input disabled="" type="checkbox"> 刷 B 站</li><li><input disabled="" type="checkbox"> 写代码</li><li><input checked="" disabled="" type="checkbox"> 起床</li></ul><h3 id="16-表格-用-“-”-绘制表格边框"><a href="#16-表格-用-“-”-绘制表格边框" class="headerlink" title="16. 表格 [用 “|” 绘制表格边框]"></a>16. 表格 [用 “|” 绘制表格边框]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 学号 | 姓名  | 年龄 |</span><br><span class="line">| :--- | :---: | ---: | (引号的位置代表着 左对齐, 居中, 右对齐)</span><br><span class="line">|114514|田所|24|</span><br><span class="line">|1919810|浩三|25|</span><br></pre></td></tr></table></figure><p>第一行为表头, 并由第二行分割线决定对齐方式与长度, 第三行及之后即表格数据</p><p>E.G.</p><table><thead><tr><th align="left">学号</th><th align="center">姓名</th><th align="right">年龄</th></tr></thead><tbody><tr><td align="left">114514</td><td align="center">田所</td><td align="right">24</td></tr><tr><td align="left">1919810</td><td align="center">浩三</td><td align="right">25</td></tr></tbody></table><h3 id="17-图片-直接拖进来或者复制粘贴"><a href="#17-图片-直接拖进来或者复制粘贴" class="headerlink" title="17. 图片 [直接拖进来或者复制粘贴]"></a>17. 图片 [直接拖进来或者复制粘贴]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![图片](图片的位置)</span><br></pre></td></tr></table></figure><p>我还是会选择拖进来或者复制粘贴啦~ 在 Typora 的设置里也可以改图片的储存方式.</p><h3 id="18-分割线-按三个-“-”-或-“-“-或-“-”-并敲回车"><a href="#18-分割线-按三个-“-”-或-“-“-或-“-”-并敲回车" class="headerlink" title="18. 分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]"></a>18. 分割线 [按三个 “*” 或 “-“ 或 “_” 并敲回车]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">--- (我喜欢用这种)</span><br><span class="line">___</span><br><span class="line">// (其实按三个及以上都可以)</span><br></pre></td></tr></table></figure><p>由于 <code>*</code> 与 <code>_</code> 均会自动补全, 所以我觉得 <code>-</code> 最为方便.</p><p>E.G.</p><hr><hr><hr><h3 id="19-Emoji-表情-“-”-前置"><a href="#19-Emoji-表情-“-”-前置" class="headerlink" title="19. Emoji 表情 [“:” 前置]"></a>19. Emoji 表情 [“:” 前置]</h3><p><strong>(注意: 英文输入为扩展语法)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:sweat_smile:</span><br><span class="line">:drooling_face:</span><br><span class="line">:clown_face:</span><br><span class="line">// (敲回车或者鼠标点击, 后置的&quot;:&quot;一般不需要手动输)</span><br></pre></td></tr></table></figure><p>这个功能唯一的要求就是英语水平要高, 或者大概记得各个 Emoji 的英文名.</p><p>E.G.</p><p>:sweat_smile:<br>:drooling_face:<br>:clown_face:</p><p>对于其余普通的 Markdown 文本编辑器, 可以直接将 Emoji 表情复制进来, 这是直接<strong>硬编码</strong>的 (<del>刻进 DNA 里</del>)</p><p>E.G.</p><p>😅🤤🤡</p><p>用好这个功能可以让你的文本非常的可爱! <del>太抽象了</del></p><p>这里分享一个可以复制<a href="https://emojipedia.org/apple/">全 Emoji 的网站</a>, 非常好用! 我之前的 C 语言大作业也是从这里下载的资源!</p><h2 id="🔥-进阶教程"><a href="#🔥-进阶教程" class="headerlink" title="🔥 进阶教程"></a>🔥 进阶教程</h2><h3 id="1-目录-自动生成"><a href="#1-目录-自动生成" class="headerlink" title="1. 目录 [自动生成]"></a>1. 目录 [自动生成]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TOC] (此为 Typora 特有的, 如本文档开头)</span><br></pre></td></tr></table></figure><p>若使用 VS Code 搭配 Markdown All in One 扩展, 可在 VS Code 的<code>命令面板</code> (即 <a href="https://code.visualstudio.com/docs/getstarted/userinterface#_command-palette">VS Code Command Palette</a>) 输入 <code>Create Table of Contents</code> 自动生成目录, 且可在扩展设置中细调目录参数.</p><h3 id="2-内联-HTML-代码-用-“-lt-gt-lt-x2F-gt-”-包围"><a href="#2-内联-HTML-代码-用-“-lt-gt-lt-x2F-gt-”-包围" class="headerlink" title="2. 内联 HTML 代码 [用 “&lt;&gt; &lt;&#x2F;&gt;” 包围]"></a>2. 内联 HTML 代码 [用 “&lt;&gt; &lt;&#x2F;&gt;” 包围]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;text-align:center&quot;&gt;</span><br><span class="line">  &lt;font style=&quot;color:red&quot;&gt;我不会 HTML 呜呜呜... 浇浇我&lt;/font&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;center&gt;简单的文字居中也可以这样&lt;/center&gt;</span><br><span class="line"></span><br><span class="line">&lt;u&gt;我差点忘了还有下划线这东西...&lt;/u&gt;</span><br></pre></td></tr></table></figure><p>只要你会写, 你完全可以把 Markdown 当作 <strong>HTML</strong> 来写.</p><p>同时, <code>.md</code> 文件可以直接导出成一个网页.</p><p>下划线可以选中想要下划的文字按下 <code>Ctrl</code> + <code>U</code>.</p><p>E.G.</p><div style="text-align:center">  <font style="color:red">我不会 HTML 呜呜呜... 浇浇我</font></div><center>简单的文字居中也可以这样</center><p><u>我差点忘了还有下划线这东西…</u></p><h3 id="3-内联-LaTeX-公式-用-“-”-包围"><a href="#3-内联-LaTeX-公式-用-“-”-包围" class="headerlink" title="3. 内联 $\LaTeX$ 公式 [用 “$” 包围]"></a>3. 内联 $\LaTeX$ 公式 [用 “$” 包围]</h3><p><strong>(注意: 部分编译器会不识别部分符号)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$\LaTeX$ 是最好用的论文排版语言! 不信你看!</span><br><span class="line"></span><br><span class="line">$a^n+b^n=c^n$</span><br><span class="line"></span><br><span class="line">$$</span><br><span class="line">%\usepackage&#123;unicode-math&#125;</span><br><span class="line">\displaystyle \ointctrclockwise\mathcal&#123;D&#125;[x(t)]</span><br><span class="line">\sqrt&#123;\frac&#123;\displaystyle3\uppi^2-\sum_&#123;q=0&#125;^&#123;\infty&#125;(z+\hat L)^&#123;q&#125;</span><br><span class="line">\exp(\symrm&#123;i&#125;q^2 \hbar x)&#125;&#123;\displaystyle (\symsfup&#123;Tr&#125;\symbfcal&#123;A&#125;)</span><br><span class="line">\left(\symbf\Lambda_&#123;j_1j_2&#125;^&#123;i_1i_2&#125;\Gamma_&#123;i_1i_2&#125;^&#123;j_1j_2&#125;</span><br><span class="line">\hookrightarrow\vec D\cdot \symbf P \right)&#125;&#125;</span><br><span class="line">=\underbrace&#123;\widetilde&#123;\left\langle \frac&#123;\notin \emptyset&#125;</span><br><span class="line">&#123;\varpi\alpha_&#123;k\uparrow&#125;&#125;\middle\vert</span><br><span class="line">\frac&#123;\partial_\mu T_&#123;\mu\nu&#125;&#125;&#123;2&#125;\right\rangle&#125;&#125;_&#123;\mathrm&#123;K&#125;_3</span><br><span class="line">\mathrm&#123;Fe&#125;(\mathrm&#123;CN&#125;)_6&#125; ,\forall z \in \mathbb&#123;R&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>用 <code>$</code> 包围为单条公式, 按下两个 <code>$</code> 并敲回车即生成公式块.</p><p>E.G.</p><p>$\LaTeX$ 是最好用的论文排版语言! 不信你看!</p><p>$a^n+b^n&#x3D;c^n$</p><p>$$<br>%\usepackage{unicode-math}<br>\displaystyle \ointctrclockwise\mathcal{D}[x(t)]<br>\sqrt{\frac{\displaystyle3\uppi^2-\sum_{q&#x3D;0}^{\infty}(z+\hat L)^{q}<br>\exp(\symrm{i}q^2 \hbar x)}{\displaystyle (\symsfup{Tr}\symbfcal{A})<br>\left(\symbf\Lambda_{j_1j_2}^{i_1i_2}\Gamma_{i_1i_2}^{j_1j_2}<br>\hookrightarrow\vec D\cdot \symbf P \right)}}<br>&#x3D;\underbrace{\widetilde{\left\langle \frac{\notin \emptyset}<br>{\varpi\alpha_{k\uparrow}}\middle\vert<br>\frac{\partial_\mu T_{\mu\nu}}{2}\right\rangle}}_{\mathrm{K}_3<br>\mathrm{Fe}(\mathrm{CN})_6} ,\forall z \in \mathbb{R}<br>$$</p><h3 id="4-网络图床"><a href="#4-网络图床" class="headerlink" title="4. *网络图床"></a>4. *网络图床</h3><p>(这是学长给我的网络图床教程, 我并未实践过…)</p><p>分享一个 Typora 搭配腾讯云 COS&#x2F;阿里云 OSS 图床的<a href="https://blog.csdn.net/guo_ridgepole/article/details/108257277">例子</a>. 新用户免费试用 6 个月, 另外还可选择七牛云或者路过图床.</p><h3 id="5-Typora-的常用快捷键"><a href="#5-Typora-的常用快捷键" class="headerlink" title="5. *Typora 的常用快捷键"></a>5. *Typora 的常用快捷键</h3><table><thead><tr><th align="center">按键</th><th align="center">效果</th><th align="center">按键</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center"><code>Ctrl</code> + <code>D</code></td><td align="center">选中当前词</td><td align="center"><code>Ctrl</code> + <code>L</code></td><td align="center">选中当前句&#x2F;行</td></tr><tr><td align="center"><code>Ctrl</code> + <code>E</code></td><td align="center">选中当前区块</td><td align="center"><code>Ctrl</code> + <code>F</code></td><td align="center">搜索当前选中</td></tr><tr><td align="center"><code>Ctrl</code> + <code>B</code></td><td align="center">加粗当前选中</td><td align="center"><code>Ctrl</code> + <code>H</code></td><td align="center">替换当前选中</td></tr><tr><td align="center"><code>Ctrl</code> + <code>I</code></td><td align="center">倾斜当前选中</td><td align="center"><code>Ctrl</code> + <code>U</code></td><td align="center">下划当前选中</td></tr><tr><td align="center"><code>Ctrl</code> + <code>K</code></td><td align="center">将当前选中生成链接</td><td align="center"><code>Ctrl</code> + <code>J</code></td><td align="center">滚动屏幕将选中滚至顶部</td></tr><tr><td align="center"><code>Ctrl</code> + <code>W</code></td><td align="center">关闭当前窗口</td><td align="center"><code>Ctrl</code> + <code>N</code></td><td align="center">打开新窗口</td></tr><tr><td align="center"><code>Ctrl</code> + <code>O</code></td><td align="center">打开文件</td><td align="center"><code>Ctrl</code> + <code>P</code></td><td align="center">搜索文件并打开</td></tr><tr><td align="center"><code>Ctrl</code> + <code>回车</code></td><td align="center">表格下方插入行</td><td align="center"><code>Ctrl</code> + <code>,</code></td><td align="center">打开偏好设置</td></tr><tr><td align="center"><code>Ctrl</code> + <code>.</code></td><td align="center">切换全角&#x2F;半角标点</td><td align="center"><code>Ctrl</code> + <code>/</code></td><td align="center">切换正常&#x2F;源代码视图</td></tr><tr><td align="center"><code>Ctrl</code> + <code>Shift</code> + <code>-</code></td><td align="center">缩小视图缩放</td><td align="center"><code>Ctrl</code> + <code>Shift</code> + <code>+</code></td><td align="center">放大视图缩放</td></tr></tbody></table><p>还有一些不常用的&#x2F;三键的快捷键不在此列出.</p><h3 id="6-Typora-的主题样式与检查元素"><a href="#6-Typora-的主题样式与检查元素" class="headerlink" title="6. *Typora 的主题样式与检查元素"></a>6. *Typora 的主题样式与检查元素</h3><p>Markdown 在编译后约等于 HTML. 而 Typora 的正常视图就是编译后的 Markdown, 故 Typora 的主题样式本质就是 CSS 文件.</p><p>可以下载各种好看的主题给 Typora 换上, 同时也可以自己调整对应的 CSS 文件, 或者自己手搓.</p><p>在 Typora 设置中开启 <code>调试模式</code> 后即可在正常视图右击打开 <code>检查元素</code>, 在其中就可以完全将 Markdown 文件当成 HTML 来编辑.</p><h2 id="💯-总结"><a href="#💯-总结" class="headerlink" title="💯 总结"></a>💯 总结</h2><p>至此, <strong>Markdown + Typora &#x2F; VSCode</strong> 的手册教程也告一段落.</p><p>不知你看完这么长的教程&#x2F;手册, 是否能体会到 Markdown 的精妙简洁之处呢?</p><p>其实 Markdown 只是标记语言的最开始, 我的感受是会了 Markdown 之后对于理解 HTML 也有帮助, 对于用 $\LaTeX$ 来写论文也有帮助. 标记语言正是为了摆脱 Word 那种虽然”所见即所得”, 但又过于花哨浮华, 很差的兼容性与闭源的编码的缺陷. 当你能掌握这样的”所写即所得”时, 你肯定会感受到用 Markdown 这类语言来处理文本的妙处!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/post/5751eea2.html"/>
      <url>/post/5751eea2.html</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><strong>问题1</strong>：c++头文件为什么没有.h？</p><p>​在c语言中头文件使用扩展名.h,将其作为一种通过名称标识文件类型的简单方式。但是c++得用法改变了，c++头文件没有扩展名。但是有些c语言的头文件被转换为c++的头文件，这些文件被重新命名，丢掉了扩展名.h(使之成为c++风格头文件)，并在文件名称前面加上前缀c(表明来自c语言)。例如c++版本的math.h为cmath.</p><p>​由于C使用不同的扩展名来表示不同文件类型，因此用一些特殊的扩展名(如hpp或hxx)表示c++的头文件也是可以的，ANSI&#x2F;IOS标准委员会也认为是可以的，但是关键问题是用哪个比较好，最后一致同意不适用任何扩展名。</p><table><thead><tr><th>头文件类型</th><th>约定</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>c++旧式风格</td><td>以.h结尾</td><td>iostream.h</td><td>c++程序可用</td></tr><tr><td>c旧式风格</td><td>以.h结尾</td><td>math.h</td><td>c&#x2F;c++程序可用</td></tr><tr><td>c++新式风格</td><td>无扩展名</td><td>iostream</td><td>c++程序可用，使用namespace std</td></tr><tr><td>转换后的c</td><td>加上前缀c,无扩展名</td><td>cmath</td><td>c++程序可用，可使用非c特性，如namespace std</td></tr></tbody></table><p><strong>问题2</strong>：using namespace std 是什么?</p><p>​namespace是指标识符的各种可见范围。命名空间用关键字namespace 来定义。命名空间是C++的一种机制，用来把单个标识符下的大量有逻辑联系的程序实体组合到一起。此标识符作为此组群的名字。</p><p><strong>问题3</strong>：cout 、endl 是什么？</p><p>​cout是c++中的标准输出流，endl是输出换行并刷新缓冲区。</p><h1 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h1><blockquote><p>封装</p></blockquote><ul><li><p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p></li><li><p>类将成员变量和成员函数封装在类的内部，根据需要设置访问权限，通过成员函数管理内部状态。</p></li></ul><blockquote><p>继承</p></blockquote><ul><li><p>继承所表达的是类之间相关的关系，这种关系使得对象可以继承另外一类对象的特征和能力。</p></li><li><p>继承的作用：避免公用代码的重复开发，减少代码和数据冗余。</p></li></ul><blockquote><p>多态</p></blockquote><ul><li>多态性可以简单地概括为“一个接口，多种方法”，字面意思为多种形态。程序在运行时才决定调用的函数，它是面向对象编程领域的核心概念。</li></ul><h1 id="C-对C的扩展"><a href="#C-对C的扩展" class="headerlink" title="C++对C的扩展"></a>C++对C的扩展</h1><h3 id="作用域运算符"><a href="#作用域运算符" class="headerlink" title="::作用域运算符"></a>::作用域运算符</h3><blockquote><p>通常情况下，如果有两个同名变量，一个是全局变量，</p><p>另一个是局部变量，那么局部变量在其作用域内具有较高的优先权，</p><p>它将屏蔽全局变量。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//1. 局部变量和全局变量同名</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//打印局部变量a</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="comment">//打印全局变量a</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量a:&quot;</span> &lt;&lt; ::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>作用域运算符可以用来解决局部变量与全局变量的重名问题，</p></blockquote><p>即在局部变量的作用域内，可用::对被屏蔽的同名的全局变量进行访问。</p><h3 id="C-命名空间-namespace"><a href="#C-命名空间-namespace" class="headerlink" title="C++命名空间(namespace)"></a>C++命名空间(namespace)</h3><blockquote><p>命名空间的用途:解决名称冲突</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;B::a : &quot;</span> &lt;&lt; B::a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间可以嵌套</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::a : &quot;</span> &lt;&lt; A::a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;A::B::a : &quot;</span> &lt;&lt; A::B::a &lt;&lt; endl;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间下可以存储 变量, 函数,结构体,类…..</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_A = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125; </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数的声明和实现可分离</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> MySpace&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> param)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MySpace::func2</span><span class="params">(<span class="type">int</span> param)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MySpace::func2 : &quot;</span> &lt;&lt; param &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间必须声明在全局作用域下</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//namespace B  //不能定义在局部中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间是开放的,可以随时向空间中添加新成员</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> B&#123;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间可以是匿名的,只能在本文件内访问</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;    </span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line">cout &lt;&lt; ::b;</span><br></pre></td></tr></table></figure><blockquote><p>命名空间可以起别名</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> veryLongName&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;hello namespace&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> shortName = veryLongName;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;veryLongName::a : &quot;</span> &lt;&lt; shortName::a &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><blockquote><p>using声明</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> LOL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sunWuKongId = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int sunWuKongId = 2; 会报错</span></span><br><span class="line">    <span class="comment">//using声明和就近原则不要同时出现,尽量避免这种情况</span></span><br><span class="line">    <span class="keyword">using</span> LOL::sunWuKongId;</span><br><span class="line">    cout &lt;&lt; sunWuKongId &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>using编译指令</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int sunWuKongId = 2; 会输出2, 就近原则</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> LOL;</span><br><span class="line">cout &lt;&lt; sunWuKongId &lt;&lt;endl;</span><br><span class="line"><span class="comment">//using编译指令和就近原则同时出现,优先使用就近原则</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LOL和KingGlory里都有sunWuKongId</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> LOL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> KingGlory;</span><br><span class="line">cout &lt;&lt; LOL::sunWuKongId &lt;&lt;endl;</span><br><span class="line"><span class="comment">//当出现多个编译指令,并且出现同名情况,使用数据依然加zon</span></span><br></pre></td></tr></table></figure><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><h3 id="内联函数引出"><a href="#内联函数引出" class="headerlink" title="内联函数引出"></a>内联函数引出</h3><blockquote><p>在c中我们经常把一些短并且执行频繁的计算写成宏，而不是函数，这样做的理由是为了执行效率，宏可以避免函数调用的开销，这些都由预处理来完成。</p></blockquote><p>但是在c++出现之后，使用预处理宏会出现两个问题：</p><ul><li><p>第一个在c中也会出现，宏看起来像一个函数调用，但是会有隐藏一些难以发现的错误。</p></li><li><p>第二个问题是c++特有的，预处理器不允许访问类的成员，也就是说预处理器宏不能用作类类的成员函数。</p></li></ul><p>为了保持预处理宏的效率又增加安全性，而且还能像一般成员函数那样可以在类里访问自如，c++引入了内联函数(inline function).</p><p>内联函数为了继承宏函数的效率，没有函数调用时开销，然后又可以像普通函数那样，可以进行参数，返回值类型的安全检查，又可以作为成员函数。</p><h3 id="预处理宏的缺陷"><a href="#预处理宏的缺陷" class="headerlink" title="预处理宏的缺陷"></a>预处理宏的缺陷</h3><blockquote><p>问题一:需要加括号保证运算的完整</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(x,y) x+y</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ret1 = <span class="built_in">ADD</span>(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span>; <span class="comment">//希望的结果是300</span></span><br><span class="line">    <span class="comment">//展开变成了 10 + 20 * 10</span></span><br><span class="line"><span class="type">int</span> ret2 = <span class="built_in">Add</span>(<span class="number">10</span>, <span class="number">20</span>) * <span class="number">10</span>; <span class="comment">//希望结果也是300</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret1:&quot;</span> &lt;&lt; ret1 &lt;&lt; endl; <span class="comment">//210</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret2:&quot;</span> &lt;&lt; ret2 &lt;&lt; endl; <span class="comment">//300</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解决方案, 需要加括号保证运算的完整</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADD(x,y) ((x) + (y))</span></span><br></pre></td></tr></table></figure><blockquote><p>问题二:即使加了括号,有些情况依然与预期效果不符</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COMPARE(x,y) ((x) &lt; (y) ? (x) : (y))</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Compare</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;COMPARE(++a, b):&quot; &lt;&lt; COMPARE(++a, b) &lt;&lt; endl; // 3</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Compare(int x,int y):&quot;</span> &lt;&lt; <span class="built_in">Compare</span>(++a, b) &lt;&lt; endl; <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为宏展开后是((++a) &lt; (b) ? (++a) : (b))</span></span><br></pre></td></tr></table></figure><h3 id="内联函数基本概念"><a href="#内联函数基本概念" class="headerlink" title="内联函数基本概念"></a>内联函数基本概念</h3><p>在c++中，预定义宏的概念是用内联函数来实现的，而<strong>内联函数本身也是一个真正的函数</strong>。内联函数具有普通函数的所有行为。唯一不同之处在于内联函数会在适当的地方像预定义宏一样展开，所以不需要函数调用的开销。因此应该不使用宏，使用内联函数。</p><ul><li>在普通函数(非成员函数)函数前面加上inline关键字使之成为内联函数。</li><li>但是必须注意必须函数体和声明结合在一起，否则编译器将它作为普通函数来对待。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>;</span><br></pre></td></tr></table></figure><p>以上写法没有任何效果，仅仅是声明函数，应该如下方式来做:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="keyword">return</span> ++;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意: 编译器将会检查函数参数列表使用是否正确，并返回值(进行必要的转换)。这些事预处理器无法完成的。</p></li><li><p>内联函数的确占用空间，但是内联函数相对于普通函数的优势只是省去了函数调用时候的压栈，跳转，返回的开销。我们可以理解为内联函数是以<strong>空间换时间</strong>。</p></li></ul><p>总结:</p><blockquote><p>内联函数优点</p></blockquote><p>解决了宏的缺陷,因为是普通函数,又带来了宏的优点,以空间换时间</p><blockquote><p>关键字inline</p></blockquote><blockquote><p>函数的声明和函数的实现同时拥有inline才算内联</p></blockquote><h3 id="类内部的内联函数"><a href="#类内部的内联函数" class="headerlink" title="类内部的内联函数"></a>类内部的内联函数</h3><blockquote><p>类内部的成员函数,都隐藏的加了inline关键字</p><p>任何在类内部定义的函数自动成为内联函数。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>()&#123; cout &lt;&lt; <span class="string">&quot;构造函数!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span></span>&#123; cout &lt;&lt; <span class="string">&quot;输出Person!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内联函数和编译器"><a href="#内联函数和编译器" class="headerlink" title="内联函数和编译器"></a>内联函数和编译器</h3><blockquote><p>c++内联编译会有一些限制，以下情况编译器可能考虑不会将函数进行内联编译：</p></blockquote><ul><li>不能存在任何形式的循环语句</li><li>不能存在过多的条件判断语句</li><li>函数体不能过于庞大</li><li>不能对函数进行取址操作</li></ul><p><strong>内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。一个好的编译器将会内联小的、简单的函数。</strong></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 5;</span><br><span class="line">int&amp; ref = a;</span><br></pre></td></tr></table></figure><p>ref并不是一个变量,只是a的别名,并不占用内存空间</p><p>引用很容易与指针混淆，它们之间有三个主要的不同：</p><ul><li>不存在空引用。引用必须连接到一块合法的内存。</li><li>一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。</li><li>引用必须在创建时被初始化。指针可以在任何时间被初始化。</li></ul><h3 id="把引用作为参数"><a href="#把引用作为参数" class="headerlink" title="把引用作为参数"></a>把引用作为参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 局部变量声明</span></span><br><span class="line">   <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">   <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> temp;</span><br><span class="line">   temp = x; <span class="comment">/* 保存地址 x 的值 */</span></span><br><span class="line">   x = y;    <span class="comment">/* 把 y 赋值给 x */</span></span><br><span class="line">   y = temp; <span class="comment">/* 把 x 赋值给 y  */</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h3 id="stringstream用法"><a href="#stringstream用法" class="headerlink" title="stringstream用法"></a>stringstream用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b, c;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">getline</span>(cin, a);</span><br><span class="line">    cin &gt;&gt; b &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">    <span class="function">stringstream <span class="title">ssin</span><span class="params">(a)</span></span>;</span><br><span class="line">    string str;</span><br><span class="line">    <span class="keyword">while</span> (ssin &gt;&gt; str)</span><br><span class="line">        <span class="keyword">if</span> (str == b) cout &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; str &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>stringstream ssin(a); 将字符串初始化成字符串流</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// swapping ostringstream objects</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>       <span class="comment">// std::string</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>      <span class="comment">// std::stringstream</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  std::stringstream ss;</span><br><span class="line"></span><br><span class="line">  ss &lt;&lt; <span class="number">100</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> foo,bar;</span><br><span class="line">  ss &gt;&gt; foo &gt;&gt; bar;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;foo: &quot;</span> &lt;&lt; foo &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;bar: &quot;</span> &lt;&lt; bar &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><blockquote><p>foo: 100<br>bar: 200</p></blockquote><h4 id="从string对象str中读取字符。遇空格结束"><a href="#从string对象str中读取字符。遇空格结束" class="headerlink" title="从string对象str中读取字符。遇空格结束"></a>从string对象str中读取字符。遇空格结束</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>; <span class="comment">//将str复制到ss</span></span><br><span class="line">string abc;</span><br><span class="line"><span class="keyword">while</span>(ss &gt;&gt; abc) <span class="comment">//相当于输入一个个的单词</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; abc &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>OUTPUT:</p><blockquote><p>hello world</p><p>hello</p><p>world</p></blockquote><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><blockquote><p>若使用普通的变量来存储的话，数据是分散的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br></pre></td></tr></table></figure><blockquote><p>但是，使用 struct 关键词，可以聚合这几种数据类型成为一个新的数据类型。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面这一串结构类型虽然很长，但是，就相当于 int 类型一样。 如同在 int 后填变量名可以声明一个整型变量。 在结构类型后面填写变量名可以声明一个结构变量。 </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;timmy;</span><br></pre></td></tr></table></figure><p>timmy 是由该结构声明的变量，它由4个成员组成。</p><p><strong>使用成员运算符 . 加上 字段名 可以访问到结构的各个成员。</strong></p><blockquote><p>timmy.name;</p><p> timmy.gender; </p><p>timmy.height; </p><p>timmy.weight;</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;timmy;</span><br><span class="line"><span class="comment">// 将Timmy的数据装入结构变量</span></span><br><span class="line"><span class="built_in">strcpy</span>(timmy.name, <span class="string">&quot;Timmy&quot;</span>);</span><br><span class="line">timmy.gender = <span class="number">1</span>;</span><br><span class="line">timmy.height = <span class="number">170.00</span>;</span><br><span class="line">timmy.weight = <span class="number">60</span>;</span><br><span class="line"><span class="comment">// 从结构变量中显示Timmy的数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, timmy.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.weight);</span><br></pre></td></tr></table></figure><h3 id="结构别名"><a href="#结构别名" class="headerlink" title="结构别名"></a>结构别名</h3><p>现在，我们想定义多个人员信息结构变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;timmy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;david;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;jane;</span><br></pre></td></tr></table></figure><blockquote><p>由于这几个结构变量的内部成员都是一致的，能不能只声明一次结构类型，后续继续使用呢？ 我们可以给结构类型声明取一个别名。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;timmy;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> david;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> jane;</span><br></pre></td></tr></table></figure><p>在第一次声明结构变量时，在 <code>struct</code> 与<code>&#123;</code>之间可以填写一个<strong>结构别名</strong>。</p><p>若以后再次需要使用这种结 构，仅需要使用 struct 加 别名 即可声明这种结构的变量。 </p><p>事实上，我们可以将结构类型声明提取到最开头。让所有的结构变量均由别名来声明。相当于我们先造 了一个模板，然后，用这个模板生成各个变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> david;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> jane;</span><br></pre></td></tr></table></figure><blockquote><p>请注意，如果结构类型声明在一个函数中，那么别名只能在函数内部使用。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 别名person无法在func2中使用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> david;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 func1 声明了一个结构类型，它的别名为 person 。并且使用别名声明了一个结构变量 timmy 。</p><p> 函数 func2 中，使用别名 person ，声明另一个结构变量，但是别名 person 无法在函数 func2 中使用， 因此将编译报错。 </p><p>如果需要在多个函数中使用结构别名，那么可以把它放到函数外面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> david;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初始化结构"><a href="#初始化结构" class="headerlink" title="初始化结构"></a>初始化结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, timmy.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.weight);</span><br></pre></td></tr></table></figure><blockquote><p>结构的初始化列表的写法需要注意如下4点： </p></blockquote><ul><li>初始化列表由花括号包括。 </li><li>花括号内为结构成员需要被初始化的值。 </li><li>**初始化值按照结构成员声明时的顺序依次排列 **</li><li>每个初始化值之间由逗号分隔。</li></ul><p>对于第三点， person 结构成员声明的顺序依次为 name 、 gender 、 height 、 weight 。 对应的初始化列表中的初始化值顺序为”timmy”、 1、170.00、 60.00。 需要严格地对应顺序。</p><h3 id="结构数组"><a href="#结构数组" class="headerlink" title="结构数组"></a>结构数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> people[<span class="number">3</span>] = &#123;</span><br><span class="line">&#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;david&quot;</span>, <span class="number">1</span>, <span class="number">175.00</span>, <span class="number">65.00</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;jane&quot;</span>, <span class="number">2</span>, <span class="number">165.00</span>, <span class="number">55.00</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i ++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> per = people[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, per.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, per.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>, per.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, per.weight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套结构"><a href="#嵌套结构" class="headerlink" title="嵌套结构"></a>嵌套结构</h3><blockquote><p>一个结构可以作为另一个结构的成员。</p></blockquote><p>例如，我们声明一个结构，用于存储通讯方式。通讯方式由电话号码，邮箱组成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">contact</span> &#123;</span><br><span class="line"><span class="type">char</span> phone[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> email[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>现在，我们需要记录每个人员的通讯方式。可以把这个结构作为人员结构的成员。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">contact</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>初始化:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;</span><br><span class="line"><span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>, &#123;<span class="string">&quot;130123456678&quot;</span>, <span class="string">&quot;timmy@xxx.com&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 . 加 字段名 可以访问到通讯方式结构。但是，你肯定还想访问其内部的成员，再次使 用 . 加 字段名 即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">contact</span> &#123;</span><br><span class="line"><span class="type">char</span> phone[<span class="number">20</span>];</span><br><span class="line"><span class="type">char</span> email[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">contact</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;</span><br><span class="line"><span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>, &#123;<span class="string">&quot;130123456678&quot;</span>, <span class="string">&quot;timmy@xxx.com&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, timmy.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, timmy.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>, timmy.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.weight);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.c.phone);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.c.email);</span><br></pre></td></tr></table></figure><h3 id="指向结构的指针"><a href="#指向结构的指针" class="headerlink" title="指向结构的指针"></a>指向结构的指针</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> *pTimmy = &amp;timmy;</span><br></pre></td></tr></table></figure><blockquote><p>由于取地址 &amp; 与取值 * 它们具有可逆关系，我们可以把指针先转为结构再使用。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (*pTimmy).name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (*pTimmy).gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, (*pTimmy).height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, (*pTimmy).weight);</span><br></pre></td></tr></table></figure><blockquote><p>由于成员运算符 . 的优先级高于取值 * 。为了让取值 * 先运算符，必须使用括号 *pTimmy 包括。</p><p>另外，C语言中提供了更加方便的写法，成员间接运算符<code> -&gt;</code> 。</p></blockquote><p><code>(*pTimmy).name</code> 等价于<code> pTimmy-&gt;name</code> 。</p><h3 id="结构在函数中传递"><a href="#结构在函数中传递" class="headerlink" title="结构在函数中传递"></a>结构在函数中传递</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="keyword">struct</span> person per)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(per.name, <span class="string">&quot;david&quot;</span>);</span><br><span class="line">per.gender = <span class="number">1</span>;</span><br><span class="line">per.height = <span class="number">175.00</span>;</span><br><span class="line">per.weight = <span class="number">65.00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;;</span><br><span class="line"><span class="built_in">change</span>(timmy);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, timmy.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.weight);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>现在，我们将结构当作参数传入函数。在函数内部修改传入的参数。 很显然，由于实参 timmy 与实参 per 是相互独立的。修改函数 change 内的 per 无法改动实参 timmy 。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="type">int</span> gender;</span><br><span class="line"><span class="type">double</span> height;</span><br><span class="line"><span class="type">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="keyword">struct</span> person *per)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(per-&gt;name, <span class="string">&quot;david&quot;</span>);</span><br><span class="line">per-&gt;gender = <span class="number">1</span>;</span><br><span class="line">per-&gt;height = <span class="number">175.00</span>;</span><br><span class="line">per-&gt;weight = <span class="number">65.00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;;</span><br><span class="line"><span class="built_in">change</span>(&amp;timmy);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, timmy.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, timmy.gender);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.height);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, timmy.weight);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但是，如果将 change 函数的参数改为指向结构的指针，情况就大不相同了。在函数 change 内部可以通 过指针，找到结构变量 timmy 。并且，对其进行修改</p></blockquote><blockquote><p>最后，将一个结构从函数返回也是可以的。从函数返回了david的数据，并且在将其赋值给了timmy。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> <span class="built_in">change</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> per;</span><br><span class="line"><span class="built_in">strcpy</span>(per.name, <span class="string">&quot;david&quot;</span>);</span><br><span class="line">per.gender = <span class="number">1</span>;</span><br><span class="line">per.height = <span class="number">175.00</span>;</span><br><span class="line">per.weight = <span class="number">65.00</span>;</span><br><span class="line"><span class="keyword">return</span> per;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span> timmy = &#123;<span class="string">&quot;timmy&quot;</span>, <span class="number">1</span>, <span class="number">170.00</span>, <span class="number">60.00</span>&#125;;</span><br><span class="line">timmy = <span class="built_in">change</span>();</span><br></pre></td></tr></table></figure><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类中的变量和函数被统一称为类的成员变量。</p><p><code>private</code>后面的内容是私有成员变量，在类的外部不能访问；<code>public</code>后面的内容是公有成员变量，在类的外部可以访问。</p><p>类的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="type">int</span> age, height;</span><br><span class="line">        <span class="type">double</span> money;</span><br><span class="line">        string books[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;I&#x27;m &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            age = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">get_age</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">add_money</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            money += x;</span><br><span class="line">        &#125;</span><br><span class="line">&#125; person_a, person_b, persons[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person c;</span><br><span class="line"></span><br><span class="line">    c.name = <span class="string">&quot;yxc&quot;</span>;      <span class="comment">// 正确！访问公有变量</span></span><br><span class="line">    c.age = <span class="number">18</span>;          <span class="comment">// 错误！访问私有变量</span></span><br><span class="line">    c.<span class="built_in">set_age</span>(<span class="number">18</span>);       <span class="comment">// 正确！set_age()是共有成员变量</span></span><br><span class="line">    c.<span class="built_in">add_money</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    c.<span class="built_in">say</span>();</span><br><span class="line">    cout &lt;&lt; c.<span class="built_in">get_age</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成变量特殊方法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">player</span> &#123;</span><br><span class="line"> <span class="type">int</span> x, y;</span><br><span class="line"> <span class="type">int</span> speed;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">     x += a * speed;</span><br><span class="line">     y += b * speed;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;c, player[<span class="number">1000</span>]; <span class="comment">//生成变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    player players[<span class="number">1000</span>]; <span class="comment">//生成变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类默认私有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class player &#123;</span><br><span class="line"> int x, y;</span><br><span class="line"> int speed;</span><br><span class="line"> void move(int a, int b)&#123;</span><br><span class="line">     x += a * speed;</span><br><span class="line">     y += b * speed;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>访问控制（private、public）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class player &#123;</span><br><span class="line">public:</span><br><span class="line"> int x, y;</span><br><span class="line"> int speed;</span><br><span class="line">private:</span><br><span class="line"> void move(int a, int b)&#123;</span><br><span class="line">     x += a * speed;</span><br><span class="line">     y += b * speed;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="C-类与结构体对比"><a href="#C-类与结构体对比" class="headerlink" title="C++类与结构体对比"></a>C++类与结构体对比</h1><p>区别：</p><blockquote><p>作用上：class默认private，struct默认public。<br>使用上：引入struct是为了让C++向后兼容C。</p></blockquote><p>推荐选用：</p><blockquote><p>若只包含一些变量结构或POD(plain old data)时，选用struct。例</p><p>如数学中的向量类。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Vec2</span>&#123;</span><br><span class="line"> <span class="type">float</span> x, y;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Vec2&amp; other)</span></span>&#123;</span><br><span class="line">     x += other.x;</span><br><span class="line">     y += other.y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>若要实现很多功能的类，则选用class</p><p>若是只有数据,函数较少的,用struct</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客搭建</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<h1 id="环境与工具准备"><a href="#环境与工具准备" class="headerlink" title="环境与工具准备"></a>环境与工具准备</h1><p><strong>本教程主要面对的是Windows用户</strong></p><ul><li>操作系统：Windows10</li><li>Node</li><li>Git</li><li>Hexo</li><li>文本编辑器(强烈推荐VSCODE)</li><li>GitHub 帐号</li><li>一个域名（强烈推荐买个域名）</li><li>云服务器（可选）</li></ul><h1 id="Node的安装"><a href="#Node的安装" class="headerlink" title="Node的安装"></a>Node的安装</h1><ol><li><p>打开Node官网，下载和自己系统相配的Node的安装程序，否则会出现安装问题。下载地址：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><br>我个人的版本是 12.19.0，目前版本已经更新到19.0.0，按照个人经验，可以选个低一些的版本，可以和我的一样，否则后面会出现各种不兼容的问题！我之前就是安装16的，系统无法识别，如果大家遇到问题建议选个低版本的！历史版本下载页面：<a href="https://nodejs.org/en/download/releases/">https://nodejs.org/en/download/releases/</a><br><a href="https://s1.vika.cn/space/2022/10/27/876780920daf4f8fb319d49ff68f17a3"><img src="https://s1.vika.cn/space/2022/10/27/876780920daf4f8fb319d49ff68f17a3" alt="image-20221027173738226"></a></p></li><li><p>下载后安装，安装的目录可以使用默认目录【C:&#x2F;Program Files&#x2F;nodejs&#x2F;】，也可以自定义路径。<br>这个环境路径切换坑也很多，如果大家C盘空间足够可以直接装C盘，如果想切换其他盘或者把环境遍历切换到自定义路径也可以，具体教程百度(不过坑比较多就是了)!</p></li><li><p>安装完成后，检查是否安装成功。在键盘按下win + R键，输入CMD，然后回车，打开CMD窗口，执行node -v命令，看到版本信息，则说明安装成功。</p></li><li><p>修改npm源。npm下载各种模块，默认是从国处服务器下载，速度较慢，建议配置成淘宝镜像。打开CMD窗口，运行如下命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li></ol><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><ol><li><p>在<code>Git BASH</code>输入如下命令安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure></li><li><p>安装完后输入hexo -v验证是否安装成功。</p></li></ol><p><a href="https://s1.vika.cn/space/2022/10/27/f05830f48da44ea98d2a55c3a6663004"><img src="https://s1.vika.cn/space/2022/10/27/f05830f48da44ea98d2a55c3a6663004" alt="image-20221027173525181"></a></p><h1 id="Github注册与创建仓库"><a href="#Github注册与创建仓库" class="headerlink" title="Github注册与创建仓库"></a>Github注册与创建仓库</h1><ol><li>进入官网 <a href="https://github.com/">https://github.com/</a><br><a href="https://bu.dusays.com/2022/05/12/627d2c0449341.webp"><img src="https://bu.dusays.com/2022/05/12/627d2c0449341.webp" alt="Github注册"></a></li><li>点击右上角的 Sign up(注册)<br><a href="https://bu.dusays.com/2022/05/12/627d2c05ee628.png"><img src="https://bu.dusays.com/2022/05/12/627d2c05ee628.png" alt="Github注册"></a></li><li>填写自己的邮箱、密码、用户名等信息，然后用邮箱验证即可完成。</li><li>注册完成后，点击右上角的<code>+</code>按钮，选择<code>New repository</code>，创建一个<code>&lt;用户名&gt;.github.io</code>的仓库。</li></ol><p><a href="https://s1.vika.cn/space/2022/10/27/7a06143d180d47088833a486732dccf5"><img src="https://s1.vika.cn/space/2022/10/27/7a06143d180d47088833a486732dccf5" alt="image-20221027110619071"></a></p><ul><li>仓库的格式必须为：<code>&lt;用户名&gt;.github.io</code> (注意：前缀必须为用户名，不要等后面404了再来为什么！！！)</li><li>Description：为描述仓库（选填）</li><li>勾选 Initialize this repository with a README 初始化一个 <a href="http://readme.md/">README.md</a> 文件</li><li>点击 Creat repository 进行创建</li></ul><p><a href="https://s1.vika.cn/space/2022/10/27/0a4dbb10ca69422ca9ccb7493d0f177a"><img src="https://s1.vika.cn/space/2022/10/27/0a4dbb10ca69422ca9ccb7493d0f177a" alt="image-20221027111641909"></a></p><h1 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h1><ol><li><p>进入官网：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> ，由于官网下载太慢可以通过淘宝的开源镜像下载 网址：<a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/v2.36.1.windows.1/">https://registry.npmmirror.com/binary.html?path=git-for-windows/v2.36.1.windows.1/</a> ，下载版本更具自己的需求选择即可。</p><p><a href="https://s1.vika.cn/space/2022/10/27/28a7d7e6ef3f4df080da8d7e8337431b"><img src="https://s1.vika.cn/space/2022/10/27/28a7d7e6ef3f4df080da8d7e8337431b" alt="image-20221027111755697"></a></p></li><li><p>下载后傻瓜式安装Git即可，安装的目录可以使用默认目录【C:&#x2F;Program Files&#x2F;Git】，也可以自定义路径。</p></li><li><p>点击电脑左下角开始即可看见<code>Git Bash</code>。</p></li></ol><p><a href="https://bu.dusays.com/2022/05/13/627d410ddc940.webp"><img src="https://bu.dusays.com/2022/05/13/627d410ddc940.webp" alt="Git Bash"></a></p><ul><li><code>Git CMD</code> 是windows 命令行的指令风格</li><li><code>Git Bash</code> 是linux系统的指令风格（建议使用）</li><li><code>Git GUI</code>是图形化界面（新手学习不建议使用）</li></ul><ol><li><p>常用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">git config -l  //查看所有配置</span><br><span class="line">git config --system --list //查看系统配置</span><br><span class="line">git config --global --list //查看用户（全局）配置</span><br></pre></td></tr></table></figure></li><li><p>配置用户名和邮箱</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">git config --global user.name &quot;你的用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>git config -l</code> 检查是否配置成功，至此git安装及配置全部完成。</p><p><a href="https://s1.vika.cn/space/2022/10/27/9115d60b377a47f3a8b79779a287ee65"><img src="https://s1.vika.cn/space/2022/10/27/9115d60b377a47f3a8b79779a287ee65" alt="image-20221027112049822"></a></p></li></ol><h1 id="连接至Github"><a href="#连接至Github" class="headerlink" title="连接至Github"></a>连接至Github</h1><ol><li><p>执行以下命令生成ssh公钥，此公钥用于你的计算机连接Github</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><p>之后打开C盘下用户文件夹下的.ssh的文件夹，会看到 id_rsa.pub</p><p><a href="https://bu.dusays.com/2022/05/14/627e87126fc59.png"><img src="https://bu.dusays.com/2022/05/14/627e87126fc59.png" alt="公钥"></a></p><p>用记事本打开上述图片中的公钥（id_rsa.pub），复制里面的内容，然后开始在github中配置ssh密钥。</p><p><a href="https://bu.dusays.com/2022/05/14/627e87156038a.png"><img src="https://bu.dusays.com/2022/05/14/627e87156038a.png" alt="记事本打开公钥"></a></p></li><li><p>将 SSH KEY 配置到 GitHub<br>进入github，点击右上角头像 选择<code>settings</code>，进入设置页后选择 <code>SSH and GPG keys</code>，名字随便起，公钥填到<code>Key</code>那一栏。</p><p><img src="https://s1.vika.cn/space/2022/10/27/4a69d999fed54ff78a5b84805d3c6a12" alt="image-20221027112347632"></p><p><a href="https://s1.vika.cn/space/2022/10/27/aa20ae7d8db34e2596638f5f031f0814"><img src="https://s1.vika.cn/space/2022/10/27/aa20ae7d8db34e2596638f5f031f0814" alt="image-20221027112416710"></a></p><p><a href="https://s1.vika.cn/space/2022/10/27/eaccde8a10eb4cde945a1ed221bb6ace"><img src="https://s1.vika.cn/space/2022/10/27/eaccde8a10eb4cde945a1ed221bb6ace" alt="image-20221027112657256"></a></p></li><li><p>测试连接，输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><a href="https://s1.vika.cn/space/2022/10/27/122bb1ef33074bee84030a525ce1ec56"><img src="https://s1.vika.cn/space/2022/10/27/122bb1ef33074bee84030a525ce1ec56" alt="image-20221027112918539"></a></p><p>出现连接到账户的信息，说明已经大功告成，至此完成了环境准备工作。</p></li></ol><h1 id="初始化-Hexo-项目"><a href="#初始化-Hexo-项目" class="headerlink" title="初始化 Hexo 项目"></a>初始化 Hexo 项目</h1><ol><li><p>在目标路径（我这里选的路径为【C:&#x2F;Hexo-Blog】）打开cmd命令窗口，执行<code>hexo init</code>初始化项目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">hexo init blog-demo(项目名)</span><br></pre></td></tr></table></figure><p><a href="https://s1.vika.cn/space/2022/10/27/1fbeb52671cf4b1daeca3660d1a31a2f"><img src="https://s1.vika.cn/space/2022/10/27/1fbeb52671cf4b1daeca3660d1a31a2f" alt="image-20221027113206776"></a></p></li><li><p>进入<code>blog-demo</code> ，输入<code>npm i</code>安装相关依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">cd blog-demo  //进入blog-demo文件夹</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p><a href="https://s1.vika.cn/space/2022/10/27/150eeb3e61c94b89a1cad2a3079b1f94"><img src="https://s1.vika.cn/space/2022/10/27/150eeb3e61c94b89a1cad2a3079b1f94" alt="image-20221027113331624"></a></p></li><li><p>初始化项目后，<code>blog-demo</code>有如下结构：</p></li></ol><p><a href="https://s1.vika.cn/space/2022/10/27/70cf503f27c54d30a31c6b13735023b7"><img src="https://s1.vika.cn/space/2022/10/27/70cf503f27c54d30a31c6b13735023b7" alt="image-20221027113438707"></a></p><p>【node_modules】：依赖包<br>【scaffolds】：生成文章的一些模板<br>【source】：用来存放你的文章<br>【themes】：主题<br>【.npmignore】：发布时忽略的文件（可忽略）<br>【_config.landscape.yml】：主题的配置文件<br>【config.yml】：博客的配置文件<br>【package.json】：项目名称、描述、版本、运行和开发等信息</p><ol><li><p>输入hexo server或者hexo s 启动项目</p><p><a href="https://s1.vika.cn/space/2022/10/27/688592f6db1448d29a2f722fc7a0bb0a"><img src="https://s1.vika.cn/space/2022/10/27/688592f6db1448d29a2f722fc7a0bb0a" alt="image-20221027113534970"></a></p></li><li><p>打开浏览器，输入地址：<a href="http://localhost:4000/">http://localhost:4000/</a> ，看到下面的效果，说明你的博客已经构建成功了。</p><p><a href="https://bu.dusays.com/2022/05/26/628e5423df640.webp"><img src="https://bu.dusays.com/2022/05/26/628e5423df640.webp" alt="博客首页"></a></p></li></ol><h1 id="将静态博客挂载到-GitHub-Pages"><a href="#将静态博客挂载到-GitHub-Pages" class="headerlink" title="将静态博客挂载到 GitHub Pages"></a>将静态博客挂载到 GitHub Pages</h1><ol><li><p>安装 hexo-deployer-git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>修改 _config.yml 文件<br>在blog-demo目录下的_config.yml，就是整个Hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的<a href="https://hexo.io/zh-cn/docs/configuration">配置描述</a>。<br>修改最后一行的配置，将repository修改为你自己的github项目地址即可，还有分支要改为<code>main</code>代表主分支（注意缩进）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YAML</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:Fomalhaut-Blog/Fomalhaut-Blog.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure></li><li><p>修改好配置后，运行如下命令，将代码部署到 GitHub（Hexo三连）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL</span><br><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy  // Git BASH终端</span><br><span class="line">hexo clean; hexo generate; hexo deploy  // VSCODE终端</span><br></pre></td></tr></table></figure><ul><li><p>hexo clean：删除之前生成的文件，若未生成过静态文件，可忽略此命令。</p></li><li><p>hexo generate：生成静态文章，可以用<code>hexo g</code>缩写</p></li><li><p>hexo deploy：部署文章，可以用<code>hexo d</code>缩写</p><p><a href="https://s1.vika.cn/space/2022/10/27/7ed7b8256d75408aa86e90cd37d0ea53"><img src="https://s1.vika.cn/space/2022/10/27/7ed7b8256d75408aa86e90cd37d0ea53" alt="image-20221027113704801"></a></p><p>注意：deploy时可能要你输入 username 和 password。</p><p>如果出现<code>Deploy done</code>，则说明部署成功了。</p><p><a href="https://s1.vika.cn/space/2022/10/27/85b61e7242214d368539d744b4778a5d"><img src="https://s1.vika.cn/space/2022/10/27/85b61e7242214d368539d744b4778a5d" alt="image-20221027113756069"></a></p><p>稍等两分钟，打开浏览器访问：<a href="https://fomalhaut-blog.github.io/">https://Fomalhaut-Blog.github.io</a> ，这时候我们就可以看到博客内容了。</p><p><a href="https://s1.vika.cn/space/2022/10/27/6de50dfe03604b07aa26fb7dd5fe1f99"><img src="https://s1.vika.cn/space/2022/10/27/6de50dfe03604b07aa26fb7dd5fe1f99" alt="image-20221027113923949"></a></p></li></ul></li></ol><h2 id="10-无法连接至Github的解决方案"><a href="#10-无法连接至Github的解决方案" class="headerlink" title="10. 无法连接至Github的解决方案"></a>10. 无法连接至Github的解决方案</h2><p>注意：当你在与Github进行ssh通信时候出现超时或者是连接被关闭的情况，可以尝试以下解决方案。</p><ol><li><p>挂代理和换网络（这个就不用多说了）</p></li><li><p><a href="https://blog.csdn.net/weixin_41287260/article/details/124368189">Git问题：解决“ssh:connect to host github.com port 22: Connection timed out”</a></p><p>这是评论区的朋友提供的，可以解决SSH连接超时等问题</p></li><li><p>开源项目<a href="https://github.com/521xueweihan/GitHub520">Github520</a></p><p>通过修改Host文件的方法解决访问速度慢的问题</p></li></ol><p>连接有效性检验：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line"># 任选其一即可</span><br><span class="line">ping github.com</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
